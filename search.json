[{"title":"新年计划","url":"/posts/8cae86ca/","content":"\n---\n\n## **一、工作日时间表（周一至周五）**\n| 时间段          | 内容                          | 具体安排/备注                                                                 |\n|-----------------|-------------------------------|------------------------------------------------------------------------------|\n| **06:30-07:00** | 晨间学习                      | - 墨墨背单词词                                             |\n| **07:00-17:00** | 工作时段                      | - 午休时间抓紧学习                             |\n| **17:00-18:30** | 力量训练                      | - 按下方「固定健身计划表」执行                                                |\n| **18:30-19:00** | 练后餐                        | - 碳水+蛋白质                                           |\n| **19:00-21:00** | 六级深度学习                  | 按下方「六级精细化学习表」执行                                              |\n| **21:00-22:00** | 公务员备考                    | - 行测：每日1个题型专项练习（如资料分析速算）<br>- 申论：摘录、做题   |\n| **22:00-23:00** | 复盘/整理内务/读书                     | - 复盘学习情况 <br>- 读书 <br>- 弹性时间（补充睡眠）                                        |\n| **23:00-06:30** | 睡眠                          | 严格保证7.5小时睡眠（佩戴睡眠眼罩+白噪音）                                   |\n\n---\n\n## **二、周末时间表（周六/周日）**\n\n- 周六上午\n\n08:30-11:00 行测模考（粉笔智能组卷）\n\n- 周日下午\n\n14:00-17:00 申论写作（往年试题或者结合本周热点事件）\n\n---\n\n## **三、固定健身计划表**\n---\n\n### **周三/周六：胸+三头**  \n| 动作                | 组数×次数       | 组间歇  | 训练目标               |  \n|---------------------|----------------|---------|------------------------|  \n| 1. 平板杠铃卧推     | 4×6-8          | 120秒   | 力量基础（80-85%1RM）  |  \n| 2. 上斜哑铃卧推     | 3×8-10         | 90秒    | 肌肥大（70-75%1RM）    |  \n| 3. 器械夹胸         | 3×12-15        | 60秒    | 孤立刺激（60%1RM）     |  \n| 4. 窄距俯卧撑       | 3×力竭         | 45秒    | 三头激活（自重）       |  \n| 5. 绳索下压         | 4×12-15        | 45秒    | 代谢压力（递减组）     |  \n\n---\n\n### **周四/周日：背+二头**  \n| 动作                | 组数×次数       | 组间歇  | 训练目标               |  \n|---------------------|----------------|---------|------------------------|  \n| 1. 正手宽握引体向上 | 4×6（辅助）    | 120秒   | 神经适应（弹力带减重） |  \n| 2. 器械高位下拉     | 3×10           | 90秒    | 背阔肌宽度（75%1RM）   |  \n| 3. 坐姿绳索划船     | 4×8            | 75秒    | 中下背厚度（80%1RM）   |  \n| 4. 哑铃交替弯举     | 3×10/侧        | 60秒    | 二头肌峰（慢速离心）   |  \n| 5. 锤式弯举         | 3×12           | 45秒    | 肱肌强化（中立握法）   |  \n\n---\n\n### **周一/周五：腿+肩**  \n| 动作                | 组数×次数       | 组间歇  | 训练目标               |  \n|---------------------|----------------|---------|------------------------|  \n| 1. 哈克机深蹲       | 4×8-10         | 120秒   | 股四头肌主导（75%1RM） |  \n| 2. 单腿腿举         | 3×10/侧        | 90秒    | 单侧平衡（60%1RM）     |  \n| 3. 罗马尼亚硬拉     | 4×8            | 90秒    | 后链强化（70%1RM）     |  \n| 4. 坐姿哑铃推举     | 4×10           | 75秒    | 三角肌前中束           |  \n| 5. 反向飞鸟         | 3×15           | 60秒    | 三角肌后束（轻重量）   |  \n| 6. 哑铃侧平举       | 递减组：12→10→8| 30秒    | 代谢应激（50%1RM起）   |  \n\n---\n\n### **科学参数说明**  \n1. **强度梯度**  \n   - 大重量复合动作：高组数（4组）+低次数（6-8次）+长间歇（120秒）  \n   - 孤立动作：低组数（3组）+高次数（12-15次）+短间歇（45-60秒）  \n\n2. **周期进阶**  \n   - 每2周增加重量：复合动作+2.5kg，孤立动作+1kg  \n   - 每4周调整次数范围（例：6-8次→8-10次→4-6次）  \n\n3. **疲劳管理**  \n   - 胸/背日：组间进行肩关节动态拉伸  \n   - 腿日：组间进行踝关节灵活性训练  \n\n以下是基于您指定动作计划的 **训练时长精确计算** 和优化建议：\n\n---\n\n### **各训练日时长分解**\n\n#### **胸+三头日（周三/周六）**\n| 动作                | 组数×次数 | 组间歇  | 单动作耗时 | 累计耗时 |\n|---------------------|----------|---------|------------|----------|\n| 平板杠铃卧推        | 4×6-8    | 120秒   | 4×(1分钟动作+2分钟休息) = **12分钟** | 12分钟   |\n| 上斜哑铃卧推        | 3×8-10   | 90秒    | 3×(1分钟+1.5分钟) = **7.5分钟**      | 19.5分钟 |\n| 器械夹胸            | 3×12-15  | 60秒    | 3×(1分钟+1分钟) = **6分钟**          | 25.5分钟 |\n| 窄距俯卧撑          | 3×力竭   | 45秒    | 3×(0.5分钟+0.75分钟) = **3.75分钟** | 29.25分钟 |\n| 绳索下压            | 4×12-15  | 45秒    | 4×(1分钟+0.75分钟) = **7分钟**      | **36.25分钟** |\n\n**总耗时**：约 **40-45分钟**（含动作间过渡）\n\n---\n\n#### **背+二头日（周四/周日）**\n| 动作                | 组数×次数 | 组间歇  | 单动作耗时 | 累计耗时 |\n|---------------------|----------|---------|------------|----------|\n| 正手引体向上        | 4×6      | 120秒   | 4×(1分钟+2分钟) = **12分钟**       | 12分钟   |\n| 高位下拉            | 3×10     | 90秒    | 3×(1分钟+1.5分钟) = **7.5分钟**    | 19.5分钟 |\n| 坐姿划船            | 4×8      | 75秒    | 4×(1分钟+1.25分钟) = **9分钟**     | 28.5分钟 |\n| 哑铃交替弯举        | 3×10/侧  | 60秒    | 3×(1.5分钟+1分钟) = **7.5分钟**    | 36分钟   |\n| 锤式弯举            | 3×12     | 45秒    | 3×(1分钟+0.75分钟) = **5.25分钟** | **41.25分钟** |\n\n**总耗时**：约 **45-50分钟**\n\n---\n\n#### **腿+肩日（周一/周五）**\n| 动作                | 组数×次数 | 组间歇  | 单动作耗时 | 累计耗时 |\n|---------------------|----------|---------|------------|----------|\n| 哈克机深蹲          | 4×8-10   | 120秒   | 4×(1.5分钟+2分钟) = **14分钟**     | 14分钟   |\n| 单腿腿举            | 3×10/侧  | 90秒    | 3×(2分钟+1.5分钟) = **10.5分钟**   | 24.5分钟 |\n| 罗马尼亚硬拉        | 4×8      | 90秒    | 4×(1.5分钟+1.5分钟) = **12分钟**   | 36.5分钟 |\n| 坐姿哑铃推举        | 4×10     | 75秒    | 4×(1分钟+1.25分钟) = **9分钟**     | 45.5分钟 |\n| 反向飞鸟            | 3×15     | 60秒    | 3×(1分钟+1分钟) = **6分钟**        | 51.5分钟 |\n| 侧平举递减组        | 12→10→8  | 30秒    | 1×(3分钟+0.5分钟) = **3.5分钟**    | **55分钟** |\n\n**总耗时**：约 **60分钟**\n\n---\n\n#### **全程时间分配**\n| 阶段                | 耗时      | 说明                      |\n|---------------------|-----------|---------------------------|\n| 动态热身            | 5-8分钟   | 针对当日目标肌群激活       |\n| 正式训练            | 40-60分钟 | 上表计算值                |\n| 静态拉伸+筋膜放松   | 7-10分钟  | 使用泡沫轴重点放松         |\n| **总计**            | **55-75分钟** | 根据训练日浮动          |\n\n---\n\n#### **时间压缩方案（紧急情况）**\n1. **超级组技术**  \n   - 将拮抗肌群动作配对（如卧推+划船），组间休息减少50%  \n   - 节省时间：约15分钟\n\n2. **递减组替代**  \n   - 将多组孤立动作改为连续递减组（如绳索下压4组→2递减组）  \n   - 节省时间：约10分钟\n\n3. **智能删减原则**  \n   - 优先保留复合动作（卧推/深蹲/硬拉），删除1个孤立动作  \n   - 节省时间：约8-12分钟\n\n---\n\n#### **科学建议**\n1. **组间歇控制**  \n   - 使用计时器APP严格管控休息时间\n\n2. **训练密度优化**  \n   - 大重量日：保证2-3分钟完整恢复  \n   - 代谢压力日：通过缩短休息提升心率（增肌减脂协同）\n\n3. **周期性调整**  \n   - 增肌期：允许延长至75分钟  \n   - 考试冲刺期：压缩至50分钟（侧重维持）\n\n\n此计划在保证科学性的前提下，将单次训练控制在 **1小时左右**（腿日稍长）。\n\n---\n\n## **四、六级精细化学习计划表**（晚19:00-21:00）\n### **阶段划分与每日任务**\n| 时间段      | 学习模块    | 具体内容                                                                 | 监测指标                  |\n|-------------|-------------|--------------------------------------------------------------------------|--------------------------|\n| **19:00-19:30** | 听力特训    | - 精听1套真题Section C（逐句听写+1.5倍速复听）<br>- 标注连读/爆破音现象 | 单句听写准确率≥90%       |\n| **19:30-20:10** | 阅读攻坚    | - 限时完成2篇仔细阅读（每篇≤15分钟）<br>- 长难句解析：拆解3个复杂句型   | 阅读正确率≥85%           |\n| **20:10-20:40** | 写作/翻译   | - 背诵并默写1个作文模板（教育/科技类）<br>- 翻译真题句子5句（中译英）   | 翻译达意度评分≥4/5       |\n| **20:40-21:00** | 错题复盘    | - 整理当日错误题到Notion错题库<br>- 标注错误类型（词汇/逻辑/技巧）       | 同类错误重复率每周下降5% |\n\n### **月度里程碑**\n| 月份   | 核心目标                  | 关键动作                                                                 |\n|--------|---------------------------|--------------------------------------------------------------------------|\n| **1月** | 词汇筑基                  | - 完成《六级核心2000词》第一轮背诵<br>- 建立听力高频场景词库            |\n| **2月** | 听力突破                  | - 精听完成10套真题Section A-C<br>- 掌握5大听力出题逻辑                  |\n| **3月** | 阅读提速                  | - 限时阅读训练每日2篇<br>- 总结8类阅读干扰项特征                        |\n| **4月** | 写作模板                  | - 积累6类话题万能句型<br>- 完成20句翻译真题精练                         |\n| **5月** | 全真模考                  | - 每周2套完整模考（含作文批改）<br>- 分析各题型时间分配                  |\n| **6月** | 考前冲刺                  | - 高频错题重做间                               |\n\n---\n\n## **五、执行辅助工具**\n1. **时间管理**：MarkDown TODOLIST\n2. **健身记录**：训记APP\n3. **学习监测**：根据TODOLIST完成情况，每周blog复盘"},{"title":"量子计算入门计划","url":"/posts/bcb9e508/","content":"\n---\n\n### **阶段 1：数学与量子力学基础**（2-3个月）\n#### **重点目标**\n- 补充必要的数学和量子力学基础\n- 理解量子比特的表示与操作\n\n#### **推荐资源**\n1. **数学基础**\n   - **书籍**：Gilbert Strang《线性代数导论》（重点：向量空间、矩阵、特征值）\n   - **补充材料**：复数运算、概率论、张量积（参考MIT OpenCourseWare）\n2. **量子力学基础**\n   - **书籍**：《Quantum Mechanics: The Theoretical Minimum》（Leonard Susskind）\n   - **在线课程**：Coursera《量子力学与量子计算》（Umesh Vazirani, 伯克利）\n\n---\n\n### **阶段 2：量子计算核心理论**（3-4个月）\n#### **重点目标**\n- 掌握量子门、量子算法和量子纠错\n- 理解量子计算的物理实现\n\n#### **推荐书籍**\n1. **经典教材**\n   - 《Quantum Computation and Quantum Information》（Nielsen & Chuang）*必读*\n   - 《Quantum Computing: A Gentle Introduction》（Rieffel & Polak）*适合入门*\n2. **算法专项**\n   - 《An Introduction to Quantum Algorithms》（Phillip Kaye）*聚焦Shor/Grover算法*\n\n#### **关键论文**\n1. 基础算法：\n   - Shor, P. (1994). [\"Algorithms for Quantum Computation\"](https://doi.org/10.1109/SFCS.1994.365700)（因数分解）\n   - Grover, L. (1996). [\"A Fast Quantum Mechanical Algorithm for Database Search\"](https://doi.org/10.1145/237814.237866)\n2. 近期进展：\n   - Harrow, A. (2009). [\"Quantum Algorithm for Linear Systems of Equations\"](https://arxiv.org/abs/0811.3171)（HHL算法）\n\n---\n\n### **阶段 3：编程与实践**（2-3个月）\n#### **重点目标**\n- 熟悉量子编程框架\n- 实现经典算法并参与开源项目\n\n#### **工具与框架**\n1. **Qiskit（IBM）**：\n   - 官方教程：[Qiskit Textbook](https://qiskit.org/textbook/)\n   - 书籍：《Learn Quantum Computing with Python and Qiskit》（Hassi Norlén）\n2. **其他框架**：\n   - Cirq（Google）/[ProjectQ](https://projectq.ch/)（ETH Zurich）\n   - Microsoft Quantum Development Kit（Q#）\n\n#### **实践项目**\n1. 实现基础算法：量子隐形传态、Deutsch-Jozsa算法\n2. 参与IBM Quantum Challenge（定期举办的编程竞赛）\n3. 探索量子机器学习库（如PennyLane）\n\n---\n\n### **阶段 4：高级主题与研究前沿**（持续学习）\n#### **研究方向选择**\n1. **量子算法优化**：QAOA（组合优化）、VQE（量子化学）\n2. **量子纠错与容错**：Surface Code、NISQ（含噪声中等规模量子计算）\n3. **量子机器学习**：量子神经网络、数据编码策略\n\n#### **必读论文**\n1. 近期顶会论文：\n   - [Quantum Topical Conference (QTC)](https://aps.org/meetings/qtc/)\n   - [Quantum Information Processing (QIP)](https://qipconference.org/)\n2. 预印本平台：\n   - [arXiv量子计算板块](https://arxiv.org/list/quant-ph/recent)\n   - [Quantum Journal](https://quantum-journal.org/)（开源期刊）\n\n---\n\n### **学习路线总结**\n| 阶段 | 时间 | 内容 | 资源 |\n|------|------|------|------|\n| 预备知识 | 2-3月 | 线性代数/量子力学基础 | Strang教材 + Susskind书籍 |\n| 核心理论 | 3-4月 | 量子门/算法/纠错 | Nielsen & Chuang + 经典论文 |\n| 编程实践 | 2-3月 | Qiskit/Cirq项目开发 | IBM教程 + 开源项目 |\n| 高级研究 | 持续 | 顶会论文跟踪 + 研究方向深耕 | arXiv + 实验室合作 |\n\n---\n\n### **附加建议**\n1. **加入社区**：\n   - Qiskit Slack频道、Quantum Computing Stack Exchange\n   - 参与本地量子计算Meetup或线上研讨会（如QWorld）\n2. **硬件拓展**：\n   - 了解超导量子比特（IBM/Goolge）与光量子（Xanadu）的实现差异\n3. **职业路径**：\n   - 实习机会：IBM Quantum、Rigetti、IonQ\n   - 学术路径：关注MIT、Caltech、ETH Zurich等团队研究方向\n\n通过以上路线，你可以逐步从理论过渡到实践，最终进入研究前沿领域。量子计算领域发展迅速，建议定期跟踪最新论文（如关注Scott Aaronson博客或John Preskill的年度综述）。","tags":["量子计算","学习计划","DeepSeek"],"categories":["量子计算笔记"]},{"title":"2462. 雇佣 K 位工人的总代价","url":"/posts/1a9fcd1b/","content":"# [leetcode-2462. 雇佣 K 位工人的总代价](https://leetcode.cn/problems/total-cost-to-hire-k-workers/description/?envType=daily-question&envId=Invalid%20Date)\n```C++\nclass Solution {\npublic:\n    long long totalCost(vector<int>& costs, int k, int candidates) {\n        int n = costs.size();\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n        int left = candidates - 1, right = n - candidates;\n        if (left + 1 < right) {\n            for (int i = 0; i <= left; ++i) {\n                q.emplace(costs[i], i);\n            }\n            for (int i = right; i < n; ++i) {\n                q.emplace(costs[i], i);\n            }\n        }\n        else {\n            for (int i = 0; i < n; ++i) {\n                q.emplace(costs[i], i);\n            }\n        }\n        long long ans = 0;\n        for (int _ = 0; _ < k; ++_) {\n            auto [cost, id] = q.top();\n            q.pop();\n            ans += cost;\n            if (left + 1 < right) {\n                if (id <= left) {\n                    ++left;\n                    q.emplace(costs[left], left);\n                }\n                else {\n                    --right;\n                    q.emplace(costs[right], right);\n                }\n            }\n        }\n        return ans;\n    }\n};\n\n```\n\n要找到最小的总代价，只涉及简单的比较而不需要做决策，显然这是一个排序问题。\n\n由于只需要排序前candidates位和后candidates位工人的代价，这是一个堆排序问题，要找到最小值，使用小顶堆。\n\nC++中使用优先队列`priority_queue`实现堆排序,代码如上。\n\n## 优先队列\n\n定义：`priority_queue<Type, Container, Functional> `\n\nType 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆\n\n```\n//升序队列\npriority_queue <int,vector<int>,greater<int> > q;\n//降序队列\npriority_queue <int,vector<int>,less<int> >q;\n\n//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）\n```\n\n优先队列是用堆实现的，它使得队列内部的元素具有优先级，改变出队顺序。因此优先队列具有队列的所有特性，包括基本操作：\n\n和队列基本操作相同: \n\n- top 访问队头元素 \n- empty 队列是否为空 \n- size 返回队列内元素个数 \n- push 插入元素到队尾 (并排序) \n- emplace 原地构造一个元素并插入队列 \n- pop 弹出队头元素 \n- swap 交换内容"},{"title":"CSAPP 第三章：程序的机器级表示","url":"/posts/adc3eca/","content":"# CSAPP 第三章：程序的机器级表示\n\n## 3.1 历史观点\n\n### 摩尔定律\n\n摩尔定律（Moore's Law：是由英特尔公司的联合创始人之一戈登·摩尔（Gordon Moore）在1965年提出的经验观察和预测。摩尔定律指出，集成电路上可容纳的晶体管数量每隔约18个月翻倍，同时造价减半。换句话说，摩尔定律认为集成电路的性能将以指数级增长，而成本则将相对下降。\n\n摩尔定律的观察基础是在集成电路中使用的晶体管数量和密度不断增加，这使得处理器的速度和性能也在不断提高。这一观察发展为一个准则，成为计算机硬件行业的重要指导原则。\n\n摩尔定律的实际效应是，在相同的芯片面积上，可以集成更多的晶体管，从而提高处理器的性能。这使得计算机和其他电子设备变得更快、更小、更强大，并带来了信息技术的快速发展。\n\n### X86和X86-64\n\nx86是一种32位的处理器架构，最初由英特尔（Intel）开发并推广。它是基于英特尔的8086和8088处理器设计的，并成为个人电脑（PC）中最为广泛使用的架构之一。x86架构支持32位寻址和32位数据处理，其指令集和寄存器设计是基于32位的。\n\nx86-64（也称为AMD64或x64）是x86架构的64位扩展。它由AMD首先引入，并得到了其他处理器制造商的采纳，包括英特尔。x86-64架构扩展了x86的寻址空间和寄存器大小，支持64位寻址和64位数据处理。这使得x86-64处理器能够处理更大的内存地址空间和执行更复杂的计算任务。与传统的32位x86架构相比，x86-64架构在处理器性能和内存管理方面有显著的优势。\n\nx86-64架构是目前个人电脑和服务器领域最为广泛使用的处理器架构之一。它支持运行32位和64位的操作系统和应用程序，提供了更高的性能和更大的灵活性。许多现代操作系统和软件都提供了针对x86-64架构的优化版本，以充分利用其性能和功能。\n\n## 3.2 程序编码\n\n### 汇编过程\n\n编译C语言程序的过程：\n\n1. 预处理（Preprocessing）：编译器对源代码进行预处理，包括宏展开、头文件包含等操作。预处理器可以根据#include指令将其他文件的内容插入源文件中，并对宏进行替换。\n\n2. 编译（Compilation）：编译器将预处理后的源代码转换为汇编代码（Assembly Code），即将C语言的代码转换为机器可以理解的低级指令。\n\n3. 汇编（Assembly）：汇编器将汇编代码转换为机器码，即可执行的二进制指令。汇编器将每条汇编指令翻译成对应的机器指令，并生成目标文件（Object File）。\n\n4. 链接（Linking）：链接器将目标文件与所需的库文件进行链接，生成最终的可执行文件（Executable File）。链接器将目标文件中的函数和变量引用与其定义进行匹配，解析符号引用，并将它们关联起来。\n\n### ATT（AT&T）和Intel的语法区别\n\nATT（AT&T）和Intel是两种不同的汇编语法格式，它们主要在语法结构和指令书写上存在一些区别。\n\n1. 语法结构：\n   - ATT语法：源操作数在前，目的操作数在后，使用逗号分隔。例如：`movl %eax, %ebx`。\n   - Intel语法：目的操作数在前，源操作数在后，使用逗号分隔。例如：`mov ebx, eax`。\n\n2. 寄存器命名：\n   - ATT语法：寄存器名称以`%`开头。例如：`%eax`。\n   - Intel语法：寄存器名称没有特殊的符号前缀。例如：`eax`。\n\n3. 立即数和内存引用：\n   - ATT语法：立即数使用`$`符号表示，内存引用使用括号表示。例如：`movl $10, %eax`（将立即数10移动到eax寄存器）；`movl (%ebx), %eax`（将ebx寄存器指向的内存地址的值移动到eax寄存器）。\n   - Intel语法：立即数没有特殊符号表示，内存引用使用方括号表示。例如：`mov eax, 10`（将立即数10移动到eax寄存器）；`mov eax, [ebx]`（将ebx寄存器指向的内存地址的值移动到eax寄存器）。\n\n4. 操作数大小：\n   - ATT语法：根据操作数的大小，使用不同的后缀来表示，如`b`表示字节（byte），`w`表示字（word），`l`表示双字（double word）。例如：`movb $1, %al`（将立即数1移动到al寄存器，al为8位寄存器）。\n   - Intel语法：操作数的大小根据指令而定，不需要显式指定后缀。例如：`mov al, 1`（将立即数1移动到al寄存器，al为8位寄存器）。\n\n需要注意的是，不同的汇编器可能支持不同的语法格式，默认使用的是特定的汇编语法。在使用汇编语言时，应根据所选的语法格式编写相应的汇编代码。\n\n## 3.3 数据格式\n\n下面是常见的C语言数据类型在x86-64架构中的Intel数据类型、汇编代码后缀和大小（以字节为单位）的表格：\n\n| C数据类型 | Intel数据类型 | 汇编代码后缀 | 大小（字节） |\n| --------- | ------------- | ------------ | ------------ |\n| char      | BYTE          | b            | 1            |\n| short     | WORD          | w            | 2            |\n| int       | DWORD         | l            | 4            |\n| long      | QWORD         | q            | 8            |\n| long long | QWORD         | q            | 8            |\n| float     | DWORD         | s            | 4            |\n| double    | QWORD         | l            | 8            |\n\n## 3.4 访问信息\n\n### X86-64中的整数寄存器\n\n| 64位 | 32位 | 16位 |  8位  | 名称            | 作用                                   |\n|------|------|------|-------|-----------------|----------------------------------------|\n| %rax | %eax | %ax  | %al   | 返回值寄存器    | 存放函数返回值                         |\n| %rbx | %ebx | %bx  | %bl   | 数据寄存器      | 被调用者保存                           |\n| %rcx | %ecx | %cx  | %cl   | 第4个参数寄存器 | 用于存放第4个函数参数                   |\n| %rdx | %edx | %dx  | %dl   | 第3个参数寄存器 | 用于存放第3个函数参数                   |\n| %rsi | %esi | %si  | %sil  | 第2个参数寄存器 | 用于存放第2个函数参数                   |\n| %rdi | %edi | %di  | %dil  | 第1个参数寄存器 | 用于存放第1个函数参数                   |\n| %rbp | %ebp | %bp  | %bpl  | 基址指针寄存器  | 被调用者保存         |\n| %rsp | %esp | %sp  | %spl  | 栈指针寄存器    | 用于指向栈顶位置                       |\n| %r8  | %r8d | %r8w | %r8b  | 第5个参数寄存器 | 用于存放第5个函数参数                   |\n| %r9  | %r9d | %r9w | %r9b  | 第6个参数寄存器 | 用于存放第6个函数参数                   |\n| %r10 | %r10d| %r10w| %r10b | 附加寄存器      | 调用者保存               |\n| %r11 | %r11d| %r11w| %r11b | 附加寄存器      | 调用者保存             |\n| %r12 | %r12d| %r12w| %r12b | 数据寄存器      | 被调用者保存                           |/\n| %r13 | %r13d| %r13w| %r13b | 数据寄存器      | 被调用者保存                           |\n| %r14 | %r14d| %r14w| %r14b | 数据寄存器      | 被调用者保存                           |\n| %r15 | %r15d| %r15w| %r15b | 数据寄存器      | 被调用者保存                           |\n\n### 操作数指示符\n\n下面是一个关于操作数格式的表格示例，使用ATT格式的汇编代码：\n\n| 类型     | 格式               | 操作数值     | 名称           |\n|----------|--------------------|--------------|----------------|\n| 立即数   | 立即值             | $42          | 立即数42       |\n| 寄存器   | 寄存器名           | %eax         | 通用寄存器     |\n| 寄存器   | 内存引用           | (%ebx)       | 寄存器间接寻址 |\n| 寄存器   | 寄存器+偏移        | 12(%ecx)     | 寄存器偏移寻址 |\n| 寄存器   | 寄存器+立即值      | 0x1234(%edx) | 立即值偏移寻址 |\n| 存储器   | 基址(, 索引)       | (%ebx, %esi) | 基址索引寻址   |\n| 存储器   | 基址(, , 缩放因子) | (%ecx,,8)    | 变址寻址       |\n\n### 数据传输指令\n\n| 指令  | 描述                                 | 数据大小      |\n|-------|--------------------------------------|---------------|\n| movb  | 传输一个字节大小的数据                 | 8位           |\n| movw  | 传输一个字（16位）大小的数据           | 16位          |\n| movl  | 传输一个双字（32位）大小的数据         | 32位          |\n| movq  | 传输一个四字（64位）大小的数据         | 64位          |\n| movzbw | 将无符号字节数据拓展为字大小            | 8位拓展为16位 |\n| movsbw | 将有符号字节数据拓展为字大小            | 8位拓展为16位 |\n\n\n在x86-64架构的汇编语言中，movl指令会将32位数据的低32位复制到目的操作数的低32位，并将目的操作数的高32位清零。\n\nmovz指令将无符号字节数据拓展为字大小，填充零位；movs指令将有符号字节数据拓展为字大小，保持符号位不变。\n\n### 压入和弹出栈数据\n\n| 指令   | 效果                      | 描述                                                                         |\n|-------|--------------------------|------------------------------------------------------------------------------|\n| pushq | 将值压入栈顶              | 该指令将给定的源操作数的值压入栈顶，并将栈指针减小8个字节（根据操作数的大小）          |\n| popq  | 将值从栈顶弹出            | 该指令将栈顶的值弹出，并将栈指针增加8个字节（根据操作数的大小），并将值存储到目的操作数中 |\n\n这些指令用于栈的操作，栈是一个后进先出（LIFO）的数据结构。在x86-64汇编语言中，栈被广泛用于函数调用、局部变量存储和寄存器保存等任务。\n\n使用pushq指令时，要指定要推入栈顶的操作数，可以是寄存器、内存位置或立即数。例如，`pushq %rax` 将将寄存器 %rax 的值压入栈顶。\n\n使用popq指令时，要指定从栈顶弹出的目的操作数，可以是寄存器或内存位置。例如，`popq %rbx` 将从栈顶弹出一个值，并将其存储到寄存器 %rbx。\n\n这些指令对栈指针进行相应的调整，以确保栈的正确管理（可以发现，栈是倒过来的）。在使用这些指令时，需要注意栈的正确使用，以避免栈溢出或栈指针错误的情况。\n\n## 3.5 算术逻辑操作\n\n| 指令   | 效果                  | 描述                                                                                       |\n|-------|----------------------|--------------------------------------------------------------------------------------------|\n| leaq  | 计算有效地址            | 将源操作数的内存地址计算并存储到目的操作数中                                               |\n| inc   | 增加操作数的值           | 将源操作数的值增加1，结果存储到目的操作数中                                               |\n| dec   | 减少操作数的值           | 将源操作数的值减少1，结果存储到目的操作数中                                               |\n| neg   | 取反操作数的值           | 将源操作数的值取反（取负），结果存储到目的操作数中                                         |\n| not   | 取反操作数的位           | 将源操作数的位取反，结果存储到目的操作数中                                                 |\n| add   | 加法操作               | 将源操作数的值与目的操作数相加，结果存储到目的操作数中                                      |\n| sub   | 减法操作               | 将源操作数的值与目的操作数相减，结果存储到目的操作数中                                      |\n| imul  | 有符号乘法操作           | 将源操作数与目的操作数进行有符号乘法运算，结果存储到目的操作数中                             |\n| xor   | 异或操作               | 将源操作数与目的操作数进行按位异或运算，结果存储到目的操作数中                               |\n| or    | 或操作                | 将源操作数与目的操作数进行按位或运算，结果存储到目的操作数中                                 |\n| and   | 与操作                | 将源操作数与目的操作数进行按位与运算，结果存储到目的操作数中                                 |\n| sal   | 左移算术（带符号）     | 将源操作数的位向左移动指定的位数，空位用0填充，结果存储到目的操作数中（带符号左移）         |\n| shl   | 左移逻辑（无符号）     | 将源操作数的位向左移动指定的位数，空位用0填充，结果存储到目的操作数中（无符号左移）         |\n| sar   | 右移算术（带符号）     | 将源操作数的位向右移动指定的位数，空位用符号位填充，结果存储到目的操作数中（带符号右移）     |\n| shr   | 右移逻辑（无符号）     | 将源操作数的位向右移动指定的位数，空位用0填充，结果存储到目的操作数中（无符号右移）         |\n\n### 加载有效地址\n\nleaq和movq基本等同，但是目的数必须是寄存器。\n\nleaq可以用来做一些巧妙的操作，但是往往这和设计用途无关。\n\n### 一元和二元操作\n\n一元操作的源和目的是同一个数。\n\n二元操作的源操作数是第一个，目的操作数是第二个。\n\n例如 subq %rax,%rdx是使%rdx的值变为%rdx减去%rax的值。\n\n### 移位操作\n\n左移指令有两个名字：SAl和SHL。两者的效果是一样的。，都是在右面填上0。\n\n右移指令在x86汇编语言中，SAR和SHR指令的不同字母来自以下单词：\n\nSAR：Shift Arithmetic Right（算术右移）\nSHR：Shift Logical Right（逻辑右移）\n\n移位量可以是一个立即数，也可以放在单字节寄存器%cl中。\n\n### 特殊的算术操作\n\n| 指令   | 效果                       | 描述                                                                      |\n|-------|---------------------------|--------------------------------------------------------------------------|\n| imulq | 有符号乘法操作（四字节）     | 将源操作数与目的操作数进行有符号乘法运算，结果存储到目的操作数中              |\n| mulq  | 无符号乘法操作（四字节）     | 将源操作数与目的操作数进行无符号乘法运算，结果存储到目的操作数中              |\n| cqto  | 扩展符号位（四字节到八字节） | 将四字节的有符号值扩展到八字节，并存储到目的操作数中（对于imulq和divq指令的操作准备） |\n| idivq | 有符号除法操作（四字节）     | 将目的操作数除以源操作数，商存储到目的操作数中，余数存储到%rdx寄存器中         |\n| divq  | 无符号除法操作（四字节）     | 将目的操作数除以源操作数，商存储到目的操作数中，余数存储到%rdx寄存器中         |\n\n对于imulq指令，当只使用一个操作数时，它会将源操作数与目的操作数（即%rax寄存器）进行有符号乘法运算，并将结果存储在%rdx:%rax寄存器对中。这个寄存器对存储了64位结果，其中高32位存储在%rdx寄存器中，低32位存储在%rax寄存器中。\n\n## 3.6 控制\n\n有时需要有条件的执行，数据决定指令执行的顺序，这时就要使用jump指令改变执行顺序。\n\n### 条件码\n\n条件码是指在计算机体系结构中用于记录运算结果状态的一组标志位。常见的条件码包括进位标志（Carry Flag，CF）、零标志（Zero Flag，ZF）、符号标志（Sign Flag，SF）和溢出标志（Overflow Flag，OF）。\n\n1. 进位标志（CF）：\n   - 用途：记录算术和逻辑运算中的进位或借位情况。\n   - 设置条件：当无符号数相加产生进位，或者无符号数相减产生借位时，CF被设置为1；否则，CF被设置为0。\n\n2. 零标志（ZF）：\n   - 用途：记录运算结果是否为零。\n   - 设置条件：当运算结果为零时，ZF被设置为1；否则，ZF被设置为0。\n\n3. 符号标志（SF）：\n   - 用途：记录运算结果的符号。\n   - 设置条件：当运算结果为负数时，SF被设置为1；当运算结果为非负数时，SF被设置为0。\n\n4. 溢出标志（OF）：\n   - 用途：记录有符号数运算中是否发生溢出。\n   - 设置条件：当有符号数相加或相减产生溢出时，OF被设置为1；否则，OF被设置为0。\n\n这些条件码在程序执行过程中，可以被用于控制程序的流程，比如进行条件判断、循环等。根据条件码的状态，程序可以根据不同的条件选择不同的执行路径。例如，使用条件跳转指令根据CF、ZF、SF和OF的状态进行分支判断，从而实现程序的控制流程。\n\n好的，下面是对x86-64架构下的`cmp`和`test`指令进行说明的表格：\n\n| 指令   | 效果                   | 描述                                                                      |\n|-------|-----------------------|--------------------------------------------------------------------------|\n| cmp   | 比较操作数              | 比较源操作数和目的操作数的值，根据比较结果设置标志位                          |\n| test  | 位测试操作              | 对源操作数和目的操作数进行按位与运算，并根据结果设置标志位                      |\n\n这两个指令，cmp等价于sub，test等价于and，唯一的区别在于，这个操作只改变条件码而不改变操作数。\n\n### 访问条件码\n\n在x86-64架构下，`set`指令是一个条件设置指令，用于根据某个条件的结果设置一个目标操作数的值。它根据条件的真假结果设置目标操作数的值为1或0。`set`指令通常与条件跳转指令（如`jmp`、`jz`等）一起使用，用于在条件满足时设置一个寄存器或内存位置的值。\n\n`set`指令有多个变种，每个变种都对应不同的条件码（flags）和条件判断。这些变种包括：\n\n- `seta` / `setnbe`：如果无符号数大于（Above）指定条件，则将目标操作数设置为1，否则设置为0。\n- `setae` / `setnb` / `setnc`：如果无符号数大于等于（Above or Equal）指定条件，则将目标操作数设置为1，否则设置为0。\n- `setb` / `setnae` / `setc`：如果无符号数小于（Below）指定条件，则将目标操作数设置为1，否则设置为0。\n- `setbe` / `setna`：如果无符号数小于等于（Below or Equal）指定条件，则将目标操作数设置为1，否则设置为0。\n- `sete` / `setz`：如果等于（Equal）指定条件，则将目标操作数设置为1，否则设置为0。\n- `setg` / `setnle`：如果有符号数大于（Greater）指定条件，则将目标操作数设置为1，否则设置为0。\n- `setge` / `setnl`：如果有符号数大于等于（Greater or Equal）指定条件，则将目标操作数设置为1，否则设置为0。\n- `setl` / `setnge`：如果有符号数小于（Less）指定条件，则将目标操作数设置为1，否则设置为0。\n- `setle` / `setng`：如果有符号数小于等于（Less or Equal）指定条件，则将目标操作数设置为1，否则设置为0。\n- `setne` / `setnz`：如果不等于（Not Equal）指定条件，则将目标操作数设置为1，否则设置为0。\n\n这些变种可以根据特定的条件码和条件判断来设置目标操作数的值，目标操作数可以是一个寄存器或内存位置。例如，如果指令的结果满足\"等于\"条件，`sete %al`会将AL寄存器的值设置为1；否则，它将设置AL寄存器的值为0。\n\n### 跳转\n\n1. 无条件跳转：\n无条件跳转指令用于无条件地改变程序的执行流程，跳转到指定的代码位置。其中，常见的无条件跳转指令有：\n- `jmp`：无条件跳转到目标地址，目标地址可以是一个绝对地址或相对地址。\n  例如：`jmp label` 将会无条件跳转到标签为 `label` 的位置。\n\n2. 直接/间接跳转：\n直接跳转指令通过指定目标地址来改变程序的执行流程。目标地址可以通过直接给出或者存储在寄存器或内存中。常见的直接跳转指令有：\n- `jmp reg`：跳转到寄存器中存储的目标地址。\n  例如：`jmp eax` 将会跳转到`eax`寄存器中存储的地址。\n- `jmp [mem]`：跳转到内存中存储的目标地址。\n  例如：`jmp [0x1000]` 将会跳转到地址为`0x1000`处存储的目标地址。\n- 跳转目标是从寄存器或者内存位置读出的，成为间接跳转，写法是加一个操作符`*`，例如`jmp *%rax`。\n\n1. 有条件跳转：\n有条件跳转指令根据特定的条件码（flags）和条件判断来确定是否进行跳转。根据条件的真假结果，可以有符号数和无符号数的情况。常见的有条件跳转指令有：\n- 有符号数条件跳转：\n  - `jg` / `jnle`：如果有符号数大于（Greater）指定条件，则跳转。\n  - `jge` / `jnl`：如果有符号数大于等于（Greater or Equal）指定条件，则跳转。\n  - `jl` / `jnge`：如果有符号数小于（Less）指定条件，则跳转。\n  - `jle` / `jng`：如果有符号数小于等于（Less or Equal）指定条件，则跳转。\n  - `je` / `jz`：如果等于（Equal）指定条件，则跳转。\n  - `jne` / `jnz`：如果不等于（Not Equal）指定条件，则跳转。\n  例如：`jg label`将会在有符号数大于指定条件时跳转到标签为`label`的位置。\n  \n- 无符号数条件跳转：\n  - `ja` / `jnbe`：如果无符号数大于（Above）指定条件，则跳转。\n  - `jae` / `jnb` / `jnc`：如果无符号数大于等于（Above or Equal）指定条件，则跳转。\n \n\n - `jb` / `jnae` / `jc`：如果无符号数小于（Below）指定条件，则跳转。\n  - `jbe` / `jna`：如果无符号数小于等于（Below or Equal）指定条件，则跳转。\n  - `je` / `jz`：如果等于（Equal）指定条件，则跳转。\n  - `jne` / `jnz`：如果不等于（Not Equal）指定条件，则跳转。\n  例如：`ja label`将会在无符号数大于指定条件时跳转到标签为`label`的位置。\n\n这些跳转指令可以根据特定条件的结果来决定是否跳转到目标位置，从而实现程序执行流程的控制。\n\n在计算机中，PC（程序计数器）用于存储下一条要执行的指令的地址。在跳转指令的执行过程中，PC会被修改为跳转目标的地址，以实现代码的跳转和程序流程的改变。\n\n相对跳转（PC相对寻址）是一种常见的跳转方式，其中跳转目标相对于当前指令的地址进行偏移。PC相对寻址使用一个相对于当前指令的偏移量，该偏移量可以是正数或负数，用于计算跳转目标的地址。\n\n在x86-64架构中，相对跳转通常使用有符号的偏移量。例如，`jmp rel32` 指令使用一个32位的有符号相对偏移量，该偏移量会与当前指令的地址相加，从而计算出跳转目标的地址。相对跳转指令会将这个计算出的跳转目标地址加载到PC中，使得程序执行流程转移到该地址处。\n\n例如，假设当前指令的地址为0x1000（jmp的下一条指令），执行了一条相对跳转指令 `jmp rel32`，偏移量为-10。那么，PC会被修改为 0x1000 + (-10) = 0xFF6 的值，即跳转到地址 0xFF6 执行下一条指令。\n\nPC相对寻址允许程序在不同的代码位置之间进行跳转，提供了灵活性和动态性，可以根据程序的需求在不同的条件下选择不同的执行路径。\n\n### 用条件控制\\条件传送实现条件分支\n\n在x86-64架构下，条件控制和条件传送是两种不同的方式来实现条件分支：\n\n- 条件控制是通过条件跳转指令（如`jmp`、`jz`、`jnz`等）来实现条件分支。程序在执行到条件跳转指令时，会根据指定的条件判断是否满足跳转条件，如果满足，则会跳转到指定的目标位置执行相应的代码；如果不满足，则会继续顺序执行下一条指令。这种方式需要进行跳转操作，可能会导致指令预测失败，从而降低性能。\n\n- 条件传送是通过条件传送指令（如`cmov`系列指令）来实现条件分支。这些指令会根据条件判断来选择是否将数据从源操作数传送到目标操作数。如果条件满足，则将源操作数的值传送到目标操作数；如果条件不满足，则不进行传送操作。这种方式不需要跳转操作，因此可以避免指令预测失败的开销，提高性能。\n\n条件传送方式在指令流水线中更高效，主要是因为它避免了分支预测失败的开销，减少了流水线的清空操作，并且提高了指令级并行性，允许更多的指令同时执行。这使得条件传送在一些需要频繁进行条件分支的代码段中能够更好地发挥性能优势。然而，需要根据具体的代码特点和性能需求进行权衡选择，有时条件控制方式可能更适合。\n\n`cmov`指令在条件传送中起到了关键的作用。它是条件传送指令中的一种，用于执行条件传送操作。`cmov`指令的基本语法如下：\n\n```\ncmovXX dest, src\n```\n\n其中，`XX`是条件码（如`e`、`ne`、`g`、`ge`、`l`、`le`等），根据不同的条件码可以执行不同的条件判断。`dest`表示目标操作数，`src`表示源操作数。\n\n`cmov`指令的工作原理是先进行条件判断，如果条件满足，则将源操作数的值传送到目标操作数；如果条件不满足，则不进行传送操作。这样可以根据条件的真假来灵活选择数据传送的方式，而不需要进行跳转操作。\n\n通过使用`cmov`指令进行条件传送，可以提高程序的执行效率，尤其在一些需要频繁进行条件分支的代码段中。然而，需要注意的是，`cmov`指令的执行时间可能会比条件跳转指令长，因此在一些执行时间敏感的代码段中，需要权衡选择合适的方式来实现条件分支。\n\n只有在每个分支都容易计算的时候，才会使用条件传送，这样能避免条件控制带来的预测错误的开销。当然也会有一些特殊的情况，比如条件不成立，则分支中有空指针，显然不能进行条件传送。所以尽管条件传送效率更高，但是大部分情况下仍然选择条件控制。\n\n## 3.7 过程\n\n### 运行时栈\n\nx86-64架构中的运行时栈（Runtime Stack）是一种用于支持函数调用和局部变量存储的数据结构。它是计算机内存中的一块特殊区域，由处理器和操作系统共同管理。\n\n运行时栈通常以“栈”的形式组织数据，采用后进先出（LIFO）的方式进行操作。它在函数调用和返回过程中提供了一种有效的方式来保存和恢复现场，包括函数参数、返回地址和局部变量等。\n\n以下是一些关于x86-64运行时栈的重要概念和特点：\n\n1. 栈指针（Stack Pointer）：在x86-64中，栈指针是一个特殊的寄存器，通常称为`RSP`（64位模式下）或者`ESP`（32位模式下）。栈指针指向栈顶的位置，即最后一个入栈的元素。\n\n2. 栈帧（Stack Frame）：栈帧是函数在运行时栈中的一块区域，用于存储函数的局部变量、函数参数和其他与函数执行相关的数据。每次函数调用时，都会创建一个新的栈帧，用于保存当前函数的上下文信息。\n\n3. 函数调用过程：当一个函数被调用时，以下步骤通常发生在运行时栈中：\n   - 将函数参数压入栈中。\n   - 保存当前函数的返回地址。\n   - 分配栈空间用于存储局部变量。\n   - 将控制转移到被调用函数的入口点。\n   - 在被调用函数中，可以访问参数和局部变量。\n   - 当函数执行完毕时，恢复返回地址，并释放栈空间。\n   - 将控制返回给调用函数。\n\n4. 栈溢出（Stack Overflow）：由于运行时栈的大小是有限的，当递归调用层级过深或者在函数中分配过多的局部变量时，可能会导致栈空间不足，从而发生栈溢出错误。\n\n运行时栈在x86-64架构中是一个重要的组成部分，它提供了函数调用和局部变量存储的机制。了解运行时栈的工作原理和特点有助于理解函数调用、栈帧布局和内存管理等底层的运行时机制。\n\n### 转移控制\n\n在x86-64架构中，`call`（调用）和`ret`（返回）是用于函数调用和返回的指令。\n\n1. `call` 指令：\n   - `call` 指令用于调用一个函数或跳转到指定的代码段。\n   - 在执行 `call` 指令时，会将当前指令的下一条指令的地址（即返回地址）压入栈中，保存现场。\n   - 然后，`call` 指令会将控制转移到目标函数或代码段的入口点，开始执行目标代码。\n   - 当目标函数或代码段执行完毕后，通过 `ret` 指令返回调用者。\n\n2. `ret` 指令：\n   - `ret` 指令用于函数返回，将控制权从被调用函数返回到调用者。\n   - 在执行 `ret` 指令时，它会从栈中弹出保存的返回地址，并将控制转移到该地址所指向的指令。\n   - 这样，程序的执行流程回到了调用者处，继续执行后续的代码。\n\n在函数调用过程中，`call` 和 `ret` 指令的配对使用，确保了函数的正确调用和返回：\n\n1. 调用者：\n   - 调用者在准备调用函数之前，将函数参数压入栈中，按照函数调用约定传递参数。\n   - 调用者使用 `call` 指令将控制转移给被调用函数，并将返回地址压入栈中。\n\n2. 被调用函数：\n   - 被调用函数接收参数，并在栈上分配空间用于保存局部变量。\n   - 被调用函数执行完毕后，使用 `ret` 指令将控制权返回给调用者。\n\n3. 调用者继续执行：\n   - 当被调用函数执行完毕，控制权返回到调用者处。\n   - 调用者从栈中弹出返回地址，并继续执行后续的代码。\n\n这样，通过 `call` 和 `ret` 指令的组合，实现了函数之间的调用和返回，确保了程序的正确执行流程和返回路径。\n\n### 数据传送\n\nx86-64中，通过寄存器传递参数，但是有上限（详情见**86-64中的整数寄存器**），多于的参数只能通过栈传递。\n\n### 栈上的局部储存\n\n大部分情况下，不需要超出寄存器大小的本地存储趋于，但是有时候局部数据必须存放在内存中：\n\n- 寄存器不足够存放所有的本地数据\n- 对一个局部变量使用地址运算符'&',因此必须产生一个地址\n- 局部变量是数组或者结构。\n\n### 寄存器中的局部储存空间\n\n寄存器组是唯一被所有过程共享的资源，虽然给定时刻只有一个过程是活动的，但是我们仍然必须确保，被调用者不会覆盖调用者稍后会使用的寄存器。\n\n因此，x86-64采用了统一的寄存器使用管理，所有的过程都必须遵循。\n\n按照惯例，寄存器%rbx、%rbp和%r12-%r15被划分为被调用者保存寄存器。被调用的过程要么保证这个值不变，要么压入栈中，在返回时复原这个值。\n\n其它寄存器，除了栈指针%rsp，所有函数都可以任意修改这个寄存器。\n\n## 3.8 数组的分配和访问\n\n### 基本原则\n\n在计算数组元素的地址时，可以使用以下公式：\n\n```\naddress = base_address + element_size * index\n```\n\n其中：\n- `address` 是数组元素的地址。\n- `base_address` 是数组的起始地址或首元素的地址。\n- `element_size` 是每个数组元素的大小（以字节为单位）。\n- `index` 是要访问的元素的索引（从0开始）。\n\n通过将索引乘以每个元素的大小，然后加上起始地址，可以计算出特定元素的地址。\n\n例如，假设有一个数组 `arr`，起始地址为 `0x1000`，每个元素的大小为 4 字节（32位整数），要计算第三个元素（索引为 2）的地址，可以使用以下公式：\n\n```\naddress = 0x1000 + 4 * 2\n```\n\n计算结果为 `0x1008`，即第三个元素的地址为 `0x1008`。\n\n### 嵌套的数组\n\n如果数组是嵌套的，也就是多维数组，计算数组元素的地址就会稍微复杂一些。在多维数组中，每个维度都有一个对应的索引，因此需要使用多个索引来定位数组中的元素。\n\n对于一个二维数组，可以使用以下公式来计算元素的地址：\n\n```\naddress = base_address + (element_size * (row_index * columns + column_index))\n```\n\n其中：\n- `address` 是数组元素的地址。\n- `base_address` 是数组的起始地址或首元素的地址。\n- `element_size` 是每个数组元素的大小（以字节为单位）。\n- `row_index` 是行索引，指定要访问的行。\n- `column_index` 是列索引，指定要访问的列。\n- `columns` 是数组的列数，表示每行有多少个元素。\n\n在一个三维数组中，需要使用类似的公式，但是会涉及更多的索引和维度。\n\n需要注意的是，对于多维数组，计算地址的公式可能会因不同的数组排列方式（行主序、列主序等）而有所不同。在一些情况下，还可能需要进行乘法优化或使用偏移量来处理特殊的嵌套数组布局。\n\n### 定长数组和变长数组\n\n对于定长数组，每个元素的大小已知且相同，可以使用之前提到的公式来计算元素的地址。\n\n例如，对于一个定长数组 `arr`，起始地址为 `base_address`，每个元素的大小为 `element_size`，要计算第 `index` 个元素的地址，可以使用以下公式：\n\n```\naddress = base_address + (element_size * index)\n```\n\n其中 `address` 是数组元素的地址。\n\n对于变长数组（例如动态分配的数组），情况略有不同。由于数组的大小是在运行时确定的，每个元素的地址无法使用简单的公式进行计算。通常，变长数组的元素是通过指针或引用进行访问，而不是直接计算地址。\n\n在使用变长数组时，通常需要使用动态内存分配函数（例如 `malloc()`）在堆上分配内存，并使用指针来访问数组元素。此时，可以使用指针运算来访问数组元素，而不需要直接计算地址。\n\n例如，假设有一个变长数组 `arr`，通过动态内存分配函数 `malloc()` 在堆上分配了一块内存，并返回了指向数组首元素的指针 `arr_ptr`。要访问第 `index` 个元素，可以使用以下指针运算：\n\n```c\nelement_ptr = arr_ptr + index\n```\n\n其中 `element_ptr` 是指向第 `index` 个元素的指针。\n\n需要注意的是，对于变长数组，必须在分配内存后才能进行访问，而且还需要确保在不再使用数组时释放相关的内存，以避免内存泄漏。\n\n总结起来，对于定长数组，可以使用公式计算元素的地址。对于变长数组，通常需要使用指针来访问数组元素。\n\n## 3.9 异质的数据结构\n\n### 结构体\n\n在x86-64架构中，结构体的实现与其他架构类似，使用一系列的字节来存储结构体的成员。下面是一种常见的实现方式：\n\n1. 内存对齐：结构体在内存中存储时，通常要进行内存对齐，以保证结构体成员在内存中的地址是对齐的。这有助于提高内存访问的效率。可以使用编译器提供的特定指令或指令集来实现内存对齐。\n\n2. 成员偏移：每个结构体成员在结构体中的偏移量决定了其在内存中的位置。编译器会根据结构体成员的类型和对齐要求计算出偏移量，并将成员放置在适当的位置。\n\n3. 结构体大小：结构体的大小取决于其成员的类型和排列方式。成员之间可能存在填充字节，以确保内存对齐。\n\n以下是一个示例结构体的定义和实现：\n\n```c\n#include <stdio.h>\n\n// 定义结构体\nstruct Person {\n    char name[20];\n    int age;\n    float height;\n};\n\nint main() {\n    // 创建结构体变量\n    struct Person person;\n\n    // 访问结构体成员并赋值\n    sprintf(person.name, \"John\");\n    person.age = 25;\n    person.height = 1.75;\n\n    // 输出结构体成员的值\n    printf(\"Name: %s\\n\", person.name);\n    printf(\"Age: %d\\n\", person.age);\n    printf(\"Height: %.2f\\n\", person.height);\n\n    return 0;\n}\n```\n\n在上述示例中，我们定义了一个名为`Person`的结构体，它包含了一个字符数组`name`、一个整数`age`和一个浮点数`height`作为成员。在`main()`函数中，我们创建了一个`person`结构体变量，并通过点运算符`.`来访问和赋值结构体的成员。最后，我们使用`printf()`函数输出结构体成员的值。\n\n需要注意的是，结构体的具体实现可能因编译器、编译选项和对齐要求等因素而有所差异。因此，在实际编程中，最好遵循编译器的规范，并确保对结构体的访问和操作是正确和可移植的。\n\n### 联合\n\n联合（Union）是一种特殊的数据类型，允许在相同的内存位置存储不同类型的数据。与结构体不同，联合只能同时存储其中一个成员的值。以下是联合的实现方式：\n\n1. 内存共享：联合的所有成员共享相同的内存空间，其大小取决于最大成员的大小。这意味着联合的不同成员会占用相同的内存位置。\n\n2. 成员访问：通过使用联合变量的名称和成员名称，可以访问和操作联合的成员。\n\n下面是一个简单的联合示例：\n\n```c\n#include <stdio.h>\n\nunion Data {\n    int intValue;\n    float floatValue;\n    char stringValue[20];\n};\n\nint main() {\n    union Data data;\n\n    data.intValue = 42;\n    printf(\"Integer value: %d\\n\", data.intValue);\n\n    data.floatValue = 3.14;\n    printf(\"Float value: %.2f\\n\", data.floatValue);\n\n    sprintf(data.stringValue, \"Hello\");\n    printf(\"String value: %s\\n\", data.stringValue);\n\n    return 0;\n}\n```\n\n在上述示例中，我们定义了一个名为`Data`的联合，它包含了一个整数`intValue`、一个浮点数`floatValue`和一个字符数组`stringValue`作为成员。在`main()`函数中，我们创建了一个`data`联合变量，并通过点运算符`.`来访问和赋值联合的成员。需要注意的是，对于联合来说，我们只能同时访问其中一个成员，对一个成员的赋值会影响其他成员。\n\n请注意，联合的使用需要谨慎，特别是在涉及类型转换和内存访问方面。由于联合的成员共享相同的内存空间，对一个成员的修改可能会影响其他成员的值。因此，在使用联合时，请确保正确地访问和操作联合的成员，以避免潜在的错误和问题。\n\n### 数据对齐\n\n数据对齐是为了提高内存访问效率和处理器的性能而进行的一种优化技术。数据对齐确保数据在内存中按照特定的规则进行存储，使得访问对齐的数据可以更快速地进行，减少内存访问的开销。\n\n以下是一些原因说明为什么要进行数据对齐：\n\n1. 提高内存访问效率：处理器通常以特定的块大小（例如字节、字、双字等）从内存中读取数据。如果数据按照处理器的访问要求进行对齐，处理器可以直接从内存中读取整块数据，而不需要进行额外的操作。这样可以提高内存读取的效率。\n\n2. 减少内存访问次数：当结构体或对象中的成员按照对齐要求进行排列时，可以避免在访问不对齐的数据时进行多次内存读取。相反，可以通过一次对齐的读取来获取多个成员的值，从而减少内存访问的次数，提高效率。\n\n需要注意的是，数据对齐可能会导致一些额外的内存空间被填充，以确保成员之间的对齐。这些额外的填充字节可能会增加结构体或对象的大小。因此，在设计数据结构时，需要权衡内存使用和访问效率之间的平衡。\n\n数据对齐是由编译器根据平台的要求自动完成的。大多数编程语言和编译器提供了一些机制，如编译器指令、编译选项或属性，以控制数据对齐的方式和行为。\n\n## 3.10 在机器级程序中将控制欲数据结合起来\n\n### 指针\n\nC语言的指针是其核心特性之一，它允许直接访问内存地址，进而实现高效的内存操作和数据结构表示。指针在C语言中扮演着重要的角色，并且对于理解机器代码和底层内存操作至关重要。\n\n首先，让我们讨论指针的概念。指针是一个变量，它存储了内存地址的值。可以通过使用取地址运算符`&`将变量的地址赋给指针变量。例如，`int *ptr;`声明了一个指向整数的指针。然后，通过将某个整数变量的地址赋给`ptr`，可以使`ptr`指向该变量。\n\n指针的重要性在于它提供了直接访问内存的能力。通过解引用操作符`*`，可以访问指针指向的内存位置上存储的值。例如，`*ptr`将返回指针`ptr`指向的整数值。\n\n指针的使用要正确且谨慎。以下是一些指针相关的关键原则：\n\n- 每个指针都有值\n- 指针用'&'运算符创建\n- 数组与指针紧密联系\n- *操作符用来间接引用指针\n- 将指针强制转化类型，只改变类型不改变值\n- 指针也可以指向函数，指向的是第一条指令的地址\n\n### 内存越界引用和缓存区溢出\n\n- 内存越界引用（Memory Out-of-Bounds Reference）：\n   内存越界引用指的是程序试图访问超出其分配内存范围的位置的行为。当程序访问超过其分配内存边界的位置时，可能会导致未定义的行为和安全漏洞。\n\n   例如，在C语言中，如果你声明了一个数组 `int arr[5];` ，它有五个元素，索引从0到4。如果你试图访问 `arr[5]` 或者 `arr[100]`，这就是内存越界引用，因为你超出了数组的有效索引范围。这样的行为可能会导致程序崩溃、数据损坏或者安全漏洞，因为你可能会误用或覆盖其他内存区域的数据。\n\n   内存越界引用可能导致的问题包括程序崩溃、内存泄漏、数据损坏、安全漏洞（如利用越界引用进行代码执行）等。因此，在编写程序时，务必要注意数组和指针的边界，并确保不发生内存越界引用。\n\n- 缓冲区溢出（Buffer Overflow）：\n   缓冲区溢出是指向一个缓冲区写入超过其容量的数据量的行为。当程序向一个固定大小的缓冲区写入超过其可容纳的数据时，多余的数据会覆盖到相邻的内存区域，可能导致程序崩溃或者被攻击者利用。\n\n   缓冲区溢出通常发生在使用不安全的字符串处理函数（如C语言中的 `strcpy`、`sprintf` 等）时，因为这些函数不会检查目标缓冲区的容量。攻击者可以利用缓冲区溢出漏洞，覆盖关键数据、修改程序行为、执行恶意代码等。\n\n   为了避免缓冲区溢出漏洞，可以使用安全的字符串处理函数（如C语言中的 `strncpy`、`snprintf` 等），并且要仔细检查输入数据的大小，确保不会写入超过缓冲区容量的数据。\n\n### 对抗缓存区溢出攻击\n\n1. 栈随机化（Stack Randomization）：\n   栈随机化是一种安全增强技术，它通过在每次程序运行时随机选择栈的起始地址来改变栈的内存布局。在 Linux 系统中，栈随机化是 ASLR（Address Space Layout Randomization）的一部分。\n\n   ASLR 通过随机化程序的内存布局，包括栈、堆、共享库、代码段等，来增加攻击者对系统的预测难度。栈随机化是 ASLR 的一项措施，它使得栈的位置在每次程序运行时都会发生随机变化，从而减少了栈溢出攻击的成功概率。\n\n   栈随机化通过使攻击者无法准确预测栈的位置来防止栈溢出攻击。即使攻击者成功地溢出了栈缓冲区，他们也无法确定准确的返回地址或其他敏感数据的位置，从而阻止了攻击的成功执行。\n\n2. 栈破坏检测（Stack Protection）：\n   栈破坏检测是一种用于检测栈溢出攻击的技术。其中一种常见的栈破坏检测技术是使用金丝雀值（Canary Value），它也是 ASLR 的一部分。\n\n   在 Linux 系统中，当启用栈保护机制时，编译器会自动将一个特殊的随机值（金丝雀值）插入到栈帧中函数返回地址之前。在函数返回时，系统会检查金丝雀值是否保持不变。如果金丝雀值被篡改，系统会判定栈溢出攻击已发生，并采取相应的安全措施，如终止程序运行或触发警报。\n\n   栈破坏检测技术通过使用金丝雀值可以检测栈溢出攻击。攻击者在进行溢出时，必须同时修改栈缓冲区和相应的金丝雀值。如果金丝雀值被修改，检测机制就会触发并采取相应的措施。\n\n3. ASLR（Address Space Layout Randomization）：\n   ASLR 是一种操作系统级的安全技术，旨在增加攻击者对系统内存布局的预测难度。除了栈随机化之外，ASLR 还包括对代码段、堆、共享库等内存区域的随机化。\n\n   在 Linux 中，启用 ASLR 后，操作系统会在每次程序加载时，随机地将程序的内存布局进行重排。这意味着相同的程序在不同的运行实例中，其内存布局会发生随机变化。\n\n   ASLR 防止了许多常见的攻击技术，如栈溢出、代码注入等。通过随机化内存布局，攻击者无法准确预测关键数据和代码的位置，从而增加了攻击的难度。\n\n### 支持变长栈帧\n\n支持变长栈帧（Variable Length Stack Frames）是一种在函数调用过程中动态调整栈帧大小的技术。这通常用于支持具有可变数量参数或动态分配局部变量的函数。下面是几种常见的支持变长栈帧的方法：\n\n1. 栈指针调整：\n   变长栈帧的一种常见方法是通过在函数开始时动态调整栈指针来为变量分配空间。这通常涉及使用额外的指令来增加或减少栈指针的偏移量，以适应变量的大小。\n\n   例如，对于具有可变数量参数的函数，可以使用类似于C语言中的`va_list`和相关的宏（如`va_start`和`va_end`）来获取参数的地址，并使用栈指针调整来分配和访问参数。\n\n2. 动态分配空间：\n   另一种支持变长栈帧的方法是通过动态分配空间来容纳变量。这可以通过在堆上分配内存并将指针存储在栈帧中来实现。\n\n   例如，如果函数需要动态分配一个可变大小的数组，可以使用堆分配函数（如`malloc`）来分配内存，并将返回的指针存储在栈帧中的变量中。在函数结束时，需要确保释放已分配的内存，以避免内存泄漏。\n\n3. 额外的栈帧元数据：\n   对于支持变长栈帧的函数，通常需要存储关于栈帧结构的额外元数据信息。这些信息可以包括参数的数量、大小以及局部变量的数量和偏移量等。\n\n   这些额外的栈帧元数据通常存储在特定的位置，如栈帧的开头或结尾。通过解析和使用这些元数据，函数可以动态地访问和操作变长栈帧中的变量。\n\n   ","tags":["CSAPP","汇编语言"],"categories":["CSAPP"]},{"title":"2211. 统计道路上的碰撞次数","url":"/posts/b47441a5/","content":"# [leetcode-2211. 统计道路上的碰撞次数](https://leetcode.cn/problems/count-collisions-on-a-road/)\n```C++\nclass Solution {\npublic:\n    int countCollisions(string directions) {\n        int result =  directions.size();\n        for(int i = directions.size() - 1; i >= 0; i--)\n        {\n            if(directions[i] == 'R')\n            result--;\n            else break;\n        }\n        for(int i = 0; i < directions.size(); i++)\n        {\n            if(directions[i] == 'L')\n            result--;\n            else break;\n        }\n        for(char ch : directions)\n        {\n            if(ch == 'S')\n            result--;\n        }\n\n        return result;\n    }\n};\n```\n\n一开始的思路是，搞一个栈，暂时不相撞的车先存在栈里面。遇到相撞的情况，就把要撞的车从里面弹出来。\n\n后来发现，要讨论的相撞的情况太多了。\n\n那么可以逆向思维，不相撞的情况有哪些？仔细思考后发现，其实只有第二个示例中的两种情况：\n\n1. 最左面有向左的车\n2. 最右面有向右的车\n\n确定了相撞的情况，但是这还不是最终想求的答案。\n\n有停止的车参与的相撞，只算一次，所以应该额外计算S的数量。","tags":["脑筋急转弯"],"categories":["算法笔记"]},{"title":"2673. 使二叉树所有路径值相等的最小代价","url":"/posts/66f4d719/","content":"# [leetcode-2673. 使二叉树所有路径值相等的最小代价](https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/)\n```C++\nclass Solution {\npublic:\n    int minIncrements(int n, vector<int> &cost) {\n        int ans = 0;\n        for (int i = n / 2; i; i--) { // 从最后一个非叶节点开始算\n            ans += abs(cost[i * 2 - 1] - cost[i * 2]); // 两个子节点变成一样的\n            cost[i - 1] += max(cost[i * 2 - 1], cost[i * 2]); // 累加路径和\n        }\n        return ans;\n    }\n};\n```\n\n这道题是第一次参加周赛的最后一题，因为时间限制没时间实现。\n\n事后复盘发现了问题，想得还是太复杂，虽然已经明白了路径形成的过程，通过模拟也能得到正确结果。\n\n但是显然只需要计算两个子节点的最大值即可\n\n代码来自灵神。","tags":["树","二叉树","leetcode周赛"],"categories":["算法笔记"]},{"title":"1003. 检查替换后的词是否有效","url":"/posts/3937f726/","content":"# [leetcode-1003. 检查替换后的词是否有效](https://leetcode.cn/problems/check-if-word-is-valid-after-substitutions/)\n\n把前面的a、b都存在一个栈里面，如果找到c,就用c收回前面的ab。\n\n发生两种情况之一即可认为词无效：\n\n- 字符串遍历完，栈中仍然有剩余的字符。\n- C没有收回ab（这一定会导致c留在栈内，因为没有任何字符可以收回c）\n\n出栈的时候要注意，栈是不是空栈。\n\n```C++\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> st;\n        for(char ch : s)\n        {\n            if(ch == 'c')\n            {\n                if(!st.empty() && st.top() == 'b')\n                {\n                    st.pop();\n                    if(!st.empty() && st.top() == 'a')\n                    {\n                        st.pop();\n                        continue;\n                    }\n                    else\n                    return false;\n                }\n            }\n            st.push(ch);\n        }\n        if(st.empty())\n        return true;\n        else\n        return false;\n    }\n};\n```","tags":["栈","字符串"],"categories":["算法笔记"]},{"title":"1376. 通知所有员工所需的时间","url":"/posts/cb655654/","content":"# [leetcode-1376. 通知所有员工所需的时间](https://leetcode.cn/problems/time-needed-to-inform-all-employees/description/)\n\n```C++\nclass Solution {\npublic:\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\n        int maxTime = 0;\n        queue<int> nodes;\n        for(int i = 0; i < informTime.size(); i++)\n        {\n            if(informTime[i] == 0)\n            {\n                nodes.push(i);\n            }\n        }\n        while(!nodes.empty())\n        {\n            int node = nodes.front();\n            nodes.pop();\n            int time = 0;\n            while(manager[node] != -1)\n            {\n                time += informTime[manager[node]];\n                node = manager[node];\n            }\n            maxTime = max(time, maxTime);\n        }\n        return maxTime;\n    }\n};\n```\n\n这个树的组织形式有别于其他的二叉树，子知其父而父不知其子，所以从底部入手更简单。\n\n想了一下，队列好像没特别有必要，当成数组用了。\n\n可以用记忆化搜索继续优化，但是懒得算了。","tags":["树"]},{"title":"2418. 按身高排序","url":"/posts/993fa6d1/","content":"# [leetcode-2418. 按身高排序](https://leetcode.cn/problems/sort-the-people/)\n\n这道题很简单，但是解法有趣：\n\n- 首先把这些内容装进一个map（底层由红黑树构成）中\n- 再按键的顺序遍历map\n- 最后翻转，得到想要的答案。\n\n```C++\nclass Solution {\npublic:\n    vector<string> sortPeople(vector<string>& names, vector<int>& heights) {\n        map<int, string> hash;\n        vector<string> ans;\n        for (int i = 0; i < names.size(); ++i) hash[heights[i]] = names[i];\n        for (auto &i : hash) ans.push_back(i.second);\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};\n```","tags":["树","哈希表","排序","红黑树"],"categories":["算法笔记"]},{"title":"450. 删除二叉搜索树中的节点","url":"/posts/12fe8ccd/","content":"# [leetcode-450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/description/)\n\n有以下五种情况：\n\n- 第一种情况：没找到删除的节点，遍历到空节点直接返回了\n- 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点\n- 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点\n- 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点\n- 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。\n\n\n```C++\nclass Solution {\npublic:\n    TreeNode* deleteNode(TreeNode* root, int key) {\n        if (root == nullptr) return root; // 第一种情况：没找到删除的节点，遍历到空节点直接返回了\n        if (root->val == key) {\n            // 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点\n            if (root->left == nullptr && root->right == nullptr) {\n                ///! 内存释放\n                delete root;\n                return nullptr;\n            }\n            // 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点\n            else if (root->left == nullptr) {\n                auto retNode = root->right;\n                ///! 内存释放\n                delete root;\n                return retNode;\n            }\n            // 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点\n            else if (root->right == nullptr) {\n                auto retNode = root->left;\n                ///! 内存释放\n                delete root;\n                return retNode;\n            }\n            // 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置\n            // 并返回删除节点右孩子为新的根节点。\n            else {\n                TreeNode* cur = root->right; // 找右子树最左面的节点\n                while(cur->left != nullptr) {\n                    cur = cur->left;\n                }\n                cur->left = root->left; // 把要删除的节点（root）左子树放在cur的左孩子的位置\n                TreeNode* tmp = root;   // 把root节点保存一下，下面来删除\n                root = root->right;     // 返回旧root的右孩子作为新root\n                delete tmp;             // 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）\n                return root;\n            }\n        }\n        if (root->val > key) root->left = deleteNode(root->left, key);\n        if (root->val < key) root->right = deleteNode(root->right, key);\n        return root;\n    }\n};\n```","tags":["树","二叉树","递归","二叉搜索树"],"categories":["算法笔记"]},{"title":"113. 路径总和 II","url":"/posts/7f3d8fdb/","content":"# [leetcode-113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)\n\n两个哈希表，一个储存和，一个储存路径。\n\nm储存节点所在的和，p储存经过的路径。\n\n```C++\nclass Solution {\npublic:\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\n        unordered_map<TreeNode*,int> m;\n        unordered_map<TreeNode*,vector<int>> p;\n        vector<vector<int>> result;\n        queue<TreeNode*> que;\n        if(root != nullptr)\n        {\n            que.push(root);\n            m[root] = root->val;\n            p[root].push_back(root->val);\n            if(root->val == targetSum && root->left == nullptr && root->right == nullptr)\n            result.push_back(p[root]);\n        }\n        while(!que.empty())\n        {\n            int size = que.size();\n            for(int i = 0; i < size; i++)\n            {\n                TreeNode* node = que.front();\n                que.pop();\n                if(node->left)\n                {\n                    m[node->left] = m[node] + node->left->val;\n                    que.push(node->left);\n                    p[node->left].insert(p[node->left].end(),p[node].begin(),p[node].end());\n                    p[node->left].push_back(node->left->val);\n                    if(m[node->left] == targetSum && node->left->left == nullptr && node->left->right == nullptr)\n                    result.push_back(p[node->left]);\n                }\n                if(node->right)\n                {\n                    m[node->right] = m[node] + node->right->val;\n                    que.push(node->right);\n                    p[node->right].insert(p[node->right].end(),p[node].begin(),p[node].end());\n                    p[node->right].push_back(node->right->val);\n                    if(m[node->right] == targetSum && node->right->left == nullptr && node->right->right == nullptr)\n                    result.push_back(p[node->right]);\n                }\n            }\n        }\n        return result;\n    }\n};\n\n```","tags":["哈希","树","二叉树","层序遍历","哈希表"],"categories":["算法笔记"]},{"title":"105. 从前序与中序遍历序列构造二叉树","url":"/posts/7ab68b45/","content":"# [leetcode-105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n想起一道经典的408题，层序遍历、前序遍历、中序遍历、后序遍历四种遍历方法两两组合，哪个组合不能确定一个二叉树？\n\n答案显然是前序遍历和后序遍历组合。\n\n这里要实现的就是，从前序与中序遍历序列构造二叉树。\n\n方法很简单：把遍历分成左子树、根和右子树，再分别把左右子树递归。\n\n```C++\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        TreeNode* node = new TreeNode(preorder[0]);\n        if(preorder.size() == 1)\n        return node;\n        int left = find(inorder.begin(),inorder.end(),preorder[0]) - inorder.begin();\n        if(left != 0)\n        {\n            vector<int> pre(preorder.begin() + 1, preorder.begin() + 1 + left);\n            vector<int> ino(inorder.begin(),inorder.begin() + left);\n            node->left = buildTree(pre, ino);\n        }\n        if(left + 1 != preorder.size())\n        {\n            vector<int> pre(preorder.begin() + 1 + left, preorder.end());\n            vector<int> ino(inorder.begin() + left + 1, inorder.end());\n            node->right = buildTree(pre, ino);\n        }\n        return node;\n    }\n};\n```","tags":["树","二叉树","递归","前序遍历","中序遍历"],"categories":["算法笔记"]},{"title":"103. 二叉树的锯齿形层序遍历","url":"/posts/6d6dcbcb/","content":"# [leetcode-103. 二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/)\n\n这里使用的是正常层序遍历再翻转的方法，这样在实现上更简单，官方解也是这么写的。实际上双端队列的方法其实更符合题目的原意。\n\n```C++\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        deque<TreeNode*> st;\n        vector<vector<int>> result;\n        if(root != nullptr)\n        st.push_back(root);\n        int depth = 0;\n        while(!st.empty())\n        {\n            int size = st.size();\n            vector<int> temp;\n            for(int i = 0; i < size; i++)\n            {\n                TreeNode* node = st.back();\n                st.pop_back();\n                temp.push_back(node->val);\n                if(node->left)\n                {\n                    st.push_front(node->left);\n                }\n                if(node->right)\n                {\n                    st.push_front(node->right);\n                }\n\n            }\n            if(depth%2 == 1)\n            reverse(temp.begin(),temp.end());\n            result.push_back(temp);\n            depth++;\n        }\n        return result;\n    }\n};\n```","tags":["树","二叉树","层序遍历","队列"],"categories":["算法笔记"]},{"title":"108. 将有序数组转换为二叉搜索树","url":"/posts/17237f5b/","content":"# [leetcode-108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)\n\n经典的递归中序遍历树，常做常新。\n\n```C++\nclass Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\n        return helper(nums, 0, nums.size() - 1);\n    }\n\n    TreeNode* helper(vector<int>& nums, int left, int right) {\n        if (left > right) {\n            return nullptr;\n        }\n\n        // 总是选择中间位置左边的数字作为根节点\n        int mid = (left + right) / 2;\n\n        TreeNode* root = new TreeNode(nums[mid]);\n        root->left = helper(nums, left, mid - 1);\n        root->right = helper(nums, mid + 1, right);\n        return root;\n    }\n};\n```","tags":["树","二叉树","中序遍历","二叉搜索树"],"categories":["算法笔记"]},{"title":"1823. 找出游戏的获胜者","url":"/posts/3885fad4/","content":"# [leetcode-1823. 找出游戏的获胜者](https://leetcode.cn/problems/find-the-winner-of-the-circular-game/)\n\n首先我们定义 $f(n,m)$ 表示 $n$ 个人中，每数到 $m$ 就淘汰一个人，最后剩下的那个人的编号。\n\n当只有一个人的时候，那么他一定是最后留下的，即 $f(1,m)=0$。\n\n当有两个人的时候，那么第一个人被淘汰之后，剩下的那个人就是最后留下的，即 $f(2,m)=(f(1,m)+m)\\bmod 2$。\n\n当有 $n$ 个人的时候，我们假设最后留下的那个人的初始编号为 $k$，那么第一轮淘汰之后，第 $m$ 个人就会被淘汰，剩下的 $n-1$ 个人构成了一个新的数列，而且初始编号从 $k+1$ 开始，即成为了一个以 $k+1$ 为起点的编号从 $0$ 开始的数列。根据归纳假设，这个数列中最后剩下的那个人的编号是 $f(n-1,m)$。由于第一个淘汰的人的编号是 $(k+m-1)\\bmod n$，所以相对于初始编号 $k+1$，他的编号是 $((k+m-1)\\bmod n)-1$。而因为他被淘汰了，所以剩下的编号从 $(k+m)\\bmod n$ 开始。于是我们可以得到下面的递推式：\n\n$$\nf(n,m)=(f(n−1,m)+m)modn\n$$\n\n最终的答案即为 $f(n,m)$。\n\n```C++\nclass Solution {\npublic:\n    int findTheWinner(int n, int k) {\n        int p = 0;\n        for(int i = 2; i<= n; i++)\n        {\n            p = (p + k) % i;\n        }\n        return p+1;\n    }\n};\n```\n\n","tags":["数学","约瑟夫环"],"categories":["算法笔记"]},{"title":"25. K 个一组翻转链表","url":"/posts/290cb30/","content":"# [leetcode-25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/description/)\n```C++\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        if(k == 1) return head; // 如果k等于1，则直接返回原链表头结点head\n        ListNode* temp = new ListNode(); // 创建一个临时节点temp\n        temp->next = head; // 将temp的下一个节点指向head，即temp为头节点的前一个节点\n        int t = 0; // 计数器，用于记录翻转了几组\n        vector<ListNode*> n(k+1, temp); // 创建一个vector，用于存储当前要翻转的k个节点\n        while(n[0] != nullptr) // 当还有剩余节点时循环\n        {\n            for(int i = 0; i < k; i++) // 将要翻转的k个节点存入vector\n            {\n                if(n[i]->next != nullptr) // 如果当前节点的下一个节点不为空，则将下一个节点存入vector\n                {\n                    n[i+1] = n[i]->next;\n                }\n                else return head; // 如果下一个节点为空，则直接返回原链表头结点head\n            }\n            if(t == 0) // 如果是第一组，则将头结点指向翻转后的第一个节点\n            {\n                head = n[k];\n            }\n            for(int i = 1; i < (k/2) + 1; i++) // 将k个节点进行翻转，分别从两端向中间交换\n            {\n                if(i == 1) // 如果是第一个节点，则需要更改其下一个节点和上一个节点的指针\n                {\n                    n[i-1]->next = n[k-i+1];\n                    n[i]->next = n[k-i+1]->next;\n                }\n                else // 如果不是第一个节点，则需要更改其下一个节点和上一个节点的指针，以及两端节点的指针\n                {\n                    n[k-i+2]->next = n[k-i+1];\n                    n[i]->next = n[i-1];\n                }\n                if(k%2 == 0 && i == k/2) // 如果k是偶数并且当前节点为中间节点，则需要特殊处理其下一个节点的指针\n                {\n                    n[i+1]->next=n[i]; \n                }\n                else // 如果不是中间节点，则需要更改其下一个节点和上一个节点的指针，以及两端节点的指针\n                {\n                    n[k-i+1]->next = n[i+1];\n                    n[k-i]->next = n[i];\n                }\n            }\n\n            n[0] = n[1]; // 将下一组的第一个节点存入vector[0]，循环使用vector\n            t++; // 计数器加1，记录翻转的组数\n        }\n\n        return head; // 返回翻转后的链表头结点head\n    }\n};\n```\n\n看了一眼别人的题解，好像别人的写的也很长。","tags":["链表","困难题"],"categories":["算法笔记"]},{"title":"24. 两两交换链表中的节点","url":"/posts/ea8dbaa4/","content":"# [leetcode-24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        ListNode* temp = new ListNode();\n        temp->next = head;\n        ListNode* m = head;\n        int i = 0;\n        while(m != nullptr && m->next != nullptr)\n        {\n            ListNode* n = m->next;\n            m->next = n->next;\n            n->next = m;\n            temp->next = n;\n            temp = m;\n            m = m->next;\n            if(i == 0)\n            {\n                head = n;\n            }\n            i++; \n        }\n\n        return head;\n    }\n};\n```\n\n额外添加头结点的作用一般有两个：\n\n1. 处理链表开头的元素时更方便，避免分类讨论。\n2. 方便返回结果。\n\n但是这道题有所不同，因为第一个节点和第二个节点已经交换过了，头结点temp处理过后接在第二个节点前面，返回temp->next是错误的。\n\n而且temp没有任何通往第一个节点的路径，唯一的办法是第一次交换时，用head记录交换后的第一个节点。","tags":["双指针","链表"],"categories":["算法笔记"]},{"title":"82. 删除排序链表中的重复元素 II","url":"/posts/c67c6f0d/","content":"# [leetcode-82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)\n```C++\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        if(head == nullptr) return head;\n        ListNode* temp = new ListNode(101);\n        temp->next = head;\n        ListNode* slowIndex = temp;\n        ListNode* fastIndex = head;\n        while(fastIndex != nullptr && fastIndex->next)\n        {\n            int value = fastIndex->val;\n            fastIndex = fastIndex->next;\n            if(value == fastIndex->val)\n            {\n                while(fastIndex != nullptr && fastIndex->val == value)\n                {\n                    slowIndex->next = fastIndex->next;\n                    ListNode* d = fastIndex;\n                    fastIndex = fastIndex->next;\n                    delete d;\n                }\n            }\n            else\n            {\n                slowIndex = slowIndex->next;\n            }\n        }\n\n        return temp->next;\n    }\n};\n```\n\n用一个temp头结点，加到链表的开头，记录需要返回的位置(因为初始节点的开头head可能被删掉，如果不加入temp，必须得分类讨论)。\n\n用两个指针，fastIndex检查节点的值是否重复，slowIndex则停留在检查过的值的末端位置，这个设计充分展现了链表“能去不能回”的特性。\n\n","tags":["双指针","链表"],"categories":["算法笔记"]},{"title":"111. 二叉树的最小深度","url":"/posts/f5d798b7/","content":"# [leetcode-111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)\n\n用层序遍历，找到最浅的叶子节点。\n\n层序遍历的传统写法如下，用队列完成操作：\n\n```C++\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        queue<TreeNode*> que;\n        if(root != NULL)\n        que.push(root);\n        int depth = 0;\n        while(!que.empty())\n        {\n            depth++;\n            int size = que.size();\n            for(int i = 0; i < size; i++)\n            {\n                TreeNode* node = que.front();\n                que.pop();\n                if(node->left)\n                {\n                    que.push(node->left);\n                }\n                if(node->right)\n                {\n                    que.push(node->right);\n                }\n                if(node->right == nullptr && node->left == nullptr)\n                {\n                    return depth;\n                }\n            }\n        }\n        return 0;\n    }\n};\n```","tags":["树","二叉树","层序遍历"],"categories":["算法笔记"]},{"title":"从bilibili获取到的json解析","url":"/posts/715dfc00/","content":"```json\n{\n    \"code\": 0,                                  // 返回码，0 表示请求成功\n    \"message\": \"0\",                             // 返回信息，一般与返回码对应，0 表示成功\n    \"ttl\": 1,                                   // TTL，即过期时间\n    \"data\": {                                   // 返回数据\n        \"bvid\": \"BV12M4y1m7kf\",                 // 视频BV号\n        \"aid\": 909171516,                       // 视频AV号\n        \"videos\": 4,                            // 视频分P数\n        \"tid\": 171,                             // 视频分类ID\n        \"tname\": \"电子竞技\",                    // 视频分类名\n        \"copyright\": 1,\n        \"pic\": \"http://i2.hdslb.com/bfs/archive/104cf33fbf2b35e48a3063939f75d3f99d7ee64a.jpg\",    // 封面图片链接\n        \"title\": \"【2023LPL春季赛】3月26日 WBG vs RA\",    // 视频标题\n        \"pubdate\": 1679834315,                   // 视频发布时间\n        \"ctime\": 1679834315,                     // 视频创建时间\n        \"desc\": \"【2023LPL春季赛】3月26日 WBG vs RA\",    // 视频描述\n        \"desc_v2\": [                             // 视频描述的备选字段\n            {\n                \"raw_text\": \"【2023LPL春季赛】3月26日 WBG vs RA\",\n                \"type\": 1,\n                \"biz_id\": 0\n            }\n        ],\n        \"state\": 0,\n        \"duration\": 9933,                        // 视频时长（单位：秒）\n        \"rights\": {                              // 视频权限\n            \"bp\": 0,\n            \"elec\": 0,\n            \"download\": 1,\n            \"movie\": 0,\n            \"pay\": 0,\n            \"hd5\": 0,\n            \"no_reprint\": 1,\n            \"autoplay\": 1,\n            \"ugc_pay\": 0,\n            \"is_cooperation\": 0,\n            \"ugc_pay_preview\": 0,\n            \"no_background\": 0,\n            \"clean_mode\": 0,\n            \"is_stein_gate\": 0,\n            \"is_360\": 0,\n            \"no_share\": 0,\n            \"arc_pay\": 0,\n            \"free_watch\": 0\n        },\n        \"owner\": {                               // 视频上传者信息\n            \"mid\": 50329118,                      // 上传者的用户ID\n            \"name\": \"哔哩哔哩英雄联盟赛事\",      // 上传者的昵称\n            \"face\": \"https://i2.hdslb.com/bfs/face/544c89e68f2b1f12ffcbb8b3c062a3328e8692d9.jpg\"    // 上传者的头像链接\n        },\n        \"stat\": {                                // 视频的各项统\n            \"aid\": 909171516, // 视频ID\n            \"view\": 863879, // 播放量\n            \"danmaku\": 6896, // 弹幕数\n            \"reply\": 1563, // 评论数\n            \"favorite\": 717, // 收藏数\n            \"coin\": 843, // 硬币数\n            \"share\": 388, // 分享数\n            \"now_rank\": 0, // 当前排名\n            \"his_rank\": 0, // 历史最高排名\n            \"like\": 8575, // 点赞数\n            \"dislike\": 0, // 点踩数\n            \"evaluation\": \"\", // 评级\n             \"argue_msg\": \"\" // 爭議信息\n            },\n        \"dynamic\": \"【2023LPL春季赛】3月26日 WBG vs RA\", // 视频动态标题\n            \"cid\": 1071905598, // 弹幕池ID\n            \"dimension\": { // 视频分辨率信息\n            \"width\": 1920, // 宽度\n            \"height\": 1080, // 高度\n            \"rotate\": 0 // 旋转角度\n            },\n        \"premiere\": null, // 首播时间\n        \"teenage_mode\": 0, // 青少年模式开关\n        \"is_chargeable_season\": false, // 是否是付费季度\n        \"is_story\": false, // 是否是剧情系列\n        \"no_cache\": false // 是否禁用缓存\n        \"pages\": [\n            {\n                \"cid\": 1071905598, // 视频对应的cid\n                \"page\": 1, // 视频分P数，这里表示第1个分P\n                \"from\": \"vupload\", // 视频来源，这里表示自主上传\n                \"part\": \"第一局\", // 视频分P的名称\n                \"duration\": 3605, // 视频时长，单位为秒\n                \"vid\": \"\", // 视频vid，一般是从其他平台转载时才有值\n                \"weblink\": \"\", // 视频网页链接，一般是从其他平台转载时才有值\n                \"dimension\": { // 视频的尺寸信息\n                    \"width\": 1920, // 视频宽度，单位为像素\n                    \"height\": 1080, // 视频高度，单位为像素\n                    \"rotate\": 0 // 视频是否需要旋转，0表示不需要，1表示需要\n                }\n            }\n            {\n                \"cid\": 1071978332,\n                \"page\": 2,\n                \"from\": \"vupload\",\n                \"part\": \"第二局\",\n                \"duration\": 3130,\n                \"vid\": \"\",\n                \"weblink\": \"\",\n                \"dimension\": {\n                    \"width\": 1920,\n                    \"height\": 1080,\n                    \"rotate\": 0\n                }\n            },\n            {\n                \"cid\": 1072032305,\n                \"page\": 3,\n                \"from\": \"vupload\",\n                \"part\": \"第三局\",\n                \"duration\": 2593,\n                \"vid\": \"\",\n                \"weblink\": \"\",\n                \"dimension\": {\n                    \"width\": 1920,\n                    \"height\": 1080,\n                    \"rotate\": 0\n                }\n            },\n            {\n                \"cid\": 1072047043,\n                \"page\": 4,\n                \"from\": \"vupload\",\n                \"part\": \"赛后采访\",\n                \"duration\": 605,\n                \"vid\": \"\",\n                \"weblink\": \"\",\n                \"dimension\": {\n                    \"width\": 1920,\n                    \"height\": 1080,\n                    \"rotate\": 0\n                }\n            }\n        ],\n        \"subtitle\": { // 字幕相关信息\n            \"allow_submit\": false, // 是否允许提交字幕\n            \"list\": [] // 字幕列表\n        },\n        \"is_season_display\": false, // 是否展示季节标志\n        \"user_garb\": { // 头衔信息\n            \"url_image_ani_cut\": \"\" // 动画头衔图片链接\n        },\n        \"honor_reply\": {}, // 回复勋章相关信息\n        \"like_icon\": \"\", // 点赞图标链接\n        \"need_jump_bv\": false // 是否需要跳转到BV号\n    }\n}\n```","tags":["python","github","爬虫","json"],"categories":["github项目"]},{"title":"弹幕词云生成器","url":"/posts/29fc4cd/","content":"# [弹幕词云生成器](https://github.com/vinouno/BilibiliDanmuCrawler)\n\n这是一个python爬虫的初学练手项目，作用是从 bilibili.com 爬取弹幕并生成词云。\n\n## 爬取弹幕\n\n```python\ndef get_cid(bvid):\n    \"\"\"获取视频cid\"\"\"\n    url = 'https://api.bilibili.com/x/web-interface/view?bvid={}'.format(bvid)\n    headers = {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299',\n        'Referer': 'https://www.bilibili.com/video/{}'.format(bvid)\n    }\n    response = requests.get(url, headers=headers)\n    data = response.json()\n    cid = data['data']['cid']\n\n    return cid\n\n    \"\"\"\n    # 将Python对象转化为JSON格式的字符串，并输出\n    print(json.dumps(data, indent=4, ensure_ascii=False))\n    print(cid)\n    \"\"\"\n```\n\n传入视频的BV号，在`headers`里面定义了一个请求头，用于描述发起请求的客户端信息。在这段代码中，我们手动设置了一个浏览器用户代理，用于模拟浏览器的行为。\n\n然后把获取到的响应转换成json格式，从响应里提取出视频的`cid`值。\n\n这篇文章，详细解析了获取到的json：[从bilibili获取到的json解析](https://vinouno.github.io/posts/715dfc00/)。可以看到一个视频里，不同分p有不同的`cid`。\n\n问我为什么不写不同分p的情况？因为我懒，有需要再写(2023.4.14日备注，此问题已修复)。\n\n```python\ndef get_danmu(cid):\n    \"\"\"获取弹幕\"\"\"\n    url = 'https://comment.bilibili.com/{}.xml'.format(cid)\n    response = requests.get(url)\n    xml_content = response.content.decode('utf-8')\n    root = ET.fromstring(xml_content)\n    danmu_list = []\n    for d in root.iter('d'):\n        danmu = d.text\n        p_attrs = d.attrib['p']\n        p_attrs_list = p_attrs.split(',')\n        danmu_dict = {\n            'text': danmu,\n            'time': float(p_attrs_list[0]),\n            'mode': int(p_attrs_list[1]),\n            'fontsize': int(p_attrs_list[2]),\n            'color': int(p_attrs_list[3]),\n            'timestamp': int(p_attrs_list[4]),\n            'pool': int(p_attrs_list[5]),\n            'userid': p_attrs_list[6],\n            'rowid': int(p_attrs_list[7]),\n            'duration': int(p_attrs_list[8]),\n        }\n        danmu_list.append(danmu_dict)\n    return danmu_list\n```\n\n传入`cid`，b站的弹幕都存在`https://comment.bilibili.com/{cid}.xml`里，这个地址可以用浏览器直接访问。用爬虫访问这个URL，获取弹幕列表。\n\n## 生成词云\n\n```python\ndef word_cloud_generator(json_name):\n    # 读取json文件\n    with open(json_name, 'r', encoding='utf-8') as f:\n        data = json.load(f)\n\n    # 获取所有弹幕内容\n    text = ''\n    for item in data:\n        text += item['text']\n\n    # 加载停用词表\n    stopwords = set()\n    with open('cn_stopwords.txt', 'r', encoding='utf-8') as f:\n        for line in f:\n            stopwords.add(line.strip())\n\n    # 使用jieba进行分词，去掉停用词\n    words = [word for word in jieba.cut(text) if word not in stopwords]\n\n    # 将分词结果转换为字符串\n    words_str = ' '.join(words)\n\n    # 生成词云\n    wc = WordCloud(background_color='white', width=1000, height=800, font_path='msyh.ttc')\n    wc.generate(words_str)\n\n    \"\"\"\n    # 显示词云\n    plt.imshow(wc)\n    plt.axis('off')\n    plt.show()\n    \"\"\"\n\n    # 保存词云\n    filename = os.path.splitext(json_name)[0] + '.png'\n    wc.to_file(filename)\n```\n\n把获取的弹幕进行分词，这里使用了`jieba`中文分词，把句子分成词语。然后加载停用词表，去掉诸如这个、那个、是、吧等类似无意义的词语。设置词云图片的背景颜色，图片大小，生成词云图片。\n\n![](https://raw.githubusercontent.com/vinouno/blog_image/main/danmu_BV12M4y1m7kf-%E9%A2%84%E8%A7%88.png ) ","tags":["python","github","爬虫","词云","中文分词"],"categories":["github项目"]},{"title":"75. 颜色分类","url":"/posts/75dc9575/","content":"# [leetcode-75. 颜色分类](https://leetcode.cn/problems/sort-colors/description/)\n```C++\nclass Solution {\npublic:\n    void sortColors(vector<int>& nums) {\n        int m = 0; // 用于记录0出现的位置\n        int n = nums.size() - 1; // 用于记录2出现的位置\n        for (int i = 0; i <= n; i++) { // 遍历整个数组\n            while (i <= n && nums[i] == 2) { // 如果当前数字为2\n                swap(nums[i], nums[n]); // 将当前数字和最后一个数字进行交换\n                --n; // 更新最后一个数字的位置\n            }\n            if (nums[i] == 0) { // 如果当前数字为0\n                swap(nums[i], nums[m]); // 将当前数字和第一个数字进行交换\n                ++m; // 更新第一个数字的位置\n            }\n        }\n    }\n};\n\n```","tags":["双指针","数组"],"categories":["算法笔记"]},{"title":"136. 只出现一次的数字","url":"/posts/93cfc1bf/","content":"# [leetcode-136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)\n```C++\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int result = 0;\n        for(int num : nums)\n        {\n            result = result ^ num;\n        }\n        return result;\n    }\n};\n```\n\n对于任意数n：\n\n- n ^ n = 0\n- n ^ 0 = n\n- 异或满足交换律：a ^ b ^ c = a ^ c ^ b\n\n满足线性时间复杂度的要求。","tags":["位运算"],"categories":["算法笔记"]},{"title":"1053. 交换一次的先前排列","url":"/posts/cbdd2f8b/","content":"# [leetcode-1053. 交换一次的先前排列](https://leetcode.cn/problems/previous-permutation-with-one-swap/description/)\n```C++\nclass Solution {\npublic:\n    vector<int> prevPermOpt1(vector<int>& arr) {\n        int n = arr.size() - 1;\n        while(arr[n] >= arr[n-1])\n        {\n            n--;\n            if(n == 0)\n            return arr;\n        }\n        int temp = n - 1;\n        n = arr.size() - 1;\n        while(arr[temp] <= arr[n])\n        {\n            n--;\n        }\n        while(arr[n - 1] == arr[n])\n        {\n            n--;\n        }\n        swap(arr[n], arr[temp]);\n        return arr;\n    }\n};\n```","tags":["贪心"],"categories":["算法笔记"]},{"title":"1039. 多边形三角剖分的最低得分","url":"/posts/a2ea14bf/","content":"# [leetcode-1039. 多边形三角剖分的最低得分](https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/description/)\n```C++\nclass Solution {\npublic:\n    int minScoreTriangulation(vector<int>& values) {\n        unordered_map<int, int> memo; // memo是用来记录子问题的解，避免重复计算\n        int n = values.size();\n        function<int(int, int)> dp = [&](int i, int j) -> int { // dp函数是用来计算子问题的解\n            if (i + 2 > j) { // 当前的多边形边数小于3，不需要进行三角剖分，得分为0\n                return 0;\n            }\n            if (i + 2 == j) { // 当前的多边形边数等于3，只有一种剖分方式，直接计算得分\n                return values[i] * values[i + 1] * values[j];\n            }\n            int key = i * n + j; // 将子问题的i和j作为key，保存子问题的解\n            if (!memo.count(key)) { // 如果当前子问题没有被计算过，进行计算\n                int minScore = INT_MAX; // 初始化当前子问题的最小得分\n                for (int k = i + 1; k < j; k++) { // 枚举剖分点k，计算最小得分\n                    minScore = min(minScore, values[i] * values[k] * values[j] + dp(i, k) + dp(k, j));\n                }\n                memo[key] = minScore; // 将子问题的解保存到memo中\n            }\n            return memo[key]; // 返回子问题的解\n        };\n        return dp(0, n - 1); // 计算整个多边形的最小得分\n    }\n};\n```\n## 解题思路\n\n这道题可以使用动态规划（DP）来求解。具体来说，可以定义一个 DP 函数 dp(i, j)，表示对于多边形的第 i 个顶点到第 j 个顶点之间的区间，选择不相交的对角线将其分成若干个三角形的最小得分之和。那么最终的答案即为 dp(0, n-1)，其中 n 是顶点的个数。\n\n对于 dp(i, j)，可以枚举 i 和 j 之间的所有顶点 k，并尝试将顶点 i 和顶点 j 之间的一条对角线连接起来，将多边形分成两个部分。然后分别递归求解左右两个部分的最小得分之和，并将其加上当前三角形的得分，得到当前方案的总得分。最后取所有方案的总得分中的最小值即可。\n\n为了避免重复计算，可以使用备忘录（memoization）技术对已经计算过的结果进行缓存。首先创建了一个 unordered_map<int, int> 类型的 memo 变量，用于记录已经计算过的子问题的答案，以避免重复计算。\n\n然后定义了一个名为 dp 的 lambda 函数，它的输入参数为两个整数 i 和 j，输出一个整数，代表计算多边形顶点 i 到顶点 j 之间构成的三角形的最小分数。这个 lambda 函数内部采用记忆化搜索的方式来避免重复计算。首先检查是否已经计算过当前子问题的答案，如果没有则通过遍历顶点 i 到顶点 j 之间的所有可能的三角形，分别计算分数，然后取最小值并将结果存入 memo 中。\n\n最后调用 dp 函数计算多边形从顶点 0 到顶点 n-1 之间构成的三角形的最小分数，并将结果作为函数的返回值。\n\n综上，这段代码实现了一种动态规划算法，用于计算多边形中所有可能的三角形分割方案中的最小分数。其中使用了记忆化搜索来避免重复计算，lambda 函数 dp 中定义了具体的计算逻辑。\n\n## lamda表达式和function\n\n这段代码是最复杂的：\n\n```C++\n function<int(int, int)> dp = [&](int i, int j) -> int {}\n```\n\n这行代码定义了一个函数对象 dp，这个函数对象是一个 std::function 类型的变量，它指向一个以 int 和 int 为输入参数，以 int 为返回值的函数。\n\n具体来说，function<int(int, int)> 表示 dp 是一个函数对象，它接受两个 int 类型的参数，返回一个 int 类型的值。这个函数对象在后面的实现中被赋值为一个 lambda 表达式，这个 lambda 表达式定义了动态规划的状态转移方程。\n\n& 符号表示通过引用捕获外部变量，[&] 表示以引用的方式捕获所有外部变量，即函数对象内部可以访问外部的变量和函数。在本例中，lambda 表达式需要访问 values 和 memo 这两个变量。\n\n-> int 表示函数对象返回值的类型是 int，dp(i, j) 表示函数对象的调用方式，即传入两个参数 i 和 j 并返回一个 int 类型的值。\n\n总之，这行代码定义了一个函数对象 dp，它表示动态规划中的状态转移方程。在实际运行中，通过调用 dp(i, j) 可以计算出以 i 和 j 为顶点的三角形的最小得分，并且使用 memo 对已经计算过的值进行了缓存，以避免重复计算。","tags":["动态规划","记忆化搜索","C++"],"categories":["算法笔记"]},{"title":"831. 隐藏个人信息","url":"/posts/c805edf0/","content":"# [leetcode-831. 隐藏个人信息](https://leetcode.cn/problems/masking-personal-information/description/)\n```C++\nclass Solution {\npublic:\n    string maskPII(string s) {\n        string result;\n        int at = s.find('@');\n        if(at != string::npos)\n        {\n            transform(s.begin(), s.end(), s.begin(), ::tolower);\n            result = s.substr(0,1) + \"*****\"+s.substr(at - 1);\n        }\n        else\n        {\n            vector<string> country = {\"\", \"+*-\", \"+**-\", \"+***-\"};\n            s = regex_replace(s, regex(\"[^0-9]\"), \"\");\n            result = country[s.size() - 10] + \"***-***-\" + s.substr(s.size() - 4);\n        }\n        \n        return result;\n    }\n};\n```\n\n简简单单的代码，包含了不少知识：\n\n## string::npos的类型\n\n网上一些博客有这样一种说法，string::npos不应该被定义为int，这样会导致错误，经过查阅，这种说法既对又不对。\n\n在一些老版本的C++标准中，string::npos可能被定义为一个int类型的常量，这可能会导致一些类型转换问题。但在C++11及以上的标准中，string::npos被定义为size_t类型的常量，因此不会出现类型问题。\n\n## 用双引号和单引号表示的字符串有什么区别？\n\n在C++中，使用双引号 \" 表示的字符串是字符串字面量，会被解释为一个 const char* 类型的指针。例如，const char* s = \"hello\"; 将会创建一个指向字符串 \"hello\" 的指针。\n\n而使用单引号 ' 表示的是字符字面量，会被解释为一个 char 类型的值。例如，char c = 'a'; 将会创建一个值为 'a' 的 char 变量。\n\n另外，双引号表示的字符串可以包含任意数量的字符，而单引号只能包含一个字符。因此，如果要表示一个字符串，应该使用双引号，而如果要表示一个单独的字符，应该使用单引号。\n\n## substr 函数在一个参数的时候代表什么？\n\n当 substr 函数只有一个参数时，它表示从该参数所指定的位置开始，一直截取到字符串的末尾。例如，std::string s = \"hello world\"; s = s.substr(6); 将把 s 的值改为 \"world\"。\n\n## 如何将大写字母转换为小写字母？\n\n可以使用C++中的 std::tolower() 函数将大写字母转换为小写字母。例如，char c = 'A'; c = std::tolower(c); 将把 c 的值改为小写字母 a。\n\n## transform的用法\n\nstd::transform是C++标准库中的一个算法，它用于对一个序列中的每个元素进行转换，并将结果存储到另一个序列中。transform的一般用法如下：\n\n```C++\nstd::transform(InputIt first1, InputIt last1, OutputIt d_first, UnaryOperation unary_op);\n```\n\n其中，first1和last1表示输入序列的范围，d_first表示输出序列的起始位置，unary_op表示对每个输入元素要执行的操作。具体来说，transform将从first1到last1中的每个元素应用unary_op操作，并将结果存储到从d_first开始的输出序列中。\n\n下面是一些transform的常见用法：\n\n1. 对容器中的元素应用函数\n\n```C++\n#include <algorithm>\n#include <vector>\n#include <iostream>\n\nint add_one(int x) {\n    return x + 1;\n}\n\nint main() {\n    std::vector<int> nums{1, 2, 3, 4, 5};\n    std::vector<int> result(nums.size());\n    std::transform(nums.begin(), nums.end(), result.begin(), add_one);\n    for (auto i : result) {\n        std::cout << i << \" \"; // 输出：2 3 4 5 6\n    }\n    return 0;\n}\n```\n上述代码中，transform函数对nums中的每个元素应用add_one函数，并将结果存储到result容器中。\n\n2. 对字符串中的字符应用函数\n   \n```C++\n#include <algorithm>\n#include <string>\n#include <cctype>\n#include <iostream>\n\nint main() {\n    std::string s = \"Hello World\";\n    std::transform(s.begin(), s.end(), s.begin(), ::tolower);\n    std::cout << s << std::endl; // 输出：hello world\n    return 0;\n}\n\n```\n3. 对两个容器的元素应用函数\n\n```C++\n#include <algorithm>\n#include <vector>\n#include <iostream>\n\nint add(int x, int y) {\n    return x + y;\n}\n\nint main() {\n    std::vector<int> nums1{1, 2, 3, 4, 5};\n    std::vector<int> nums2{6, 7, 8, 9, 10};\n    std::vector<int> result(nums1.size());\n    std::transform(nums1.begin(), nums1.end(), nums2.begin(), result.begin(), add);\n    for (auto i : result) {\n        std::cout << i << \" \"; // 输出：7 9 11 13 15\n    }\n    return 0;\n}\n\n```\n\n## 什么是 regex_replace 函数？\nregex_replace 函数是 C++ 标准库中正则表达式库的一部分，提供了对字符串进行正则表达式匹配和替换的功能。使用该函数可以将字符串中匹配到的部分替换为指定的内容。","tags":["字符串","STL"],"categories":["算法笔记"]},{"title":"CSAPP 第二章：信息的表示和处理","url":"/posts/6870ef63/","content":"# CSAPP 第二章：信息的表示和处理\n\n## 2.1 信息存储\n\n### 位和字节\n\n- 计算机中最小的存储单位是位（bit），每个位可以存储0或1。\n- 8个位构成一个字节（byte），通常用于表示一个字符或一个整数的值。\n- 计算机中的数据是按字节为单位存储的，每个字节都有一个唯一的地址。\n\n### 十六进制表示法\n\n- 十六进制表示法用于方便地表示二进制数。\n- 每个十六进制数字对应于4个二进制位，因此一个字节可以表示为两个十六进制数字。\n- 十六进制数字包括0到9和A到F。\n\n### 字数据大小\n\n- 计算机中常用的字大小有1字节（8位）、2字节（16位）、4字节（32位）和8字节（64位）。\n- 不同的字大小可以表示的最大值不同，例如1字节可以表示的最大值为255（$2^8-1$），而4字节可以表示的最大值为4294967295（$2^{32}-1$）。\n\n### 数据类型\n\n- 不同类型的数据在计算机中存储的方式不同。\n- 布尔类型通常存储为1字节，0表示假，非0表示真。\n- 整数类型可以使用有符号或无符号表示，有符号类型使用补码表示，无符号类型使用无符号整数表示。\n- 浮点数类型通常使用IEEE标准表示，包括符号位、指数位和尾数位。\n\n### C语言数据类型\n\n- C语言支持各种数据类型，包括整数类型、浮点数类型、字符类型等。\n不同的数据类型在内存中占用的字节数不同，可以使用sizeof运算符获取。\n-  在C语言中，常量可以直接使用字面值表示，例如整数常量、浮点数常量、字符常量等。\n-  为什么防止不同编译器的不同设置引起的奇怪问题，引入了数据大小固定的数据类型，例如int32_t和int64_t。\n\n### 大端和小端\n\n在计算机中，数据在内存中存储时需要占用多个字节。大端和小端是两种不同的字节序，用于确定多字节数据中字节的存储顺序。\n\n- 大端字节序：在大端字节序中，最高位字节（即最高有效字节）存储在最低地址处，最低位字节（即最低有效字节）存储在最高地址处。例如，十六进制数0x12345678在大端字节序中存储为12 34 56 78，最高位字节0x12存储在最低地址处，最低位字节0x78存储在最高地址处。\n\n- 小端字节序：在小端字节序中，最低位字节（即最低有效字节）存储在最低地址处，最高位字节（即最高有效字节）存储在最高地址处。例如，十六进制数0x12345678在小端字节序中存储为78 56 34 12，最低位字节0x78存储在最低地址处，最高位字节0x12存储在最高地址处。\n\n两种字节序的区别在于多字节数据的字节存储顺序，而单字节数据的字节存储顺序是相同的。在网络通信和数据传输中，通常使用大端字节序。一些计算机处理器（如PowerPC）采用大端字节序，而另一些计算机处理器（如x86）采用小端字节序。在程序开发中，需要考虑字节序的问题，以免造成数据解析错误或不兼容的问题。\n\n### 布尔代数\n\n布尔代数是一种数学分支，也是一种逻辑代数。它以二元关系和二元运算为基础，用于描述逻辑命题和逻辑运算，其中的基本元素只有两个值，通常用0和1表示。在布尔代数中，0表示假，1表示真。\n\n布尔代数的运算包括与（AND）、或（OR）、非（NOT）和异或（XOR）等。以AND运算为例，当两个元素的值均为1时，AND运算的结果为1，否则为0。OR运算的结果是两个元素的值中至少有一个为1时为1，否则为0。NOT运算的结果是一个元素的值取反，即1变成0，0变成1。XOR运算的结果是两个元素的值不相同时为1，相同时为0。\n\n利用异或的性质解题：[leetcode-136. 只出现一次的数字](https://vinouno.github.io/posts/93cfc1bf/)\n\n布尔代数广泛应用于计算机科学领域中的逻辑设计、编译器设计、数据结构、算法设计等方面。例如，在逻辑电路的设计中，可以使用布尔代数的公式来简化电路的设计，从而减少电路的复杂性和成本。在编译器的设计中，布尔代数也被用来描述和优化中间代码和目标代码的生成和优化过程。在数据结构和算法设计中，布尔代数常常被用来描述逻辑运算和条件判断等。\n\n### C语言中的逻辑运算\n\n逻辑与（&&）运算符表示两个表达式都为真时结果为真，只要有一个表达式为假则结果为假。例如，a && b表示当a和b都为真时结果为真，否则结果为假。\n\n逻辑或（||）运算符表示两个表达式有一个为真时结果为真，只有两个表达式都为假时结果为假。例如，a || b表示当a或b中有一个为真时结果为真，否则结果为假。\n\n逻辑非（!）运算符表示对一个表达式取反。例如，!a表示当a为假时结果为真，当a为真时结果为假。\n\n### C语言中的移位\n\nC语言中的移位运算是位运算的一种，包括左移运算符（<<）、逻辑右移运算符（>>>）、算术右移运算符（>>）。\n\n左移运算符（<<）将一个数的二进制表示向左移动指定的位数，右侧空出的位补0。例如，a << 2表示将a的二进制表示向左移动2位，即将a的值乘以4。\n\n逻辑右移运算符（>>>）将一个数的二进制表示向右移动指定的位数，左侧空出的位补0。例如，a >>> 1表示将a的二进制表示向右移动1位，左侧空出的位补0。\n\n算术右移运算符（>>）将一个数的二进制表示向右移动指定的位数，左侧空出的位补符号位，即正数补0，负数补1。例如，a >> 1表示将a的二进制表示向右移动1位，即将a的值除以2。\n\n在C语言标准中，并没有明确定义算术右移和逻辑右移的方法，具体的实现方式取决于编译器和处理器的实现。在实际中，大部分的处理器都采用了算术右移的方式来进行有符号数的右移操作，即将左侧空出的位补上符号位；而无符号数的右移操作一般采用逻辑右移的方式，即左侧空出的位补0。\n\n由于C语言标准并没有规定右移的行为，因此在进行有符号数的右移操作时，存在一些跨平台的兼容性问题，不同的编译器和处理器可能会有不同的实现方式。因此，为了避免这些问题，建议在进行右移操作时，尽量使用无符号数进行位运算，或者使用移位后进行符号扩展的方法。\n\n移位运算在C语言中常用于优化计算，比如将乘法运算转化为移位运算。需要注意的是，移位运算符的使用需要遵循一定的规则，如不可将一个数向右移动超过它的位数，否则结果将不可预知。在使用算术右移时，需要注意负数的符号扩展问题，可以通过逻辑右移再进行符号位的处理。\n\n## 2.2 整数表示\n\n### 补码\n\n补码是一种用来表示有符号整数的编码方式。对于一个n位二进制数，它的补码表示方法如下：\n\n- 对于正数，它的补码就是它的原码（即二进制数的绝对值）\n- 对于负数，它的补码是将它的原码除符号位以外的所有位按位取反，然后再加1所得到的结果\n\n对于一个n位的补码数X，其数值表示为：\n\n$$\nX = -w_{n-1} × 2^{n-1} + ∑_{i=0}^{n-2}w_i × 2^i\n$$\n \n其中，$w_{n-1}$表示符号位，若为0则表示正数，若为1则表示负数。\n\n以一个8位的有符号整数-7为例，其原码为：\n\n$$\n-7_{10} = 10000111_{2}\n$$\n\n将其转换为补码：\n\n1. 对于符号位，符号位为1，表示负数。\n2. 对于除符号位以外的所有位，将其取反得到01111000。\n3. 将取反后的结果加1，得到01111001。\n\n因此，-7的补码表示为01111001。\n\n### 有符号数和无符号数的运算与转化\n\n有符号数和无符号数的运算和转化涉及到它们在内存中存储的方式不同，可能会导致意想不到的结果。\n\n首先，无符号数的取值范围是 $0$ 到 $2^n-1$，其中 $n$ 是该类型的位数。因此，当无符号数的值为 $0$ 时，其所有位都为 $0$。\n\n而对于有符号数，它的第一位通常表示它的符号。使用补码表示时，有符号数的取值范围是 $-2^{n-1}$ 到 $2^{n-1}-1$。对于一个 $n$ 位的有符号数，最高位的权重是 $-2^{n-1}$，其余位的权重分别为 $2^{n-2}$、$2^{n-3}$、$\\cdots$、$2^0$。\n\n当有符号数和无符号数发生运算时，C语言会将无符号数当作有符号数进行运算。如果无符号数的值小于 $0$，那么它会被解释为有符号数的一个较大的正数值，这可能导致意想不到的结果。\n\n当将有符号数转换为无符号数时，如果该数的值为负，则将其值加上 $2^n$（其中 $n$ 是该类型的位数），直到它成为一个非负数。这种转换也可能导致意想不到的结果，例如：\n\n```C\nunsigned int x = 10;\nint y = -20;\nprintf(\"%u\\n\", x + y);\n```\n上面的代码中，y 被转换为一个无符号数，其值为 $2^{32}-20$。因此，x + y 的值为 $2^{32}-10$，它通常不是我们想要的结果。\n\n### 拓展与截断\n\n拓展和截断是指对于一个数据类型，将其从一种宽度（width）转换为另一种宽度的过程。\n\n拓展指将一个较窄的数据类型转换为一个较宽的数据类型时所进行的操作。例如，将一个8位的无符号数拓展为一个16位的无符号数，就需要将其高位补0。拓展操作可以通过左移、右移和或操作等方式来实现。\n\n例如，将一个8位的无符号数x拓展为一个16位的无符号数y，可以使用下面的代码：\n\n```C\nunsigned char x = 0x23; // 0000 0010\nunsigned short y = (unsigned short) x; // 0000 0000 0010 0011\n```\n\n在上面的代码中，我们将x拓展为一个16位的无符号数y，使用了显式类型转换的方式。\n\n截断指将一个较宽的数据类型转换为一个较窄的数据类型时所进行的操作。例如，将一个32位的整数截断为一个16位的整数，就需要将其高位截断。截断操作会导致数据的精度降低，可能会导致精度损失和数据溢出等问题。\n\n例如，将一个32位的有符号整数x截断为一个16位的有符号整数y，可以使用下面的代码：\n\n```C\nint x = 0x0000ffff; // 0000 0000 0000 0000 1111 1111 1111 1111\nshort y = (short) x; // 1111 1111 1111 1111\n```\n\n在上面的代码中，我们将x截断为一个16位的有符号整数y，使用了显式类型转换的方式。由于x的高位都是0，因此截断的结果和原始值相同。\n\n需要注意的是，对于有符号整数的拓展和截断操作，其具体的结果取决于CPU的架构和编译器的实现。例如，对于有符号整数的截断操作，一些编译器会采用“截断高位，保留低位”的方式，而另一些编译器则会采用“截断低位，保留符号位”的方式。因此，在进行数据类型转换时，应该根据具体的编译器和CPU架构来决定具体的实现方式。\n\n## 2.3 整数运算\n\n### 无符号数加法\n\n在无符号数加法中，操作数被当做没有符号的正数进行处理。无符号数加法遵循模算术（模为 2 的 n 次方，n 是数的位数），当结果超出模范围时，结果会对模取模，保留余数。例如，8 位无符号数的模为 256，当两个 8 位无符号数相加时，如果结果大于 255，则结果会对 256 取模，例如：\n\n```C\n200 + 100 = 44 (mod 256)\n```\n\n### 补码加法\n\n补码加法则是一种计算机中常用的有符号数加法方式。在补码表示中，正数的补码和无符号数的表示相同，而负数的补码是将其对应正数的二进制表示取反后加 1 所得到的二进制数。补码加法与无符号数加法的区别在于，补码加法中，数的范围是从 $-2^{n-1}$ 到 $2^{n-1}-1$，其中 n 是数的位数。在补码加法中，如果两个数的和超出了这个范围，则会发生溢出。\n\n在补码加法中，当两个数相加时，如果最高位进位了，就会导致溢出，此时计算机会将结果的最高位截断并将其存储在进位标志寄存器中，以便程序员检测是否发生了溢出。\n\n### 有符号数的溢出\n\n对于有符号数，溢出有以下两种情况：\n\n正数加正数得到负数，或者负数加负数得到正数。这种情况被称为“符号位溢出”，因为结果的符号与输入操作数的符号不同。这种溢出通常是由于操作数的符号位的进位或借位错误造成的。\n\n两个正数相加得到一个大于等于最大正数，或者两个负数相加得到一个小于等于最小负数。这种情况被称为“数值位溢出”，因为结果的绝对值超出了有符号数的表示范围。这种溢出通常是由于两个操作数的绝对值相加超出了数据类型的范围造成的。\n\n处理这些溢出的方法如下：\n\n**符号位溢出**：可以通过在操作数的高位添加一位来检测符号位溢出。当符号位和进位不同时，就发生了符号位溢出。处理符号位溢出的方法包括检查符号位和进位是否相同，并相应地修改结果的符号位。\n\n**数值位溢出**：可以通过比较加法的操作数和结果的符号位来检测数值位溢出。如果操作数的符号位相同，但结果的符号位与它们不同，则发生了数值位溢出。处理数值位溢出的方法包括将操作数和结果向上或向下舍入，或者将结果截断为最大或最小值。\n\n在实际应用中，为了避免这些溢出，通常需要进行数据类型检查和数据范围限制，以确保操作数不会超出数据类型的表示范围。此外，在编写代码时，应该尽可能地避免使用可能导致溢出的算术运算。\n\n### 无符号乘法\n\n无符号乘法是指对两个无符号整数进行乘法运算，得到的结果也是一个无符号整数。在无符号乘法中，计算机将两个数按位相乘，然后再将结果相加得到最终的乘积。由于无符号整数没有正负之分，因此无符号乘法不需要考虑进位或溢出的问题。\n\n可以简单地表示无符号乘法的公式如下：\n\n$$\nC = A * B mod 2^ω\n$$\n\n### 补码乘法\n\n1. 对无符号和补码乘法，乘法运算的位级表示都是一样的。\n\n2. 机器使用一种乘法指令来进行有符号和无符号整数的乘法，也就是都采用无符号乘法处理，再取低位。\n\n3. 无符号和补码的乘法低位是相同的。证明如下：\n\n![](https://raw.githubusercontent.com/vinouno/blog_image/main/%E8%A1%A5%E7%A0%81%E4%B9%98%E6%B3%95%E8%AF%81%E6%98%8E.jpg)\n\n补码乘法的过程主要包括三个步骤：补码表示、乘法运算和结果转换。\n\n下面是补码乘法的详细步骤：\n\n1. 将两个乘数转换为它们的补码形式。如果乘数是正数，则它们的补码与原码相同；如果乘数是负数，则需要将它们的绝对值转换为二进制补码形式，并将符号位取反，然后再将符号位和数值位组合起来得到补码。\n\n2. 将两个补码乘起来，得到一个结果的补码。在这个过程中，可以使用常规的乘法算法，将乘数逐位与被乘数相乘，并将结果相加。需要注意的是，结果的位数可能会超过原始数的位数，需要进行适当的位扩展。\n\n3. 将结果的补码转换为原码。如果结果是正数，则它们的补码与原码相同；如果结果是负数，则需要将它们的绝对值转换为二进制补码形式，并将符号位取反，然后再将符号位和数值位组合起来得到原码。\n\n举例说明补码乘法：\n\n```\n          1111 1111        -1\n       x  1111 1001     x  -7\n      ----------------    ------\n          11111111          7\n         00000000\n        00000000\n       11111111\n      11111111\n     11111111\n    11111111\n   11111111\n   ----------------\n1  00000000111       --->  7 (notice the Most significant bit is zero)\n(last 8-bits needed) \n```\n### 乘以常数\n\n把一个数乘以$2^n$,相当于左移n位。\n\n整数乘法运算在大多数机器上都相当慢（10个或者更多的时钟周期），而其他整数运算（加法、减法、位运算和移位）只需要一个时钟周期。\n\n因此许多C语言编译器识图用移位、加法和减法的组合来代替乘法。\n\n例如表达式$x*14=x<<3+x<<2+x<<1$，当然更好的办法是$x*14=x<<4-x<<1$。\n\n### 除以2的幂\n\n同样地，我们可以用分别用逻辑右移和算术右移代替无符号数和补码的除以2的幂的除法。\n\n逻辑右移的情况下，不需要任何额外的操作。\n\n但是在算术右移的时候，会出现向下取整的情况。当结果是负数的时候，就会出现不合适的舍入。这时候，我们就应该先加上一个偏置值($2^k - 1$)，再进行移位。\n\n测试题：在不使用任何乘除法、模运算、条件语句、比较运算符、循环的情况下，写一个函数，返回整数参数$x/16$的值。\n\n```C\nint div16(int x){\n   int bias = (x >> 31) &0XF;\n   return (x + bias) >> 4;\n}\n```\n## 2.4 浮点数\n\n现实的应用中，需要表示一些非常大的数字或者非常接近0的数字，以及更普遍地作为实数运算的近似值的计算，这是就需要浮点数的表示。\n\n其中IEEE754标准定义的浮点数规则，广泛地被应用。\n\n### 二进制小数\n\n在二进制中，不同位置的数字带有$2^n$的权，基于同样的原则，我们也能推广到负位置上，不同位置上的数字，也可以代表$\\frac{1}{2}、\\frac{1}{4}$等等。\n\n这样的表示方法，就带来一个问题：用有限位数的二进制数表示十进制小数，只能近似地表示（当然，增加二进制数的表示长度，可以提升近似地精度）。\n\n### IEEE浮点表示\n\nIEEE 754是一种常用的标准。它定义了浮点数的表示方法和运算规则。\n\n#### 浮点数的组成部分\n\nIEEE 754浮点数由三个主要部分组成：符号位（Sign）、指数位（Exponent）和尾数位（Significand/Mantissa）。每个部分在浮点数的二进制表示中具有特定的意义。\n\n- 符号位（Sign）：用于表示浮点数的正负号。0表示正数，1表示负数。\n\n- 指数位（Exponent）：表示浮点数的指数部分，用于确定浮点数的数量级。指数位的值采用偏移表示法（移码），其中偏移值为2^(n-1) - 1，其中n是指数位的位数。\n\n- 尾数位（Significand/Mantissa）：表示浮点数的小数部分。尾数位决定了浮点数的精度。\n\n在单精度浮点数中，三个部分分别占1、8、23位，而在双精度浮点数中，三个部分分别占1、11、52位。\n\n\n#### 规格化与非规格化\n\n- 规格化值（Normalized Value）：如果浮点数中指数部分的编码值既不是全0，又不是全1，且在科学表示法的表示方式下，分数 (fraction) 部分最高有效位（即整数字）是1，那么这个浮点数将被称为规约形式的浮点数。“规约”是指用唯一确定的浮点形式去表示一个值。由于这种表示下的尾数有一位隐含的二进制有效数字，为了与二进制科学计数法的尾数（mantissa）相区别，IEEE754称之为有效数（significant）。\n\n\n- 非规格化值（Denormalized Value）：如果浮点数的指数部分的编码值是0，分数部分非零，那么这个浮点数将被称为非规约形式的浮点数。一般是某个数字相当接近零时才会使用非规约型式来表示。 IEEE 754标准规定：非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小1。例如，最小的规约形式的单精度浮点数的指数部分编码值为1，指数的实际值为-126；而非规约的单精度浮点数的指数域编码值为0，对应的指数实际值也是-126而不是-127。实际上非规约形式的浮点数仍然是有效可以使用的，只是它们的绝对值已经小于所有的规约浮点数的绝对值；即所有的非规约浮点数比规约浮点数更接近0。规约浮点数的尾数大于等于1且小于2，而非规约浮点数的尾数小于1且大于0。\n\n#### 特殊值\n\n三个特殊值需要指出：\n\n1. 如果指数是0并且尾数的小数部分是0，这个数±0（和符号位相关）\n2. 如果指数为$2^e-1$并且尾数的小数部分是0，这个数是±∞（同样和符号位相关）\n3. 如果指数为$2^e-1$并且尾数的小数部分非0，这个数表示为非数（NaN）。\n\n#### 总结\n\n总结以上所有的情况：\n\n形式 | 指数 | 小数部分\n--- | --- | ---\n零 | 0 | 0\n非规约形式 | 0 | 大于0小于1\n规约形式 | 1到2^(e)-2 | 大于等于1小于2\n无穷 | 2^(e)-1 | 0\nNaN | 2^(e)-1 | 非0\n\n单精度浮点数各种极值情况：\n\n| 类别           | 正负号 | 实际指数 | 有偏移指数 | 指数域         | 尾数域                           | 数值                                 |\n| -------------- | ------ | -------- | ---------- | -------------- | -------------------------------- | ------------------------------------ |\n| 零             | 0      | -127     | 0          | 0000 0000      | 000 0000 0000 0000 0000 0000     | 0.0                                  |\n| 负零           | 1      | -127     | 0          | 0000 0000      | 000 0000 0000 0000 0000 0000     | -0.0                                 |\n| 1              | 0      | 0        | 127        | 0111 1111      | 000 0000 0000 0000 0000 0000     | 1.0                                  |\n| -1             | 1      | 0        | 127        | 0111 1111      | 000 0000 0000 0000 0000 0000     | -1.0                                 |\n| 最小的非规约数 | *      | -126     | 0          | 0000 0000      | 000 0000 0000 0000 0000 0001     | ±2^-23 × 2^-126 ≈ ±2^-149 ≈ ±1.4×10^-45 |\n| 中间大小的非规约数 | *  | -126     | 0          | 0000 0000      | 100 0000 0000 0000 0000 0000     | ±2^-1 × 2^-126 ≈ ±2^-127 ≈ ±5.88×10^-39 |\n| 最大的非规约数 | *      | -126     | 0          | 0000 0000      | 111 1111 1111 1111 1111 1111     | ±(1-2^-23) × 2^-126 ≈ ±1.18×10^-38       |\n| 最小的规约数 | *        | -126     | 1          | 0000 0001      | 000 0000 0000 0000 0000 0000     | ±2^-126 ≈ ±1.18×10^-38                  |\n| 最大的规约数 | *        | 127      | 254        | 1111 1110      | 111 1111 1111 1111 1111 1111     | ±(2^-2^-23) × 2^127 ≈ ±3.4×10^38        |\n| 正无穷         | 0      | 128      | 255        | 1111 1111      | 000 0000 0000 0000 0000 0000     | +∞                                   |\n| 负无穷         | 1      | 128      | 255        | 1111 1111      | 000 0000 0000 0000 0000 0000     | -∞                                   |\n| NaN            | *      | 128      | 255        | 1111 1111      | 非全0                            | NaN\n\n### 浮点数的舍入\n\n任何有效数上的运算结果，通常都存放在较长的寄存器中，当结果被放回浮点格式时，必须将多出来的比特丢弃。 有多种方法可以用来执行舍入作业，实际上IEEE标准列出4种不同的方法：\n\n- 舍入到最接近：舍入到最接近，在一样接近的情况下偶数优先（Ties To Even，这是默认的舍入方式）：会将结果舍入为最接近且可以表示的值，但是当存在两个数一样接近的时候，则取其中的偶数（在二进制中是以0结尾的）。\n- 朝+∞方向舍入：会将结果朝正无限大的方向舍入。\n- 朝-∞方向舍入：会将结果朝负无限大的方向舍入。\n- 朝0方向舍入：会将结果朝0的方向舍入。\n\n### 浮点数的运算性质\n\n浮点数的运算不遵循结合性和分配性。","tags":["CSAPP","C语言","二进制","补码","浮点数"],"categories":["CSAPP"]},{"title":"关于free和delete","url":"/posts/3a68c5f2/","content":"free 函数和 delete 运算符都用于释放内存空间，但它们之间有一些重要的区别。\n\n首先，free 函数是 C 语言标准库中的函数，而 delete 运算符是 C++ 语言中的运算符。\n\n其次，free 函数只能释放由 malloc、calloc 或 realloc 分配的内存空间，而 delete 运算符既可以释放由 new、new[]、malloc、calloc、realloc 分配的内存空间，也可以释放由 new、new[] 分配的对象空间。\n\n此外，当释放内存空间时，free 函数只是释放内存空间，而不会调用被释放对象的析构函数；而 delete 运算符除了释放内存空间外，还会调用被释放对象的析构函数，从而执行对象的清理工作。\n\n总之，虽然 free 函数和 delete 运算符都可以释放内存空间，但是由于它们的使用场景和行为有所不同，因此在 C++ 中建议使用 delete 运算符来释放内存空间。","tags":["C++"],"categories":["算法笔记"]},{"title":"CSAPP 第一章：计算机系统漫游","url":"/posts/19b7c283/","content":"# CSAPP 第一章：计算机系统漫游\n\n## 1.1 信息就是位+上下文\n\n计算机以二进制形式表示信息，每个二进制位表示一种状态，可以表示数字、字符等等。\n上下文指的是信息被解释的环境，同样的位在不同上下文中可能有不同的含义。\n字节是计算机中常用的信息单位，一个字节通常表示8位二进制数据。\n\n## 1.2 程序被其他程序翻译成不同的格式\n\n操作系统负责将高级语言程序翻译成机器语言程序，其中编译器将高级语言翻译成汇编语言，汇编器将汇编语言翻译成机器语言。\n目标代码是机器语言的二进制表示形式，可执行目标代码是可直接在计算机上运行的机器语言程序。\n共享库是一段被多个程序共享的目标代码，使得程序在运行时所需的内存更小。\n\n## 1.3 了解编译系统如何工作是大有益处的\n\n- 优化程序性能\n- 理解链接是出现的错误\n- 避免安全漏洞\n\n## 1.4 处理器读取并解释存储在内存中的指令\n\n存储器层次结构指的是计算机中各个存储设备（寄存器、缓存、主存、硬盘等）按照距离处理器远近划分的层次结构。\n处理器解释并执行存储在内存中的指令，指令集体系结构定义了处理器能够执行的指令集合。\n程序计数器是一个寄存器，保存当前正在执行的指令地址，处理器按顺序逐条执行指令。\n\n## 1.5 高速缓存至关重要\n\n高速缓存是存储器层次结构中的一级缓存，用于加速处理器访问主存中的数据。\n高速缓存采用空间局部性和时间局部性原理，预测处理器未来访问的数据，提前将其缓存到高速缓存中。\n高速缓存的命中率指的是处理器需要的数据在高速缓存中的比例，高速缓存的访问时间短于主存，能显著提升程序性能。\n\n## 1.6 存储设备形成层次结构\n\n存储设备也有层次结构，根据访问时间、容量和价格的不同分为寄存器、高速缓存、主存、硬盘等层次。\n存储设备的层次结构决定了数据的访问速度和容量，越靠近处理器的存储设备速度越快，容量越小。\n存储器和磁盘都采用二进制编址方案，即将每个存储单元（或扇区）赋予一个唯一的二进制地址，用于在存储设备中寻找数据。\n\n## 1.7 操作系统管理硬件\n\n操作系统是计算机中负责管理各种硬件设备的程序，包括进程、内存、文件等。\n操作系统为进程提供了虚拟地址空间，使得每个进程看到的内存空间都是相同的。\n文件系统是操作系统中负责管理磁盘上文件和目录的程序，文件被组织成目录树结构。\n\n## 1.8 系统之间利用网络通信\n\n高速网络使得计算机之间可以快速传输大量数据，网络中传输的数据以分组为单位。\n因特网是一种全球范围内的计算机网络，互联了数十亿个计算机。\n网络协议是计算机间通信的规则，常见的网络协议有TCP/IP协议。\n\n## 1.9 重要主题\n\n### Amdahl定律\n\n该定律指出，一个程序在多处理器系统上的加速比取决于其可并行化部分的比例和处理器的数量。\n\n假设一个程序的总运行时间为$T$，其中有一个比例为$\\alpha$的部分可以被并行化（即可以使用多个处理器同时执行），而剩余的比例为$1 - \\alpha$的部分必须在单个处理器上顺序执行。如果该程序在单个处理器上运行的时间为$T_1$，在$N$个处理器上运行的时间为$T_N$，则该程序在$N$个处理器上的加速比为：\n\n$$\nSpeedup_{overall} = \\frac{1}{(1 - \\alpha) + \\frac{\\alpha}{N}}\n$$\n\n### 并发与并行\n并发指的是多个计算机或进程在同一时间内执行多个任务的能力，可以提高程序的性能。\n操作系统需要管理多个进程之间的并发访问，包括进程调度、同步、互斥等机制。\n并发编程需要注意同步和互斥问题，多线程编程需要注意线程安全问题。\n","tags":["CSAPP","计算机组成原理"],"categories":["CSAPP"]},{"title":"53. 最大子数组和","url":"/posts/460c78a0/","content":"# [leetcode-53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)\n\n所有的动态规划，都要按照下面的模板解题：\n\n## 理解题意\n\n题目要我们找出和最大的连续子数组的值是多少，**连续**是关键字，连续很重要，不是子序列。\n\n题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用**动态规划**解决。\n\n## 定义状态（定义子问题）\n\n$dp[i]$:表示以$num[i]$ **结尾**的**连续**子数组的最大和。\n\n## 状态转移方程（描述子问题之间的联系）\n\n根据状态的定义，由于$nums[i]$一定会被选取，并且以$nums[i]$结尾的连续子数组与以$nums[i - 1]$结尾的连续子数组只相差一个元素 $nums[i]$。\n\n假设数组 nums 的值全都严格大于0，那么一定有$dp[i] = dp[i - 1] + nums[i]$。\n\n可是$dp[i - 1]$有可能是负数，于是分类讨论：\n\n如果$dp[i - 1] > 0$，那么可以把$nums[i]$直接接在$dp[i - 1]$表示的那个数组的后面，得到和更大的连续子数组；\n如果$dp[i - 1] <= 0$，那么$nums[i]$加上前面的数$dp[i - 1]$以后值不会变大。于是$dp[i]$ 另起炉灶，此时单独的一个$nums[i]$的值，就是$dp[i]$。\n以上两种情况的最大值就是$dp[i]$的值，写出如下状态转移方程：\n\n$$\ndp[i]= \\begin{cases}\ndp[i-1]+nums[i] & dp[i−1]>0 \\\\\nnums[i],& dp[i−1]≤0 \\\\\n\\end{cases}\n$$\n\n记为状态转移方程 1。\n\n状态转移方程还可以这样写，反正求的是最大值，也不用分类讨论了，就这两种情况，取最大即可，因此还可以写出状态转移方程如下：\n\n$$\ndp[i] = max\\left\\{nums[i],dp[i-1]+nums[i]\\right\\}\n$$\n\n记为状态转移方程 2。\n\n## 思考初始值\n\n$dp[0]$根据定义，只有1个数，一定以$nums[0]$结尾，因此$dp[0] = nums[0]$。\n\n## 思考输出\n\n这里状态的定义不是题目中的问题的定义，**不能直接将最后一个状态返回回去**。\n\n这个问题的输出是把所有的$dp[0]、dp[1]、……、dp[n - 1]$都看一遍，取最大值。\n\n## 编码\n\n```C++\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        vector<int> sum = vector(nums.size() + 1, 0);\n        int result = nums[0];\n        for (int i = 1; i <= nums.size(); i++)\n        {\n            sum[i] = max(nums[i-1] + sum[i-1], nums[i-1]);\n            result = max(result, sum[i]);\n        }\n        return result;\n    }\n};\n```","tags":["动态规划"],"categories":["算法笔记"]},{"title":"2389. 和有限的最长子序列","url":"/posts/920f27cb/","content":"# [leetcode-2389. 和有限的最长子序列](https://leetcode.cn/problems/longest-subsequence-with-limited-sum/)\n```C++\nclass Solution {\npublic:\n    vector<int> answerQueries(vector<int>& nums, vector<int>& queries) {\n        int n = nums.size(), m = queries.size();\n        sort(nums.begin(), nums.end());\n        vector<int> f(n + 1);\n        for (int i = 0; i < n; i++) {\n            f[i + 1] = f[i] + nums[i];\n        }\n        vector<int> answer(m);\n        for (int i = 0; i < m; i++) {\n            answer[i] = upper_bound(f.begin(), f.end(), queries[i]) - f.begin() - 1;\n        }\n        return answer;\n    }\n};\n```","tags":["贪心","数组","前缀和","排序"],"categories":["算法笔记"]},{"title":"二叉树的遍历","url":"/posts/ea4681d0/","content":"# [leetcode-94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)\n```C++\nclass Solution {\npublic:\n    void traversal(TreeNode* cur, vector<int>& vec) {\n        if (cur == NULL) return;\n        traversal(cur->left, vec);  // 左\n        vec.push_back(cur->val);    // 中\n        traversal(cur->right, vec); // 右\n    }\n    vector<int> inorderTraversal(TreeNode* root) {\n        vector<int> result;\n        traversal(root, result);\n        return result;\n    }\n};\n```\n经典代码，递归调用遍历函数，前序、中序和后序的区别只在于遍历函数的顺序。","tags":["树","二叉树","递归","前序遍历","中序遍历","后序遍历"],"categories":["算法笔记"]},{"title":"2488. 统计中位数为 K 的子数组","url":"/posts/7911e61f/","content":"# [leetcode-2488. 统计中位数为 K 的子数组](https://leetcode.cn/problems/count-subarrays-with-median-k/)\n```C++\nclass Solution {\npublic:\n    int countSubarrays(vector<int>& nums, int k) {\n        vector<int> sign = vector(nums.size() + 1, 0);\n        unordered_map<int,int> sum;\n        bool isK = false;\n        int result = 0;\n\n        sum[0]++;\n        for(int i = 1; i <= nums.size(); i++)\n        {\n            \n            if(nums[i - 1] > k)\n            sign[i] = sign[i - 1] + 1;\n            else if(nums[i - 1] < k)\n            sign[i] = sign[i - 1] + -1;\n            else\n            {\n                sign[i] = sign[i - 1];\n                isK = true;\n            }\n            if(isK)\n            {\n                result += sum[sign[i]];\n                result += sum[sign[i] - 1];\n            }\n            else\n            sum[sign[i]]++;\n\n            //cout << sign[i] << endl;\n        }\n        return result;\n    }\n};\n```\n\n要使子数组的中位数为k，那么必须符合下列两个条件之一：\n\n- 比k大的数和比k小的数，数量一样多。\n- 比k大的数比比k小的数多一个。\n\n那么把数组作如下处理，比k大的数，标注为1；比k小的数，标注为-1；k标记为0。\n\n然后计算前缀和，可以把前缀和认为的“高度”，数组的标记（-1、0、1）是“坡度”。符合条件的子数组，数组的头和数组的尾，“高度”和前面的两个条件对应，只有两种情况：\n\n- 头尾高度相等。\n- 尾的高度比头高1。\n\n头的索引必然小于等于k的索引，尾的索引必然大于等于k的索引（因为子数组必然包含k）。\n\n把可能的头的“高度”记录在一个哈希表中，每有一个尾，只要找到可能的头，结果就加一。\n\n时间复杂度$O(n)$。\n\n空间复杂度$O(n)$。","tags":["哈希表","数组","困难题","前缀和"],"categories":["算法笔记"]},{"title":"1615. 最大网络秩","url":"/posts/c959ad7e/","content":"# [leetcode-1615. 最大网络秩](https://leetcode.cn/problems/maximal-network-rank/description/)\n\n使用了枚举的办法，时间复杂度$O(n^2)$。\n\n```C++\nclass Solution {\npublic:\n    int maximalNetworkRank(int n, vector<vector<int>>& roads) {\n        vector<vector<int>> rd = vector(n,vector(n,0));\n        vector<int> roadNum = vector(n,0);\n        for(vector<int> road : roads)\n        {\n            rd[min(road[0],road[1])][max(road[0],road[1])] = 1;\n            roadNum[road[0]]++;\n            roadNum[road[1]]++;\n        }\n\n        int maxrank = 0;\n        for (int i = 0; i < n; i++) \n        {\n            for (int j = i + 1; j < n; j++) {\n                int rank =  roadNum[i] + roadNum[j] - rd[i][j];\n                maxrank = max(maxrank,rank);\n            }\n        }\n\n        return maxrank;\n    }\n};\n\n```\n\n也可以用贪心的办法解决，官方题解代码如下：\n\n```C++\nclass Solution {\npublic:\n    int maximalNetworkRank(int n, vector<vector<int>>& roads) {\n        vector<vector<bool>> connect(n, vector<bool>(n, false));\n        vector<int> degree(n);\n        for (auto road : roads) {\n            int x = road[0], y = road[1];\n            connect[x][y] = true;\n            connect[y][x] = true;\n            degree[x]++;\n            degree[y]++;\n        }\n\n        int first = -1, second = -2;\n        vector<int> firstArr, secondArr;\n        for (int i = 0; i < n; ++i) {\n            if (degree[i] > first) {\n                second = first;\n                secondArr = firstArr;\n                first = degree[i];\n                firstArr.clear();\n                firstArr.emplace_back(i);\n            } else if (degree[i] == first) {\n                firstArr.emplace_back(i);\n            } else if (degree[i] > second){\n                secondArr.clear();\n                second = degree[i];\n                secondArr.emplace_back(i);\n            } else if (degree[i] == second) {\n                secondArr.emplace_back(i);\n            }\n        }\n        if (firstArr.size() == 1) {\n            int u = firstArr[0];\n            for (int v : secondArr) {\n                if (!connect[u][v]) {\n                    return first + second;\n                }\n            }\n            return first + second - 1;\n        } else {\n            int m = roads.size();\n            if (firstArr.size() * (firstArr.size() - 1) / 2 > m) {\n                return first * 2;\n            }\n            for (int u: firstArr) {\n                for (int v: firstArr) {\n                    if (u != v && !connect[u][v]) {\n                        return first * 2;\n                    }\n                }\n            }\n            return first * 2 - 1;\n        }\n    }\n};\n```\n时间复杂度为$O(m+n)$。","tags":["贪心","图","枚举"],"categories":["算法笔记"]},{"title":"1605. 给定行和列的和求可行矩阵","url":"/posts/ced0bc4d/","content":"# [leetcode-1605. 给定行和列的和求可行矩阵](https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/description/)\n\n一直贪心就行了，自由度很高。\n\n```C++\nclass Solution {\npublic:\n    vector<vector<int>> restoreMatrix(vector<int>& rowSum, vector<int>& colSum) {\n        int m = rowSum.size();\n        int n = colSum.size();\n        vector<vector<int>> result = vector(m, vector(n, 0));\n        int i = 0, j = 0;\n        while (i < m && j < n)\n        {\n            int v = min(rowSum[i], colSum[j]);\n            result[i][j] = v;\n            rowSum[i] -= v;\n            colSum[j] -= v;\n            if (rowSum[i] == 0) {\n                ++i;\n            }\n            if (colSum[j] == 0) {\n                ++j;\n            }\n        }\n        return result;\n    }\n};\n```","tags":["贪心","矩阵"],"categories":["算法笔记"]},{"title":"2383. 赢得比赛需要的最少训练时长","url":"/posts/b7b4f2bb/","content":"# [leetcode-2383. 赢得比赛需要的最少训练时长](https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/description/)\n```C++\nclass Solution {\npublic:\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\n        int sumExperience = initialExperience;\n        int sumEnergy = 0;\n        int result = 0;\n        for(int num : experience)\n        {\n            if(sumExperience <= num)\n            {\n                result += (num + 1 -sumExperience);\n                sumExperience = num + 1;\n            }\n            else\n            sumExperience += num;\n        }\n        for(int num : energy)\n        {\n            sumEnergy += num;\n        }\n        if(sumEnergy >= initialEnergy)\n        result += (sumEnergy + 1 - initialEnergy);\n        return result;\n    }\n};\n```","tags":["贪心"],"categories":["算法笔记"]},{"title":"239. 滑动窗口最大值","url":"/posts/58d1758d/","content":"# [leetcode-239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/)\n```C++\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        deque<int> maxNum;\n        vector<int> result;\n        for (int i = 0; i < nums.size(); i++)\n        {\n            if(i >= k && nums[i-k] == maxNum.front())\n            maxNum.pop_front();\n            if(maxNum.size() == 0)\n            maxNum.push_back(nums[i]);\n            else\n            {\n                while(!maxNum.empty() &&nums[i] > maxNum.back())\n                {\n                    maxNum.pop_back();\n                }\n                maxNum.push_back(nums[i]);\n            }\n            if(i >= k - 1)\n            result.push_back(maxNum.front());\n        }\n        return result;\n    }\n};\n```\n定义一个双向队列maxNum,用来储存所有可能成为滑动窗口内最大值的数。\n\n一个数如果比另一个数“老”，而且不比这个数大，那么这个数绝无在后面的移动中成为最大值的可能。\n\n那么我们定义的队列，一定是一个从老到新，从大到小排列的队列（因为新入队的大数会把老的小数全部淘汰）。最大值一定在队列的头。进一步可以推理出出队和入队的操作：\n\n- 出队：如果这个数还在队列中（没被淘汰），那么就把它出队。\n- 入队：入队的同时，淘汰所有的比它更小的数。\n\n所以只需要维护这个队列，即可得到答案。\n\n时间复杂度为$O(n)$,空间复杂度为$O(k)$。","tags":["栈","队列","滑动窗口","困难题"],"categories":["算法笔记"]},{"title":"150. 逆波兰表达式求值","url":"/posts/b3578cd3/","content":"# [leetcode-150. 逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)\n```C++\nclass Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n        stack<long long> st;\n        for(string str : tokens)\n        {\n            if(str == \"+\" || str == \"-\" || str == \"*\"|| str == \"/\")\n            {\n                long long num1 = st.top();\n                st.pop();\n                long long num2 = st.top();\n                st.pop();\n                if(str == \"+\") \n                st.push(num2 + num1);\n                if(str == \"-\") \n                st.push(num2 - num1);\n                if(str == \"*\") \n                st.push(num2 * num1);\n                if(str == \"/\") \n                st.push(num2 / num1);\n                \n            }\n            else\n            {\n                st.push(stoll(str));\n            }\n        }\n        return st.top();\n    }\n};\n```\n这段代码是一个计算逆波兰表达式的函数，其中输入的参数是一个字符串类型的 vector，表示逆波兰表达式。该函数的返回值是计算出的表达式的结果。\n\n逆波兰表达式是一种将运算符放在操作数之后的表示数学表达式的方法。例如，中缀表达式 \"3 + 4\" 在逆波兰表示法中为 \"3 4 +\"。\n\n函数通过使用一个堆栈来实现计算逆波兰表达式的功能。在遍历逆波兰表达式时，如果当前的字符串为运算符，则从堆栈中弹出两个操作数，并将它们应用于该运算符。否则，如果当前的字符串为操作数，则将其作为 long long 类型解析，并将其压入堆栈中。\n\n最终，堆栈中仅剩一个元素，即为计算出的逆波兰表达式的结果，将其返回即可。","tags":["栈","逆波兰"],"categories":["算法笔记"]},{"title":"像素画-薇古丝（未完成）","url":"/posts/c49d4bce/","content":"# 像素画薇古丝\n![](https://raw.githubusercontent.com/vinouno/blog_image/main/%E8%96%87%E5%8F%A4%E4%B8%9D-400-%E6%9C%AA%E5%AE%8C%E6%88%90.png)\n\n外形大体上满意（就是头发画的很僵硬）。\n但是高光和阴影很难达到满意的效果，尝试数次，放弃，待进步后完成。","tags":["像素画","未完成"],"categories":["绘画笔记"]},{"title":"665. 非递减数列","url":"/posts/36199ffe/","content":"# [leetcode-65. 非递减数列](https://leetcode.cn/problems/non-decreasing-array/description/)\n\n这段代码实现了一个时间复杂度为 O(n)、空间复杂度为 O(1) 的解法，用于判断在最多修改一个元素的情况下，给定的数组 nums 能否变成一个非递减数列。\n\n具体来说，它通过遍历数组 nums，对于每一对相邻元素 (x, y) 进行比较，如果 x > y，则说明需要修改一个元素才能满足非递减的条件。此时，将修改次数 cnt 加一，并判断 cnt 是否超过了一次，如果超过了一次，则说明无法只修改一个元素来满足条件，直接返回 false。\n\n如果 cnt 不超过一次，则需要考虑修改哪个元素。为了保证修改后的数组满足非递减的条件，有两种可能的情况需要考虑：\n\n1. 修改 nums[i]，使得 x <= y，此时修改后的数组可能会影响到 i - 1 和 i + 1 位置的元素。如果 nums[i + 1] < nums[i - 1]，则说明需要将 nums[i + 1] 修改为 nums[i]，否则将 nums[i] 修改为 nums[i + 1]。\n\n2. 修改 nums[i + 1]，使得 x <= y，此时只会影响到 i + 1 位置的元素，因为 i 和 i - 1 位置的元素已经是非递减的了。因此，直接将 nums[i + 1] 修改为 nums[i] 即可。\n\n最后，如果遍历完整个数组 nums 之后都没有返回 false，则说明只需要修改不超过一次元素就可以将数组变成非递减的，返回 true 即可。\n\n```C++\nclass Solution {\npublic:\n    bool checkPossibility(vector<int> &nums) {\n        int n = nums.size(), cnt = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            int x = nums[i], y = nums[i + 1];\n            if (x > y) {\n                cnt++;\n                if (cnt > 1) {\n                    return false;\n                }\n                if (i > 0 && y < nums[i - 1]) {\n                    nums[i + 1] = x;\n                }\n            }\n        }\n        return true;\n    }\n};\n```","tags":["数组"],"categories":["算法笔记"]},{"title":"453. 最小操作次数使数组元素相等","url":"/posts/fa3eb899/","content":"# [leetcode-453. 最小操作次数使数组元素相等](https://leetcode.cn/problems/minimum-moves-to-equal-array-elements/description/)\nn-1个数加一，等价于1个数减一。\n\n```C++\nclass Solution {\npublic:\n    int minMoves(vector<int>& nums) {\n        int sum = 0, min = nums[0];\n        for (int i : nums)\n        {\n            if(i < min)\n            min = i;\n            sum += i;\n        }\n        return sum-(min*nums.size());\n    }\n};\n```","tags":["数组"],"categories":["算法笔记"]},{"title":"28. 找出字符串中第一个匹配项的下标","url":"/posts/9d746551/","content":"# [leetcode-28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)\n```C++\nclass Solution {\npublic:\n    vector<int> getNext(const string s) {\n        vector<int> next(s.size());\n        next[0] = -1;\n        int i = 0, j = -1;\n        while (i < s.size() - 1) {\n            if (j == -1 || s[j] == s[i]) {\n                j++;\n                i++;\n                next[i] = j;\n            } else {\n                j = next[j];\n            }\n        }\n        return next;\n    }\n\n    int strStr(string haystack, string needle) {\n        vector<int> next = getNext(needle);\n        int i = 0, j = 0;\n        while (i < haystack.size()) {\n            if (j == -1 || haystack[i] == needle[j]) {\n                i++;\n                j++;\n                if (j == needle.size()) {\n                    return i - j;\n                }\n            } else {\n                j = next[j];\n            }\n        }\n        return -1;\n    }\n};\n```\n\n这段代码实现了经典的字符串匹配算法 KMP。KMP 算法的核心是利用已经匹配的信息来避免重复匹配，从而提高匹配效率。\n\n首先，我们来看 getNext 函数。该函数用于计算 needle 字符串的前缀表（prefix table），也称为失配函数（failure function）。前缀表是一个数组，其中第 i 个元素表示 needle 字符串中以第 i 个字符结尾的子串的最长前缀和最长后缀相等的长度。\n\n具体来说，我们定义两个指针 i 和 j，其中 i 表示当前子串的结尾位置，j 表示当前子串的最长前缀和最长后缀相等的长度。初始化时，i 和 j 都指向字符串的开头，前缀表的第一个元素设为 -1。\n\n接下来，我们在一个循环中不断计算前缀表中的元素。每次循环，我们比较 s[i] 和 s[j] 是否相等，如果相等，说明可以将 j 增加 1，同时将前缀表中下一个元素设为 j。如果不相等，我们需要将 j 回溯到前缀表中 j 对应的值，这是因为我们已经知道前面的 j 个字符是匹配的，所以可以直接跳过这些字符，从前面已经匹配的位置重新开始匹配。这个过程可以用递推式 j = next[j] 来描述。\n\n最后，我们返回前缀表。\n\n我们来看 strStr 函数。该函数用于在 haystack 字符串中查找 needle 字符串的第一个匹配项。首先，我们调用 getNext 函数计算出 needle 字符串的前缀表。然后，我们定义两个指针 i 和 j，其中 i 表示当前在 haystack 中匹配的位置，j 表示当前在 needle 中匹配的位置。初始化时，i 和 j 都指向字符串的开头。\n\n我们在一个循环中不断尝试匹配 haystack 和 needle 中的字符。如果当前字符匹配成功，我们将 i 和 j 同时向后移动一个位置，继续匹配下一个字符。如果 j 到达了 needle 的末尾，说明已经找到了匹配项，我们可以返回 i - j。如果当前字符匹配失败，我们需要将 j 回溯到前缀表中 j 对应的值，重新开始匹配。这个过程可以用递推式 `j = next[j]` 来描述。如果 j 已经回溯到了 -1，说明在当前位置找不到匹配项，需要将 i 向后移动一个位置，重新开始匹配。\n\n最后，如果循环结束还没有找到匹配项，说明在 haystack 中找不到 needle，需要返回 -1。\n\n总体来说，这段代码的时间复杂度为 $O(m+n)$，其中 $m$ 和 $n$ 分别是 haystack 和 needle 的长度。这是因为在计算前缀表和匹配字符串时，指针 i 和 j 各自最多向前移动 $m$ 和 $n$ 次。空间复杂度为 $O(n)$，其中 $n$ 是 needle 的长度，这是因为前缀表需要保存 needle 中每个位置的最长前缀和最长后缀相等的长度。\n\n总之，这段代码非常经典和实用，可以在很多场景下使用，比如搜索引擎中的字符串匹配、文本编辑器中的搜索功能等等。","tags":["字符串","KMP算法"],"categories":["算法笔记"]},{"title":"像素画练习（临摹）-稻草人费德提克","url":"/posts/2083f273/","content":"# 原图\n从P站上找了一张稻草人的像素图，尝试第一次临摹。\n\n![](https://raw.githubusercontent.com/vinouno/blog_image/main/%E7%A8%BB%E8%8D%89%E4%BA%BA-%E5%8E%9F%E5%9B%BE.png)\n\n# 轮廓临摹\n这个还是比较满意的，外形基本复现成功了。我想让稻草人的腿更长一点，就把它的腿拉长了，看上去也没太违和。\n\n![](https://raw.githubusercontent.com/vinouno/blog_image/main/%E7%A8%BB%E8%8D%89%E4%BA%BA-400.png)\n\n# 上色\n上色的结果不是特别满意，想让稻草人灰暗一点，这样才有恐怖的感觉。但是试了很多次，总感觉不是特别满意，没画出原图那种“脏”的感觉，不像一个扭曲的怪物，还是要对调色多加练习。\n\n![](https://raw.githubusercontent.com/vinouno/blog_image/main/%E7%A8%BB%E8%8D%89%E4%BA%BA-400-%E4%B8%8A%E8%89%B2.png)","tags":["像素画","临摹","绘画练习"],"categories":["绘画笔记"]},{"title":"用像素画一棵树吧","url":"/posts/feda20cd/","content":"# 绘画步骤\n像素画是一种新兴的艺术形式，一般被应用在一些小游戏里。\n\n究其本质，和传统绘画是一样的，重点在于轮廓和色彩。接下来，我们通过画一棵树，来展现像素画的一般步骤。\n\n## 抽象成几何图形\n任何图形，都可以被抽象成若干几何图形的组合：比如平行四边形、梯形、椭圆等。\n\n画一颗树也是如此，因此，我们可以把树抽象成这样的几何图形：上面一个椭圆表示树冠、下面一个矩形表示树干。\n\n## 整形、补充细节\n显然这么简单的图形是没法表现一棵树的，因此我们应该增加一些细节：\n- 在矩形和圆的连接处留空，表示分开的树杈。\n- 矩形的底部延伸出几条线，表示根。\n- 椭圆的外延，沿弧线的切线方向衍生出若干不规则的毛刺，表示向外延伸的树冠。\n\n完成这些步骤，这个图形就有树的雏形了。\n\n## 定义光源、区分明暗\n可以假设照射这棵树的阳光来自右上，这样就可以用浅灰、深灰和黑色，分别表示树受到强烈光照、一般光照、较少光照的部分。\n\n由于光源在右上角，浅灰的部分会集中在右上，黑色的部分则集中在左下。\n\n由于树冠是不规则的，自由生长的，我们可以想象，这棵树有两个亮面，一个在右上，一个在正面偏左的位置。浅灰和深灰交替分布，但是仍然要遵循一个原则：离光源越近，明亮的部分就分布越密。\n\n## 上色\n我们可以先调出树叶的绿色和树干的棕色。\n运用色轮的知识，分别调出这两个颜色的亮色和暗色。把这些色彩涂在树上，一颗树就完成了。\n\n## 成果展示\n这是放大十倍的效果图，也许看上去还有些不自然的地方：\n\n![](https://raw.githubusercontent.com/vinouno/blog_image/main/%E6%A0%91-%E5%A4%A7.png)\n\n但是这棵树只是在48px*48px画布上完成的一个简单作品，如果只放大四倍，问题就没那么大了。\n\n![](https://raw.githubusercontent.com/vinouno/blog_image/main/%E6%A0%91-%E5%B0%8F.png)\n\n如果再画几棵形态各异的树，把它们放在树林场景里，就非常自然了。\n\n# 补充知识\n像素画是一种简单的绘画形式，一个初学者只要几天就能画出像样的画来。\n但是，形式上的简单不代表我们可以忽视其他绘画形式所需的基础知识。\n\n## 色轮\n![](https://raw.githubusercontent.com/vinouno/blog_image/main/%E8%89%B2%E8%BD%AE.png)\n\n### 第一次色、第二次色和第三次色\n绘画中，我们可以把红、黄、蓝定义为三原色，又名第一次色。\n\n第一次色两两混合，又产生了绿、橙、紫三色，称为第二次色。\n\n第一次色和相邻的第二次色混合，会产生六种更中间的颜色。\n\n把这十二种颜色按顺序排列在一个圆上，就得到了十二色相环。\n\n### 色相、饱和度、明度\n- 色相指的是色彩在色相环所处的位置。因为圆是360度的，所以它的数值范围是0-360。\n- 饱和度是指色彩的鲜艳程度。个人理解，就是和灰色的混合程度。饱和度越低，颜色就越灰；饱和度越高，颜色就越鲜艳。因为这是一个百分数，所以数值范围是0-100.\n- 明度是指色彩的明亮程度。个人理解，就是混合的灰色所占的黑白比例。明度越高，就越白；明度越低，就越黑。\n\n### 冷暖色、补偿色\n冷暖色是色彩给人心理上感觉。红、黄、橙是暖色，而绿、蓝、紫是冷色。\n补偿色是指在色轮上位置相对的颜色，这两种颜色对比最强烈。比如橙色和蓝色，如果在一片蓝天中画一个橙色的太阳，强烈的对比会一下子吸引住观赏者。\n\n### 色彩与光照\n遵照如下的原则，就可以找到一个色彩的亮色和暗色。\n\n|        | 强光照 | 弱光照 |\n| :----: | :----: | :----: |\n|  色相  |  更暖  |  更冷  |\n| 饱和度 | 更鲜艳 | 更灰暗 |\n|  明度  |  更亮  |  更暗  |\n\n## 抗锯齿\n线条是物体轮廓的组成部分，充满锯齿和毛刺的像素线条是非常违和的，我们追求的是自然的线条。一种常用的办法是用更亮的颜色填充线条的外围，做出半透明的质感。\n\n## 负空间\n练习像素画的过程中少不了临摹，判断临摹的像不像，要关注临摹作品的负空间。","tags":["像素画","教程学习"],"categories":["绘画笔记"]},{"title":"1047. 删除字符串中的所有相邻重复项","url":"/posts/a807ef62/","content":"# [leetcode-1047. 删除字符串中的所有相邻重复项](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)\n```C++\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        string result;\n        for(char ch: s)\n        {\n            if (result.back() != ch || result.empty())\n            {\n                result.push_back(ch);\n            }\n            else\n            result.pop_back();\n        }\n        return result;\n    }\n};\n```","tags":["栈","字符串"],"categories":["算法笔记"]},{"title":"225. 用队列实现栈&&232. 用栈实现队列","url":"/posts/75057265/","content":"# [leetcode-225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)\n\n用队列实现栈，就要在出队的时候，把所有元素全部出队，前n-1个元素重新入队\n\n```C++\nclass MyStack {\npublic:\n    queue<int> que;\n    /** Initialize your data structure here. */\n    MyStack() {\n\n    }\n    /** Push element x onto stack. */\n    void push(int x) {\n        que.push(x);\n    }\n    /** Removes the element on top of the stack and returns that element. */\n    int pop() {\n        int size = que.size();\n        size--;\n        while (size--) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部\n            que.push(que.front());\n            que.pop();\n        }\n        int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了\n        que.pop();\n        return result;\n    }\n\n    /** Get the top element. */\n    int top() {\n        return que.back();\n    }\n\n    /** Returns whether the stack is empty. */\n    bool empty() {\n        return que.empty();\n    }\n};\n```\n# [leetcode-232. 用栈实现队列](https://leetcode.cn/problems/implement-stack-using-queues/)\n\n用栈实现队列，则需要两个栈，一个输入栈，一个输出栈，出栈的时候，如果输出栈为空，就从把输入栈全部出栈并且入输出栈。\n\n```C++\nclass MyQueue {\npublic:\n    stack<int> stIn;\n    stack<int> stOut;\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        stIn.push(x);\n    }\n    \n    int pop() {\n        if(stOut.empty())\n        {\n            while (!stIn.empty())\n            {\n                stOut.push(stIn.top());\n                stIn.pop();\n            }          \n        }\n        int result = stOut.top();\n        stOut.pop();\n        return result;\n    }\n    \n    int peek() {\n        int res = this->pop();\n        stOut.push(res);\n        return res;\n    }\n    \n    bool empty() {\n        return stIn.empty() && stOut.empty();\n    }\n};\n\n```","tags":["栈","队列"],"categories":["算法笔记"]},{"title":"151. 反转字符串中的单词","url":"/posts/dd14d712/","content":"# [leetcode-151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)\n```C++\nclass Solution {\npublic:\n    void reverse(string& s, int start, int end){ //翻转，区间写法：左闭右闭 []\n        for (int i = start, j = end; i < j; i++, j--) {\n            swap(s[i], s[j]);\n        }\n    }\n\n    void removeExtraSpaces(string& s) {//去除所有空格并在相邻单词之间添加空格, 快慢指针。\n        int slow = 0;   //整体思想参考https://programmercarl.com/0027.移除元素.html\n        for (int i = 0; i < s.size(); ++i) { //\n            if (s[i] != ' ') { //遇到非空格就处理，即删除所有空格。\n                if (slow != 0) s[slow++] = ' '; //手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。\n                while (i < s.size() && s[i] != ' ') { //补上该单词，遇到空格说明单词结束。\n                    s[slow++] = s[i++];\n                }\n            }\n        }\n        s.resize(slow); //slow的大小即为去除多余空格后的大小。\n    }\n\n    string reverseWords(string s) {\n        removeExtraSpaces(s); //去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。\n        reverse(s, 0, s.size() - 1);\n        int start = 0; //removeExtraSpaces后保证第一个单词的开始下标一定是0。\n        for (int i = 0; i <= s.size(); ++i) {\n            if (i == s.size() || s[i] == ' ') { //到达空格或者串尾，说明一个单词结束。进行翻转。\n                reverse(s, start, i - 1); //翻转，注意是左闭右闭 []的翻转。\n                start = i + 1; //更新下一个单词的开始下标start\n            }\n        }\n        return s;\n    }\n};\n```","tags":["字符串","双指针"],"categories":["算法笔记"]},{"title":"15. 三数之和","url":"/posts/e192590d/","content":"# [leetcode-15. 三数之和](https://leetcode.cn/problems/3sum/)\n\n## 滑动窗口\n![](https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif)\n```C++\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> result;\n        for (int num1 = 0; num1 < nums.size() - 2; num1++)\n        {\n            if(num1 > 0 && nums[num1] == nums[num1 - 1])\n            continue;   //去重\n            int num2 = num1 + 1;\n            int num3 = nums.size() - 1;\n            while (num2 < num3)\n            {\n                if(nums[num1] + nums[num2] + nums[num3] > 0)\n                {\n                    num3--;\n                }\n                else if(nums[num1] + nums[num2] + nums[num3] < 0)\n                {\n                    num2++;\n                }\n                else\n                {   \n                    vector<int> temp;\n                    temp.push_back(nums[num1]);\n                    temp.push_back(nums[num2]);\n                    temp.push_back(nums[num3]);\n                    result.push_back(temp);\n                    while(num2 < num3 && nums[num2] == nums[num2 + 1])\n                    num2++; //去重\n                    while(num2 < num3 && nums[num3] == nums[num3 - 1])\n                    num3--; //去重\n\n                    num2++;\n                    num3--;\n                }\n            }           \n        }\n        return result;\n    }\n};\n```\n\n## 哈希表\n还有一种哈希的做法，但是去重会更加复杂，代码直接用别人的。\n```C++\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        vector<vector<int>> result;\n        sort(nums.begin(), nums.end());\n        // 找出a + b + c = 0\n        // a = nums[i], b = nums[j], c = -(a + b)\n        for (int i = 0; i < nums.size(); i++) {\n            // 排序之后如果第一个元素已经大于零，那么不可能凑成三元组\n            if (nums[i] > 0) {\n                break;\n            }\n            if (i > 0 && nums[i] == nums[i - 1]) { //三元组元素a去重\n                continue;\n            }\n            unordered_set<int> set;\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (j > i + 2\n                        && nums[j] == nums[j-1]\n                        && nums[j-1] == nums[j-2]) { // 三元组元素b去重\n                    continue;\n                }\n                int c = 0 - (nums[i] + nums[j]);\n                if (set.find(c) != set.end()) {\n                    result.push_back({nums[i], nums[j], c});\n                    set.erase(c);// 三元组元素c去重\n                } else {\n                    set.insert(nums[j]);\n                }\n            }\n        }\n        return result;\n    }\n};\n```","tags":["哈希","滑动窗口"],"categories":["算法笔记"]},{"title":"541. 反转字符串 II","url":"/posts/e20c25b0/","content":"# [leetcode-541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/description/)\n```C++\nclass Solution {\npublic:\n    void reverse(string& s, int start, int end) {\n        for (int i = start, j = end; i < j; i++, j--) {\n            swap(s[i], s[j]);\n        }\n    }\n    string reverseStr(string s, int k) {\n        for (int i = 0; i < s.size(); i += (2 * k)) {\n            // 1. 每隔 2k 个字符的前 k 个字符进行反转\n            // 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符\n            if (i + k <= s.size()) {\n                reverse(s, i, i + k - 1);\n                continue;\n            }\n            // 3. 剩余字符少于 k 个，则将剩余字符全部反转。\n            reverse(s, i, s.size() - 1);\n        }\n        return s;\n    }\n};\n```","tags":["字符串"],"categories":["算法笔记"]},{"title":"344. 反转字符串","url":"/posts/f8e8b99a/","content":"# [leetcode-344. 反转字符串](https://leetcode.cn/problems/reverse-string/)\n\n太简单了，不知道写什么内容，就当熟悉语法了。\n\n```C++\nclass Solution {\npublic:\n    void reverseString(vector<char>& s) {\n        for(int i = 0; i < s.size()/2; i++)\n        {\n            swap(s[i],s[s.size() - 1 - i]);\n        }\n    }\n};\n```","tags":["字符串"],"categories":["算法笔记"]},{"title":"383. 赎金信","url":"/posts/3fb1f6fc/","content":"# [leetcode-383. 赎金信](https://leetcode.cn/problems/ransom-note/)\n\n常用的办法是开一个长度为26的数组，但是用`unordered_map`也一样。\n\n```C++\nclass Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n        unordered_map<char,int> umap;\n        for(auto a : magazine)\n        {\n            umap[a]++;\n        }\n        for(auto b : ransomNote)\n        {\n            if(umap[b] == 0)\n            return false;\n            umap[b]--;\n        }\n        return true;\n    }\n};\n```","tags":["哈希"],"categories":["算法笔记"]},{"title":"454. 四数相加 II","url":"/posts/8ea35345/","content":"# [leetcode-454. 四数相加 II](https://leetcode.cn/problems/4sum-ii/)\n\n- 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。\n\n- 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。\n\n- 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。\n\n- 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。\n\n- 最后返回统计值 count 就可以了\n\n```C++\nclass Solution {\npublic:\n    int fourSumCount(vector<int>& nums1, vector<int>& nums2, vector<int>& nums3, vector<int>& nums4) {\n        unordered_map<int,int> umap;\n        int count = 0;\n        for(int a : nums1)\n        {\n            for(int b : nums2)\n            {\n                umap[a + b]++;\n            }\n        }\n\n        for(int c : nums3)\n        {\n            for(int d : nums4)\n            {\n                if(umap.find(- c - d) != umap.end() )\n                {\n                    count += umap[- c - d];\n                }\n            }\n        }\n        return count;\n    }\n};\n```","tags":["哈希"],"categories":["算法笔记"]},{"title":"202. 快乐数","url":"/posts/827e2fc4/","content":"# [leetcode-202. 快乐数](https://leetcode.cn/problems/happy-number/)\n\n定义一个函数计算数位平方和，把每次的和记录在一个哈希表中，每计算一次检验一次，如果出现重复的元素，说明无限循环了。\n\n```C++\nclass Solution {\npublic:\n    int getSum(int num)\n    {\n        int sum = 0;\n        while(num > 0)\n        {\n            sum += ((num % 10) * (num % 10));\n            num /= 10;   \n        }\n        return sum;\n    }\n\n    bool isHappy(int n) {\n        unordered_set<int> nums;\n        while (nums.find(n) == nums.end())\n        {\n            nums.insert(n);\n            n = getSum(n);\n            if(n == 1)\n            return true;\n        }\n        return false;\n    }\n};\n```","tags":["哈希"],"categories":["算法笔记"]},{"title":"算法笔记-综述","url":"/posts/41de9669/","content":"# 算法笔记-综述\n聊聊算法笔记分类下的文章。\n\n## 在这个分类下写文章的初衷是什么？\n目前，只是个人对leetcode刷题过程的记录，相当于私人笔记本。\n\n## 为什么有的文章带标题题号，而有的文章没有？\n标题带题号的文章，都是写题过程记的流水账，文字很少，只是对题目的简单描述，这种文章只起到记录的作用。\n\n不带题号的文章，大多是对一类型题的总结，文字内容比较多。\n\n## 文章保证原创吗？\n不保证，文章内有很多内容都是来自[代码随想录](https://programmercarl.com/)和leetcode上的题解。\n\n## 那为什么不标注出处？\n- 懒\n- 我认为没有必要。本站不打算吸引很多浏览者，个人性质的笔记没必要大费周章写明出处。","tags":["综述"],"categories":["算法笔记"]},{"title":"3. 无重复字符的最长子串","url":"/posts/4bff4329/","content":"# [leetcode-3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)\n\n这道题最主要的考察点还是滑动窗口，但是刚刚学习了C++中的哈希表用法，练习一下api调用。\n\n```C++\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int fastIndex = 0, slowIndex = 0, size = 0;\n        int maxSize = 0;\n        unordered_set<char> words;\n        while(fastIndex < s.size())\n        {\n            if(words.count(s[fastIndex]) == 0)\n            {\n                words.insert(s[fastIndex]);\n                fastIndex++;\n                size++;\n                if(size > maxSize)\n                maxSize++;\n            }\n            else\n            {\n                while(words.count(s[fastIndex]) != 0)\n                {\n                    words.erase(s[slowIndex]);\n                    slowIndex++;\n                    size--;\n                }\n            }\n        }\n        return maxSize;\n    }\n};\n```","tags":["哈希","滑动窗口"],"categories":["算法笔记"]},{"title":"1. 两数之和","url":"/posts/b55528ce/","content":"# [leetcode-1. 两数之和](https://leetcode.cn/problems/two-sum/description/)\n```C++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> hashtable;\n        for (int i = 0; i < nums.size(); ++i) {\n            auto it = hashtable.find(target - nums[i]);\n            if (it != hashtable.end()) { \n                //hashtable.end指向的位置是最后一个元素的下一个元素\n                //find没找到内容时，就会返回这个结果\n                return {it->second, i};\n            }\n            hashtable[nums[i]] = i; //录入数据\n        }\n        return {};\n    }\n};\n```","tags":["哈希"],"categories":["算法笔记"]},{"title":"C++中的STL无序（哈希）容器","url":"/posts/99013716/","content":"# 常见的三种哈希结构\n当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。\n\n- 数组\n- set（集合）\n- map (映射)\n\n这里数组就没啥可说的了，我们来看一下set。\n\n在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：\n\n| 集合 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 |增删效率 |\n| :----:| :----: | :----: | :----:| :----: | :----: |:----: |\n| std::set | 红黑树 | 有序 | 否 | 否 | \tO(log n) | \tO(log n) |\n| std::multiset | 红黑树 | 有序 | 是 | 否 | O(log n) | O(log n) |\n| std::unordered_set | 哈希表 | 无序 | 否 | 否 | O(1) | O(1) |\n\nstd::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。\n\n| 集合 | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 |增删效率 |\n| :----:| :----: | :----: | :----:| :----: | :----: |:----: |\n| std::map | 红黑树 | key有序 | key不可重复 | key不可修改 | \tO(log n) | \tO(log n) |\n| std::multimap | 红黑树 | key有序 | key可重复 | key可修改 | O(log n) | O(log n) |\n| std::unordered_map | 哈希表 | key无序 | key不可重复 | key不可修改 | O(1) | O(1) |\n\nstd::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。\n\n当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。\n\n那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。\n\n其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。\n\n虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，std::set、std::multiset 使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。\n\n这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？\n\n实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。","tags":["哈希","C++","STL"],"categories":["算法笔记"]},{"title":"哈希表","url":"/posts/850f2080/","content":"# 哈希表\n\n哈希的原理就不再赘述了。第一题虽然使用数组完成题目，但是已经涉及到哈希的思想。\n\n[leetcode-242. 有效的字母异位词](https://leetcode.cn/problems/valid-anagram/)\n```C++\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        int record[26] = {0};\n        for (int i = 0; i < s.size(); i++) {\n            // 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了\n            record[s[i] - 'a']++;\n        }\n        for (int i = 0; i < t.size(); i++) {\n            record[t[i] - 'a']--;\n        }\n        for (int i = 0; i < 26; i++) {\n            if (record[i] != 0) {\n                // record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。\n                return false;\n            }\n        }\n        // record数组所有元素都为零0，说明字符串s和t是字母异位词\n        return true;\n    }\n};\n```\n\n第二题用了哈希表，要注意`unordered_set`的使用方法。\n\n[leetcode-349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)\n```C++\nclass Solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        unordered_set<int> result_set; // 存放结果，之所以用set是为了给结果集去重\n        unordered_set<int> nums_set(nums1.begin(), nums1.end()); //两个迭代器复制元素\n        for (int num : nums2) {\n            // 发现nums2的元素 在nums_set里又出现过\n            if (nums_set.find(num) != nums_set.end()) {\n                result_set.insert(num);\n            }\n        }\n        return vector<int>(result_set.begin(), result_set.end());\n    }\n};\n```","tags":["哈希"],"categories":["算法笔记"]},{"title":"142. 环形链表 II","url":"/posts/ec4387b9/","content":"# [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/description/)\n\n这道题非常地有趣，旨在找到链表中环的起始点。\n\n## 哈希法\n\n最容易的办法是遍历链表中的每个节点，用哈希表储存地址，如果有重复的内容，说明找到了环的起始点。\n\n```C++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        unordered_set<ListNode *> visited;\n        while(head != nullptr)\n        {\n            if(visited.count(head)) //返回head出现的次数\n            {\n                return head;\n            }\n            visited.insert(head);\n            head = head->next;\n        }\n        return nullptr;\n        }\n};\n\n```\n\n## 数学法\n第二种办法是数学法，具体可以参考题解：[环形链表 II（双指针法，清晰图解）](https://leetcode.cn/problems/linked-list-cycle-ii/solutions/12616/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/)\n\n概括一下：\n\n根据：\n\nf = 2s （快指针每次2步，路程刚好2倍）\n\nf = s + nb （相遇时，刚好多走了n圈）\n\n推出：s = nb\n\n从head结点走到入环点需要走 ： a + nb， 而slow已经走了nb，那么slow再走a步就是入环点了。\n\n如何知道slow刚好走了a步？ 从head开始，和slow指针一起走，相遇时刚好就是a步.\n\n```C++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n         ListNode* fast = head;\n         ListNode* slow = head;\n        while (true) {\n            if (fast == NULL || fast->next == NULL) return NULL;\n            fast = fast->next->next;\n            slow = slow->next;\n            if (fast == slow) break;\n        }\n        fast = head;\n        while (slow != fast) {\n            slow = slow->next;\n            fast = fast->next;\n        }\n        return fast;\n    }\n};\n```\n\n## 巧妙法\n\nO(n)算法，应该是最快的。 堆的地址从低到高，LeetCode的链表内存是顺序申请的，如果有环，head->next一定小于或等于head。\n\n这个办法在实际生产中没法使用，因为堆内会不断地new和delete新的节点。\n\n```C++\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        while(head) {\n            if(!less<ListNode *>()(head, head->next)) {\n                return head->next;\n            }\n            head = head->next;\n        }\n        return nullptr;\n    }\n};\n```","tags":["哈希","双指针","链表","巧妙构思"],"categories":["算法笔记"]},{"title":"160. 相交链表","url":"/posts/f6a6c904/","content":"# [leetcode-160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)\n\n由于链表的特殊性质，一旦多条链表在一个节点相交，那么后面所有的节点都是重合的。所以，链表相交一定发生在链表的尾部。\n\n解决方案是，把两条链表尾部对齐，使两指针一起移动，如果发现地址相同，说明链表已经相交。\n\n```C++\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* curA = headA;\n        ListNode* curB = headB;\n        int lenA = 0, lenB = 0;\n        while (curA != NULL) { // 求链表A的长度\n            lenA++;\n            curA = curA->next;\n        }\n        while (curB != NULL) { // 求链表B的长度\n            lenB++;\n            curB = curB->next;\n        }\n        curA = headA;\n        curB = headB;\n        // 让curA为最长链表的头，lenA为其长度\n        if (lenB > lenA) {\n            swap (lenA, lenB);\n            swap (curA, curB);\n        }\n        // 求长度差\n        int gap = lenA - lenB;\n        // 让curA和curB在同一起点上（末尾位置对齐）\n        while (gap--) {\n            curA = curA->next;\n        }\n        // 遍历curA 和 curB，遇到相同则直接返回\n        while (curA != NULL) {\n            if (curA == curB) {\n                return curA;\n            }\n            curA = curA->next;\n            curB = curB->next;\n        }\n        return NULL;\n    }\n};\n```","tags":["双指针","链表"],"categories":["算法笔记"]},{"title":"19. 删除链表的倒数第 N 个结点","url":"/posts/e3fcab93/","content":"# [leetcode-19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)\n\n熟悉的双指针，让fastIndex先前进n步，再让两个指针一起前进，直到fastIndex到达最后一个元素。此时，slowIndex所在的位置即为要删除节点的前一个元素，方便删除操作。\n\n本题稍微卡壳的地方在于，要删除的节点是第一个节点的问题，是没法找到要删除的节点的前一个节点的。但是在引入虚拟头节点dummyHead后，问题就解决了。\n\n```C++\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* dummyHead = new ListNode(0);\n        dummyHead->next = head;\n        ListNode* slowIndex = dummyHead;\n        ListNode* fastIndex = dummyHead;\n        for(int i = 0; i < n; i++)\n        {\n            fastIndex = fastIndex->next;\n        }\n\n        while(fastIndex->next != NULL)\n        {\n            fastIndex = fastIndex->next;\n            slowIndex = slowIndex->next;\n        }\n\n        ListNode* temp = slowIndex->next;\n        slowIndex->next = temp->next;\n        delete temp; \n\n        return dummyHead->next;\n    }\n};\n```","tags":["双指针","链表"],"categories":["算法笔记"]},{"title":"66. 加一","url":"/posts/67f68e42/","content":"# [leetcode-66. 加一](https://leetcode.cn/problems/plus-one/description/)\n```C++\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        for(int i = digits.size() - 1; i >= 0; i--)\n        {\n            if(digits[i] != 9)\n            {\n                digits[i]++;\n                return digits;\n            }\n            else\n            digits[i] = 0;\n        }\n        //出了循环，说明全是9\n        vector<int> result(digits.size() + 1, 0);\n        result[0] = 1;\n        return result;\n    }\n};\n```","tags":["数组"],"categories":["算法笔记"]},{"title":"206. 反转链表","url":"/posts/7787fb56/","content":"# [leetcode-206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)\n\n灵活运用了双指针，一快一慢两个指针\n\n![翻转链表](https://picx.zhimg.com/80/v2-1032cc15783f29d404801aaad96a0e4e_720w.webp?source=d16d100b)\n```C++\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* pre = NULL;\n        ListNode* cur = head;\n        ListNode* temp; //用临时节点储存cur的下个节点。\n        while(cur != NULL)\n        {\n            temp = cur->next;\n            cur->next = pre;\n            pre = cur;\n            cur = temp;\n        }\n        return pre;\n    }\n};\n```","tags":["双指针","链表"],"categories":["算法笔记"]},{"title":"707. 设计链表","url":"/posts/f348f3f8/","content":"# [leetcode-707. 设计链表](https://leetcode.cn/problems/design-linked-list/)\n```C++\nclass MyLinkedList {\npublic:\n    // 定义链表节点结构体\n    struct LinkedNode {\n        int val;\n        LinkedNode* next;\n        LinkedNode(int val):val(val), next(nullptr){}\n    };\n\n    // 初始化链表\n    MyLinkedList() {\n        _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点\n        _size = 0;\n    }\n\n    // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点\n    int get(int index) {\n        if (index > (_size - 1) || index < 0) {\n            return -1;\n        }\n        LinkedNode* cur = _dummyHead->next;\n        while(index--){ // 如果--index 就会陷入死循环\n            cur = cur->next;\n        }\n        return cur->val;\n    }\n\n    // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点\n    void addAtHead(int val) {\n        LinkedNode* newNode = new LinkedNode(val);\n        newNode->next = _dummyHead->next;\n        _dummyHead->next = newNode;\n        _size++;\n    }\n\n    // 在链表最后面添加一个节点\n    void addAtTail(int val) {\n        LinkedNode* newNode = new LinkedNode(val);\n        LinkedNode* cur = _dummyHead;\n        while(cur->next != nullptr){\n            cur = cur->next;\n        }\n        cur->next = newNode;\n        _size++;\n    }\n\n    // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。\n    // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点\n    // 如果index大于链表的长度，则返回空\n    void addAtIndex(int index, int val) {\n        if (index > _size) {\n            return;\n        }\n        LinkedNode* newNode = new LinkedNode(val);\n        LinkedNode* cur = _dummyHead;\n        while(index--) {\n            cur = cur->next;\n        }\n        newNode->next = cur->next;\n        cur->next = newNode;\n        _size++;\n    }\n\n    // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的\n    void deleteAtIndex(int index) {\n        if (index >= _size || index < 0) {\n            return;\n        }\n        LinkedNode* cur = _dummyHead;\n        while(index--) {\n            cur = cur ->next;\n        }\n        LinkedNode* tmp = cur->next;\n        cur->next = cur->next->next;\n        delete tmp;\n        _size--;\n    }\n\n    // 打印链表\n    void printLinkedList() {\n        LinkedNode* cur = _dummyHead;\n        while (cur->next != nullptr) {\n            cout << cur->next->val << \" \";\n            cur = cur->next;\n        }\n        cout << endl;\n    }\nprivate:\n    int _size;\n    LinkedNode* _dummyHead;\n\n};\n```","tags":["链表"],"categories":["算法笔记"]},{"title":"203. 移除链表元素","url":"/posts/9a8d3ba6/","content":"# [leetcode-203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)\n\n链表的种种性质操作早已熟记于心，但是上手写代码的时候还是有种种困难。\n话不多说，直接上代码：\n```C++\nclass Solution {\npublic:\n    ListNode* removeElements(ListNode* head, int val) {\n        ListNode* dummyHead = new ListNode(0,head);  //创建虚拟头结点，后面操作可以统一\n        ListNode* cur = dummyHead; //创建用来遍历的节点，cur=current\n        while (cur->next != NULL)\n        {\n            if(cur->next->val == val)\n            {\n                ListNode* temp = cur->next;\n                cur->next = cur->next->next; //删除操作，反而是最简单的一步\n                delete temp; //C++一定要释放空间\n            }\n            else\n            {\n                cur = cur->next; //不是要删除的节点，就跳过\n            }\n        }\n        head = dummyHead->next;\n        delete dummyHead;//释放空间\n        return head;\n    }\n};\n```","tags":["链表"],"categories":["算法笔记"]},{"title":"59. 螺旋矩阵II","url":"/posts/4df2c59e/","content":"# [leetcode-59. 螺旋矩阵II](https://leetcode.cn/problems/spiral-matrix-ii/)\n\n以n=3为例，此矩阵共赋值9次，移动8次，沿4个方向移动，问题的关键在于如何把这些操作不重不漏地分类完成。\n\n下一步要思考的是，根据n的不同，如何把这些操作分配到不同的轮次内，一个可行的办法是转一圈，算作一个轮次。\n\n一个轮次内有4个方向，由此可知，至少要写4个循环才能完成目标，同一方向的操作，写在一个循环内。\n\n最后，在完成一圈后，移动到下一圈开始的位置，即可完成循环。\n\n![实例](https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg)\n\n```C++\nclass Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>> result(n,vector(n,0));\n        int i = 1, x = 0, y = 0, loop = n;  //loop为轮次的长度\n        while (loop > 0)\n        {\n            for(int step = 0; step < loop -1; step++)\n            {\n                result[x][y] = i;\n                y++;\n                i++;\n            }\n            for(int step = 0; step < loop - 1; step++)\n            {\n                result[x][y] = i;\n                x++;\n                i++;\n            }\n            for(int step = 0; step < loop - 1; step++)\n            {\n                result[x][y] = i;\n                y--;\n                i++;\n            }\n            for(int step = 0; step < loop - 2; step++)\n            {\n                result[x][y] = i;\n                x--;\n                i++;\n            }\n            //四次循环，对应四个方向的移动\n            result[x][y] = i;\n            y++;\n            i++;\n            //把位置重置到下一轮的起始点\n            loop -= 2;\n        }\n        return result;\n    }\n};\n```","tags":["数组","模拟"],"categories":["算法笔记"]},{"title":"209. 长度最小的子数组","url":"/posts/5b0e75a/","content":"# [leetcode-209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)\n\n如果使用暴力解法，需要用两个for循环嵌套，时间复杂度很明显是O(n^2)。\n\n巧妙的方法是使用滑动窗口的方法，类似计算机网络中的内容，窗口由一前一后两个指针约束。窗口的前指针在循环中不停地前进，寻找最优解。当窗口中的内容不符合最优解的时候，移动后指针直到重新符合条件，再进入循环。\n\n这样做的好处是，通过操作两个指针，只进行了一次循环，时间复杂度降低为O(n).\n```C++\n    //经验不足导致的代码又臭又长\n    class Solution {\n    public:\n        int minSubArrayLen(int target, vector<int>& nums) {\n            int sum = nums[0], fastIndex = 0, slowIndex = 0, length = 1, minLength = nums.size() + 1;\n            if(sum >= target)\n            {\n                return 1;\n            }\n            while(fastIndex < nums.size() - 1)\n            {\n            fastIndex++;\n            length++;\n            sum += nums[fastIndex];\n            while(sum - nums[slowIndex] >= target)\n            {\n                sum -= nums[slowIndex];\n                slowIndex++;\n                length --;\n            }\n            if(sum >= target)\n            minLength = (length < minLength)? length : minLength;\n            }\n            if(minLength == nums.size() + 1)\n            {\n                return 0;\n            }\n            return minLength;  \n        }\n    };\n```","tags":["滑动窗口","数组"],"categories":["算法笔记"]},{"title":"977. 有序数组的平方","url":"/posts/b14e4c6/","content":"# [leetcode-977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)\n此题是一道操作双指针题，两个指针分别从数组的首尾出发，两两比较，将较大的那个平方后输出到结果集中。\n```C++\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        int k = nums.size() - 1;\n        vector<int> result(nums.size(), 0);\n        for (int i = 0, j = nums.size() - 1; i <= j;) { // 注意这里要i <= j，因为最后要处理两个元素\n            if (nums[i] * nums[i] < nums[j] * nums[j])  {\n                result[k--] = nums[j] * nums[j];\n                j--;\n            }\n            else {\n                result[k--] = nums[i] * nums[i];\n                i++;\n            }\n        }\n        return result;\n    }\n};\n```\n![有序数组的平方](https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif \"示意图\")\n","tags":["双指针","数组"],"categories":["算法笔记"]},{"title":"双指针操作数组","url":"/posts/ce6d7c23/","content":"# 双指针操作数组\n双指针法，又称快慢指针法，是数组题中比较简单的一种。\n通过一个快指针和慢指针在一个for循环下完成两个for循环的工作，把复杂度为O(n^2)的暴力法优化为O(n)。\n## Example\n之前做的题目，一两次就过了,没特别深的印象，等遇到难的题目再补充。\n\n[leetcode-27. 移除元素](https://leetcode.cn/problems/remove-element/)\n```C++\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int slowIndex = 0;\n        for(int fastIndex = 0; fastIndex < nums.size(); fastIndex++)\n        {\n            if(val != nums[fastIndex])\n            {\n                nums[slowIndex++] = nums[fastIndex];\n            }\n        }\n        return slowIndex;\n\n    }\n};\n```\n\n[leetcode-26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)\n```C++\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        int slowIndex = 0;\n        for(int fastindex = 1; fastindex < nums.size();fastindex++)\n        {\n            if(nums[fastindex] != nums[fastindex-1])\n            {\n                slowIndex++;\n                nums[slowIndex] = nums[fastindex];\n            }\n        }\n        return slowIndex + 1;\n    }\n};\n```\n\n[leetcode-283. 移动零](https://leetcode.cn/problems/move-zeroes/)\n```C++\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        int slowIndex = 0;\n        for(int fastIndex = 0; fastIndex < nums.size(); fastIndex++)\n        {\n            if (nums[fastIndex] != 0)\n            {\n                nums[slowIndex++] = nums[fastIndex];\n            } \n        }\n\n        while(slowIndex < nums.size())\n        {\n                nums[slowIndex++] = 0;\n        }\n\n    }\n};\n```","tags":["双指针","数组"],"categories":["算法笔记"]},{"title":"二分查找的模板与边界问题","url":"/posts/864a13af/","content":"# 二分查找的模板与边界问题\n二分查找有两套模板，模板A代码如下：\n\n```C++\n    int bsearch_1(int l, int r)\n    {\n        while (l < r)\n        {\n            int mid = (l + r)/2;\n            if (check(mid)) r = mid;\n            else l = mid + 1;\n        }\n        return l;\n    }\n```\n\n模板B代码如下：\n```C++\n    int bsearch_2(int l, int r)\n    {\n        while (l < r)\n        {\n            int mid = (l + r + 1) /2;\n            if (check(mid)) l = mid;\n            else r = mid - 1;\n        }\n        return l;\n    }\n```\n\n## 两套代码有什么区别\n* 模板A区间[l,r]划分成[l,mid]和[mid+1,r],更新操作是`r=mid`或者`l=mid+1`，计算mid时不需要加1，即`mid=(l+r)/2`。\n* 模板B区间[l,r]划分成[l,mid-1]和[mid,r],更新操作是`r=mid-1`或者`l=mid`，计算mid时不需要加1，即`mid=(l+r+1)/2`。\n\n## 为什么使用两套模板的mid计算方法不同？\n当使用模板B时，会有以下这种特殊情况：`r=l+1`。此时，如果使用`mid=(l+r)/2`，向下取整，使得`mid=l`，从而形成无限循环。\n\n## 什么时候用模板A？什么时候用模板B？\n左边界要更新为`l=mid+1`,使用模板A。\n左边界要更新为`l=mid`，则使用模板B。\n\n## 数据溢出怎么办？\n把mid的计算方式更改为`mid=l+((r-l)/2)`。\n\n## Example\n你现在已经完全掌握二分查找了，快来试试看吧：[leetcode-33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)\n示例代码：\n```C++\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        //使用模板A，找到旋转点，用p储存之\n        int l = 0, r = nums.size() - 1;\n        while (l < r)\n        {\n            int mid = (l + r)/2;\n            if (nums[mid] < nums[r]) \n            r = mid;\n            else l = mid + 1;\n        }       \n        int p = l;\n\n        //[0,p]为有序数组，使用模板A二分查找\n        r = p - 1, l = 0;\n        while (l < r)\n        {\n            int mid = (l + r)/2;\n            if (nums[mid] >= target) \n            r = mid;\n            else l = mid + 1;\n        }\n        if(nums[l] == target)\n        return l;\n\n        //p之后为有序数组，使用模板A二分查找\n        l = p, r = nums.size() - 1;\n        while (l < r)\n        {\n            int mid = (l + r)/2;\n            if (nums[mid] >= target) \n            r = mid;\n            else l = mid + 1;\n        }\n        if(nums[l] == target)\n        return l;\n        else\n        return -1;\n    }\n};\n```","tags":["数组","二分查找"],"categories":["算法笔记"]}]