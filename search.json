[{"title":"1. 两数之和","url":"/posts/b55528ce/","content":"<h1 id=\"leetcode-1.-两数之和\"><a\r\nhref=\"https://leetcode.cn/problems/two-sum/description/\">leetcode-1.\r\n两数之和</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">twoSum</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; hashtable;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">auto</span> it = hashtable.<span class=\"built_in\">find</span>(target - nums[i]);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (it != hashtable.<span class=\"built_in\">end</span>()) &#123; </span><br><span class=\"line\">                <span class=\"comment\">//hashtable.end指向的位置是最后一个元素的下一个元素</span></span><br><span class=\"line\">                <span class=\"comment\">//find没找到内容时，就会返回这个结果</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            hashtable[nums[i]] = i; <span class=\"comment\">//录入数据</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;&#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["哈希"]},{"title":"1047. 删除字符串中的所有相邻重复项","url":"/posts/a807ef62/","content":"<h1 id=\"leetcode-1047.-删除字符串中的所有相邻重复项\"><a\r\nhref=\"https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/\">leetcode-1047.\r\n删除字符串中的所有相邻重复项</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">removeDuplicates</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        string result;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">char</span> ch: s)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (result.<span class=\"built_in\">back</span>() != ch || result.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result.<span class=\"built_in\">push_back</span>(ch);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            result.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["字符串","栈"]},{"title":"1039. 多边形三角剖分的最低得分","url":"/posts/a2ea14bf/","content":"<h1 id=\"leetcode-1039.-多边形三角剖分的最低得分\"><a\r\nhref=\"https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/description/\">leetcode-1039.\r\n多边形三角剖分的最低得分</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minScoreTriangulation</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; memo; <span class=\"comment\">// memo是用来记录子问题的解，避免重复计算</span></span><br><span class=\"line\">        <span class=\"type\">int</span> n = values.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        function&lt;<span class=\"type\">int</span>(<span class=\"type\">int</span>, <span class=\"type\">int</span>)&gt; dp = [&amp;](<span class=\"type\">int</span> i, <span class=\"type\">int</span> j) -&gt; <span class=\"type\">int</span> &#123; <span class=\"comment\">// dp函数是用来计算子问题的解</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i + <span class=\"number\">2</span> &gt; j) &#123; <span class=\"comment\">// 当前的多边形边数小于3，不需要进行三角剖分，得分为0</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i + <span class=\"number\">2</span> == j) &#123; <span class=\"comment\">// 当前的多边形边数等于3，只有一种剖分方式，直接计算得分</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> values[i] * values[i + <span class=\"number\">1</span>] * values[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"type\">int</span> key = i * n + j; <span class=\"comment\">// 将子问题的i和j作为key，保存子问题的解</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!memo.<span class=\"built_in\">count</span>(key)) &#123; <span class=\"comment\">// 如果当前子问题没有被计算过，进行计算</span></span><br><span class=\"line\">                <span class=\"type\">int</span> minScore = INT_MAX; <span class=\"comment\">// 初始化当前子问题的最小得分</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> k = i + <span class=\"number\">1</span>; k &lt; j; k++) &#123; <span class=\"comment\">// 枚举剖分点k，计算最小得分</span></span><br><span class=\"line\">                    minScore = <span class=\"built_in\">min</span>(minScore, values[i] * values[k] * values[j] + <span class=\"built_in\">dp</span>(i, k) + <span class=\"built_in\">dp</span>(k, j));</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                memo[key] = minScore; <span class=\"comment\">// 将子问题的解保存到memo中</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> memo[key]; <span class=\"comment\">// 返回子问题的解</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">dp</span>(<span class=\"number\">0</span>, n - <span class=\"number\">1</span>); <span class=\"comment\">// 计算整个多边形的最小得分</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"解题思路\">解题思路</h2>\r\n<p>这道题可以使用动态规划（DP）来求解。具体来说，可以定义一个 DP 函数\r\ndp(i, j)，表示对于多边形的第 i 个顶点到第 j\r\n个顶点之间的区间，选择不相交的对角线将其分成若干个三角形的最小得分之和。那么最终的答案即为\r\ndp(0, n-1)，其中 n 是顶点的个数。</p>\r\n<p>对于 dp(i, j)，可以枚举 i 和 j 之间的所有顶点 k，并尝试将顶点 i\r\n和顶点 j\r\n之间的一条对角线连接起来，将多边形分成两个部分。然后分别递归求解左右两个部分的最小得分之和，并将其加上当前三角形的得分，得到当前方案的总得分。最后取所有方案的总得分中的最小值即可。</p>\r\n<p>为了避免重复计算，可以使用备忘录（memoization）技术对已经计算过的结果进行缓存。首先创建了一个\r\nunordered_map&lt;int, int&gt; 类型的 memo\r\n变量，用于记录已经计算过的子问题的答案，以避免重复计算。</p>\r\n<p>然后定义了一个名为 dp 的 lambda 函数，它的输入参数为两个整数 i 和\r\nj，输出一个整数，代表计算多边形顶点 i 到顶点 j\r\n之间构成的三角形的最小分数。这个 lambda\r\n函数内部采用记忆化搜索的方式来避免重复计算。首先检查是否已经计算过当前子问题的答案，如果没有则通过遍历顶点\r\ni 到顶点 j\r\n之间的所有可能的三角形，分别计算分数，然后取最小值并将结果存入 memo\r\n中。</p>\r\n<p>最后调用 dp 函数计算多边形从顶点 0 到顶点 n-1\r\n之间构成的三角形的最小分数，并将结果作为函数的返回值。</p>\r\n<p>综上，这段代码实现了一种动态规划算法，用于计算多边形中所有可能的三角形分割方案中的最小分数。其中使用了记忆化搜索来避免重复计算，lambda\r\n函数 dp 中定义了具体的计算逻辑。</p>\r\n<h2 id=\"lamda表达式和function\">lamda表达式和function</h2>\r\n<p>这段代码是最复杂的：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">function&lt;<span class=\"type\">int</span>(<span class=\"type\">int</span>, <span class=\"type\">int</span>)&gt; dp = [&amp;](<span class=\"type\">int</span> i, <span class=\"type\">int</span> j) -&gt; <span class=\"type\">int</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\r\n<p>这行代码定义了一个函数对象 dp，这个函数对象是一个 std::function\r\n类型的变量，它指向一个以 int 和 int 为输入参数，以 int\r\n为返回值的函数。</p>\r\n<p>具体来说，function&lt;int(int, int)&gt; 表示 dp\r\n是一个函数对象，它接受两个 int 类型的参数，返回一个 int\r\n类型的值。这个函数对象在后面的实现中被赋值为一个 lambda 表达式，这个\r\nlambda 表达式定义了动态规划的状态转移方程。</p>\r\n<p>&amp; 符号表示通过引用捕获外部变量，[&amp;]\r\n表示以引用的方式捕获所有外部变量，即函数对象内部可以访问外部的变量和函数。在本例中，lambda\r\n表达式需要访问 values 和 memo 这两个变量。</p>\r\n<p>-&gt; int 表示函数对象返回值的类型是 int，dp(i, j)\r\n表示函数对象的调用方式，即传入两个参数 i 和 j 并返回一个 int\r\n类型的值。</p>\r\n<p>总之，这行代码定义了一个函数对象\r\ndp，它表示动态规划中的状态转移方程。在实际运行中，通过调用 dp(i, j)\r\n可以计算出以 i 和 j 为顶点的三角形的最小得分，并且使用 memo\r\n对已经计算过的值进行了缓存，以避免重复计算。</p>\r\n","categories":["算法笔记"],"tags":["动态规划","记忆化搜索","C++"]},{"title":"103. 二叉树的锯齿形层序遍历","url":"/posts/6d6dcbcb/","content":"<h1 id=\"leetcode-103.-二叉树的锯齿形层序遍历\"><a\r\nhref=\"https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/description/\">leetcode-103.\r\n二叉树的锯齿形层序遍历</a></h1>\r\n<p>这里使用的是正常层序遍历再翻转的方法，这样在实现上更简单，官方解也是这么写的。实际上双端队列的方法其实更符合题目的原意。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class=\"line\">        deque&lt;TreeNode*&gt; st;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        st.<span class=\"built_in\">push_back</span>(root);</span><br><span class=\"line\">        <span class=\"type\">int</span> depth = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!st.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> size = st.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            vector&lt;<span class=\"type\">int</span>&gt; temp;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                TreeNode* node = st.<span class=\"built_in\">back</span>();</span><br><span class=\"line\">                st.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">                temp.<span class=\"built_in\">push_back</span>(node-&gt;val);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node-&gt;left)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    st.<span class=\"built_in\">push_front</span>(node-&gt;left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node-&gt;right)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    st.<span class=\"built_in\">push_front</span>(node-&gt;right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(depth%<span class=\"number\">2</span> == <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"built_in\">reverse</span>(temp.<span class=\"built_in\">begin</span>(),temp.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">            result.<span class=\"built_in\">push_back</span>(temp);</span><br><span class=\"line\">            depth++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["树","二叉树","层序遍历","队列"]},{"title":"1003. 检查替换后的词是否有效","url":"/posts/3937f726/","content":"<h1 id=\"leetcode-1003.-检查替换后的词是否有效\"><a\r\nhref=\"https://leetcode.cn/problems/check-if-word-is-valid-after-substitutions/\">leetcode-1003.\r\n检查替换后的词是否有效</a></h1>\r\n<p>把前面的a、b都存在一个栈里面，如果找到c,就用c收回前面的ab。</p>\r\n<p>发生两种情况之一即可认为词无效：</p>\r\n<ul>\r\n<li>字符串遍历完，栈中仍然有剩余的字符。</li>\r\n<li>C没有收回ab（这一定会导致c留在栈内，因为没有任何字符可以收回c）</li>\r\n</ul>\r\n<p>出栈的时候要注意，栈是不是空栈。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isValid</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        stack&lt;<span class=\"type\">char</span>&gt; st;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">char</span> ch : s)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ch == <span class=\"string\">&#x27;c&#x27;</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(!st.<span class=\"built_in\">empty</span>() &amp;&amp; st.<span class=\"built_in\">top</span>() == <span class=\"string\">&#x27;b&#x27;</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(!st.<span class=\"built_in\">empty</span>() &amp;&amp; st.<span class=\"built_in\">top</span>() == <span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">                    &#123;</span><br><span class=\"line\">                        st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    <span class=\"keyword\">else</span></span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            st.<span class=\"built_in\">push</span>(ch);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(st.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["字符串","栈"]},{"title":"111. 二叉树的最小深度","url":"/posts/f5d798b7/","content":"<h1 id=\"leetcode-111.-二叉树的最小深度\"><a\r\nhref=\"https://leetcode.cn/problems/minimum-depth-of-binary-tree/\">leetcode-111.\r\n二叉树的最小深度</a></h1>\r\n<p>用层序遍历，找到最浅的叶子节点。</p>\r\n<p>层序遍历的传统写法如下，用队列完成操作：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minDepth</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        queue&lt;TreeNode*&gt; que;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        que.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">        <span class=\"type\">int</span> depth = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!que.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            depth++;</span><br><span class=\"line\">            <span class=\"type\">int</span> size = que.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                TreeNode* node = que.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                que.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node-&gt;left)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    que.<span class=\"built_in\">push</span>(node-&gt;left);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node-&gt;right)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    que.<span class=\"built_in\">push</span>(node-&gt;right);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node-&gt;right == <span class=\"literal\">nullptr</span> &amp;&amp; node-&gt;left == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> depth;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["树","二叉树","层序遍历"]},{"title":"113. 路径总和 II","url":"/posts/7f3d8fdb/","content":"<h1 id=\"leetcode-113.-路径总和-ii\"><a\r\nhref=\"https://leetcode.cn/problems/path-sum-ii/\">leetcode-113. 路径总和\r\nII</a></h1>\r\n<p>两个哈希表，一个储存和，一个储存路径。</p>\r\n<p>m储存节点所在的和，p储存经过的路径。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">pathSum</span>(TreeNode* root, <span class=\"type\">int</span> targetSum) &#123;</span><br><span class=\"line\">        unordered_map&lt;TreeNode*,<span class=\"type\">int</span>&gt; m;</span><br><span class=\"line\">        unordered_map&lt;TreeNode*,vector&lt;<span class=\"type\">int</span>&gt;&gt; p;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; result;</span><br><span class=\"line\">        queue&lt;TreeNode*&gt; que;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(root != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            que.<span class=\"built_in\">push</span>(root);</span><br><span class=\"line\">            m[root] = root-&gt;val;</span><br><span class=\"line\">            p[root].<span class=\"built_in\">push_back</span>(root-&gt;val);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(root-&gt;val == targetSum &amp;&amp; root-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            result.<span class=\"built_in\">push_back</span>(p[root]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!que.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> size = que.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                TreeNode* node = que.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">                que.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node-&gt;left)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    m[node-&gt;left] = m[node] + node-&gt;left-&gt;val;</span><br><span class=\"line\">                    que.<span class=\"built_in\">push</span>(node-&gt;left);</span><br><span class=\"line\">                    p[node-&gt;left].<span class=\"built_in\">insert</span>(p[node-&gt;left].<span class=\"built_in\">end</span>(),p[node].<span class=\"built_in\">begin</span>(),p[node].<span class=\"built_in\">end</span>());</span><br><span class=\"line\">                    p[node-&gt;left].<span class=\"built_in\">push_back</span>(node-&gt;left-&gt;val);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(m[node-&gt;left] == targetSum &amp;&amp; node-&gt;left-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; node-&gt;left-&gt;right == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">                    result.<span class=\"built_in\">push_back</span>(p[node-&gt;left]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(node-&gt;right)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    m[node-&gt;right] = m[node] + node-&gt;right-&gt;val;</span><br><span class=\"line\">                    que.<span class=\"built_in\">push</span>(node-&gt;right);</span><br><span class=\"line\">                    p[node-&gt;right].<span class=\"built_in\">insert</span>(p[node-&gt;right].<span class=\"built_in\">end</span>(),p[node].<span class=\"built_in\">begin</span>(),p[node].<span class=\"built_in\">end</span>());</span><br><span class=\"line\">                    p[node-&gt;right].<span class=\"built_in\">push_back</span>(node-&gt;right-&gt;val);</span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(m[node-&gt;right] == targetSum &amp;&amp; node-&gt;right-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; node-&gt;right-&gt;right == <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">                    result.<span class=\"built_in\">push_back</span>(p[node-&gt;right]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["哈希","树","二叉树","层序遍历","哈希表"]},{"title":"136. 只出现一次的数字","url":"/posts/93cfc1bf/","content":"<h1 id=\"leetcode-136.-只出现一次的数字\"><a\r\nhref=\"https://leetcode.cn/problems/single-number/\">leetcode-136.\r\n只出现一次的数字</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">singleNumber</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> num : nums)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result = result ^ num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>对于任意数n：</p>\r\n<ul>\r\n<li>n ^ n = 0</li>\r\n<li>n ^ 0 = n</li>\r\n<li>异或满足交换律：a ^ b ^ c = a ^ c ^ b</li>\r\n</ul>\r\n<p>满足线性时间复杂度的要求。</p>\r\n","categories":["算法笔记"],"tags":["位运算"]},{"title":"1053. 交换一次的先前排列","url":"/posts/cbdd2f8b/","content":"<h1 id=\"leetcode-1053.-交换一次的先前排列\"><a\r\nhref=\"https://leetcode.cn/problems/previous-permutation-with-one-swap/description/\">leetcode-1053.\r\n交换一次的先前排列</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">prevPermOpt1</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = arr.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(arr[n] &gt;= arr[n<span class=\"number\">-1</span>])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            n--;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> temp = n - <span class=\"number\">1</span>;</span><br><span class=\"line\">        n = arr.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(arr[temp] &lt;= arr[n])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            n--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(arr[n - <span class=\"number\">1</span>] == arr[n])</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            n--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(arr[n], arr[temp]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["贪心"]},{"title":"142. 环形链表 II","url":"/posts/ec4387b9/","content":"<h1 id=\"环形链表-ii\"><a\r\nhref=\"https://leetcode.cn/problems/linked-list-cycle-ii/description/\">142.\r\n环形链表 II</a></h1>\r\n<p>这道题非常地有趣，旨在找到链表中环的起始点。</p>\r\n<h2 id=\"哈希法\">哈希法</h2>\r\n<p>最容易的办法是遍历链表中的每个节点，用哈希表储存地址，如果有重复的内容，说明找到了环的起始点。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">detectCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">        unordered_set&lt;ListNode *&gt; visited;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(head != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(visited.<span class=\"built_in\">count</span>(head)) <span class=\"comment\">//返回head出现的次数</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            visited.<span class=\"built_in\">insert</span>(head);</span><br><span class=\"line\">            head = head-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"数学法\">数学法</h2>\r\n<p>第二种办法是数学法，具体可以参考题解：<a\r\nhref=\"https://leetcode.cn/problems/linked-list-cycle-ii/solutions/12616/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/\">环形链表\r\nII（双指针法，清晰图解）</a></p>\r\n<p>概括一下：</p>\r\n<p>根据：</p>\r\n<p>f = 2s （快指针每次2步，路程刚好2倍）</p>\r\n<p>f = s + nb （相遇时，刚好多走了n圈）</p>\r\n<p>推出：s = nb</p>\r\n<p>从head结点走到入环点需要走 ： a + nb，\r\n而slow已经走了nb，那么slow再走a步就是入环点了。</p>\r\n<p>如何知道slow刚好走了a步？\r\n从head开始，和slow指针一起走，相遇时刚好就是a步.</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">detectCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">         ListNode* fast = head;</span><br><span class=\"line\">         ListNode* slow = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast == <span class=\"literal\">NULL</span> || fast-&gt;next == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">            fast = fast-&gt;next-&gt;next;</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (fast == slow) <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        fast = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (slow != fast) &#123;</span><br><span class=\"line\">            slow = slow-&gt;next;</span><br><span class=\"line\">            fast = fast-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fast;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"巧妙法\">巧妙法</h2>\r\n<p>O(n)算法，应该是最快的。\r\n堆的地址从低到高，LeetCode的链表内存是顺序申请的，如果有环，head-&gt;next一定小于或等于head。</p>\r\n<p>这个办法在实际生产中没法使用，因为堆内会不断地new和delete新的节点。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">detectCycle</span><span class=\"params\">(ListNode *head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(head) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(!<span class=\"built_in\">less</span>&lt;ListNode *&gt;()(head, head-&gt;next)) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> head-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            head = head-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["哈希","双指针","链表","巧妙构思"]},{"title":"105. 从前序与中序遍历序列构造二叉树","url":"/posts/7ab68b45/","content":"<h1 id=\"leetcode-105.-从前序与中序遍历序列构造二叉树\"><a\r\nhref=\"https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/\">leetcode-105.\r\n从前序与中序遍历序列构造二叉树</a></h1>\r\n<p>想起一道经典的408题，层序遍历、前序遍历、中序遍历、后序遍历四种遍历方法两两组合，哪个组合不能确定一个二叉树？</p>\r\n<p>答案显然是前序遍历和后序遍历组合。</p>\r\n<p>这里要实现的就是，从前序与中序遍历序列构造二叉树。</p>\r\n<p>方法很简单：把遍历分成左子树、根和右子树，再分别把左右子树递归。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">buildTree</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; preorder, vector&lt;<span class=\"type\">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class=\"line\">        TreeNode* node = <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>(preorder[<span class=\"number\">0</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(preorder.<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">        <span class=\"type\">int</span> left = <span class=\"built_in\">find</span>(inorder.<span class=\"built_in\">begin</span>(),inorder.<span class=\"built_in\">end</span>(),preorder[<span class=\"number\">0</span>]) - inorder.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left != <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">pre</span><span class=\"params\">(preorder.begin() + <span class=\"number\">1</span>, preorder.begin() + <span class=\"number\">1</span> + left)</span></span>;</span><br><span class=\"line\">            <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">ino</span><span class=\"params\">(inorder.begin(),inorder.begin() + left)</span></span>;</span><br><span class=\"line\">            node-&gt;left = <span class=\"built_in\">buildTree</span>(pre, ino);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(left + <span class=\"number\">1</span> != preorder.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">pre</span><span class=\"params\">(preorder.begin() + <span class=\"number\">1</span> + left, preorder.end())</span></span>;</span><br><span class=\"line\">            <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">ino</span><span class=\"params\">(inorder.begin() + left + <span class=\"number\">1</span>, inorder.end())</span></span>;</span><br><span class=\"line\">            node-&gt;right = <span class=\"built_in\">buildTree</span>(pre, ino);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> node;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["树","二叉树","递归","前序遍历","中序遍历"]},{"title":"15. 三数之和","url":"/posts/e192590d/","content":"<h1 id=\"leetcode-15.-三数之和\"><a\r\nhref=\"https://leetcode.cn/problems/3sum/\">leetcode-15. 三数之和</a></h1>\r\n<h2 id=\"滑动窗口\">滑动窗口</h2>\r\n<p><img\r\nsrc=\"https://code-thinking.cdn.bcebos.com/gifs/15.%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C.gif\" />\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">threeSum</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> num1 = <span class=\"number\">0</span>; num1 &lt; nums.<span class=\"built_in\">size</span>() - <span class=\"number\">2</span>; num1++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(num1 &gt; <span class=\"number\">0</span> &amp;&amp; nums[num1] == nums[num1 - <span class=\"number\">1</span>])</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;   <span class=\"comment\">//去重</span></span><br><span class=\"line\">            <span class=\"type\">int</span> num2 = num1 + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> num3 = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (num2 &lt; num3)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(nums[num1] + nums[num2] + nums[num3] &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    num3--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[num1] + nums[num2] + nums[num3] &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    num2++;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span></span><br><span class=\"line\">                &#123;   </span><br><span class=\"line\">                    vector&lt;<span class=\"type\">int</span>&gt; temp;</span><br><span class=\"line\">                    temp.<span class=\"built_in\">push_back</span>(nums[num1]);</span><br><span class=\"line\">                    temp.<span class=\"built_in\">push_back</span>(nums[num2]);</span><br><span class=\"line\">                    temp.<span class=\"built_in\">push_back</span>(nums[num3]);</span><br><span class=\"line\">                    result.<span class=\"built_in\">push_back</span>(temp);</span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(num2 &lt; num3 &amp;&amp; nums[num2] == nums[num2 + <span class=\"number\">1</span>])</span><br><span class=\"line\">                    num2++; <span class=\"comment\">//去重</span></span><br><span class=\"line\">                    <span class=\"keyword\">while</span>(num2 &lt; num3 &amp;&amp; nums[num3] == nums[num3 - <span class=\"number\">1</span>])</span><br><span class=\"line\">                    num3--; <span class=\"comment\">//去重</span></span><br><span class=\"line\"></span><br><span class=\"line\">                    num2++;</span><br><span class=\"line\">                    num3--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;           </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"哈希表\">哈希表</h2>\r\n<p>还有一种哈希的做法，但是去重会更加复杂，代码直接用别人的。\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">threeSum</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; result;</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"comment\">// 找出a + b + c = 0</span></span><br><span class=\"line\">        <span class=\"comment\">// a = nums[i], b = nums[j], c = -(a + b)</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 排序之后如果第一个元素已经大于零，那么不可能凑成三元组</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; nums[i] == nums[i - <span class=\"number\">1</span>]) &#123; <span class=\"comment\">//三元组元素a去重</span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            unordered_set&lt;<span class=\"type\">int</span>&gt; set;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i + <span class=\"number\">1</span>; j &lt; nums.<span class=\"built_in\">size</span>(); j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j &gt; i + <span class=\"number\">2</span></span><br><span class=\"line\">                        &amp;&amp; nums[j] == nums[j<span class=\"number\">-1</span>]</span><br><span class=\"line\">                        &amp;&amp; nums[j<span class=\"number\">-1</span>] == nums[j<span class=\"number\">-2</span>]) &#123; <span class=\"comment\">// 三元组元素b去重</span></span><br><span class=\"line\">                    <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"type\">int</span> c = <span class=\"number\">0</span> - (nums[i] + nums[j]);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (set.<span class=\"built_in\">find</span>(c) != set.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                    result.<span class=\"built_in\">push_back</span>(&#123;nums[i], nums[j], c&#125;);</span><br><span class=\"line\">                    set.<span class=\"built_in\">erase</span>(c);<span class=\"comment\">// 三元组元素c去重</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    set.<span class=\"built_in\">insert</span>(nums[j]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n","categories":["算法笔记"],"tags":["哈希","滑动窗口"]},{"title":"108. 将有序数组转换为二叉搜索树","url":"/posts/17237f5b/","content":"<h1 id=\"leetcode-108.-将有序数组转换为二叉搜索树\"><a\r\nhref=\"https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/\">leetcode-108.\r\n将有序数组转换为二叉搜索树</a></h1>\r\n<p>经典的递归中序遍历树，常做常新。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">sortedArrayToBST</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">helper</span>(nums, <span class=\"number\">0</span>, nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">helper</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> left, <span class=\"type\">int</span> right)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (left &gt; right) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 总是选择中间位置左边的数字作为根节点</span></span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (left + right) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        TreeNode* root = <span class=\"keyword\">new</span> <span class=\"built_in\">TreeNode</span>(nums[mid]);</span><br><span class=\"line\">        root-&gt;left = <span class=\"built_in\">helper</span>(nums, left, mid - <span class=\"number\">1</span>);</span><br><span class=\"line\">        root-&gt;right = <span class=\"built_in\">helper</span>(nums, mid + <span class=\"number\">1</span>, right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["树","二叉树","中序遍历","二叉搜索树"]},{"title":"1376. 通知所有员工所需的时间","url":"/posts/cb655654/","content":"<h1 id=\"leetcode-1376.-通知所有员工所需的时间\"><a\r\nhref=\"https://leetcode.cn/problems/time-needed-to-inform-all-employees/description/\">leetcode-1376.\r\n通知所有员工所需的时间</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">numOfMinutes</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> headID, vector&lt;<span class=\"type\">int</span>&gt;&amp; manager, vector&lt;<span class=\"type\">int</span>&gt;&amp; informTime)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> maxTime = <span class=\"number\">0</span>;</span><br><span class=\"line\">        queue&lt;<span class=\"type\">int</span>&gt; nodes;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; informTime.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(informTime[i] == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                nodes.<span class=\"built_in\">push</span>(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(!nodes.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> node = nodes.<span class=\"built_in\">front</span>();</span><br><span class=\"line\">            nodes.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            <span class=\"type\">int</span> time = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">while</span>(manager[node] != <span class=\"number\">-1</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                time += informTime[manager[node]];</span><br><span class=\"line\">                node = manager[node];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            maxTime = <span class=\"built_in\">max</span>(time, maxTime);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxTime;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>这个树的组织形式有别于其他的二叉树，子知其父而父不知其子，所以从底部入手更简单。</p>\r\n<p>想了一下，队列好像没特别有必要，当成数组用了。</p>\r\n<p>可以用记忆化搜索继续优化，但是懒得算了。</p>\r\n","tags":["树"]},{"title":"150. 逆波兰表达式求值","url":"/posts/b3578cd3/","content":"<h1 id=\"leetcode-150.-逆波兰表达式求值\"><a\r\nhref=\"https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/\">leetcode-150.\r\n逆波兰表达式求值</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">evalRPN</span><span class=\"params\">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class=\"line\">        stack&lt;<span class=\"type\">long</span> <span class=\"type\">long</span>&gt; st;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(string str : tokens)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str == <span class=\"string\">&quot;+&quot;</span> || str == <span class=\"string\">&quot;-&quot;</span> || str == <span class=\"string\">&quot;*&quot;</span>|| str == <span class=\"string\">&quot;/&quot;</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"type\">long</span> num1 = st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"type\">long</span> <span class=\"type\">long</span> num2 = st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">                st.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str == <span class=\"string\">&quot;+&quot;</span>) </span><br><span class=\"line\">                st.<span class=\"built_in\">push</span>(num2 + num1);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str == <span class=\"string\">&quot;-&quot;</span>) </span><br><span class=\"line\">                st.<span class=\"built_in\">push</span>(num2 - num1);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str == <span class=\"string\">&quot;*&quot;</span>) </span><br><span class=\"line\">                st.<span class=\"built_in\">push</span>(num2 * num1);</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str == <span class=\"string\">&quot;/&quot;</span>) </span><br><span class=\"line\">                st.<span class=\"built_in\">push</span>(num2 / num1);</span><br><span class=\"line\">                </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                st.<span class=\"built_in\">push</span>(<span class=\"built_in\">stoll</span>(str));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> st.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>这段代码是一个计算逆波兰表达式的函数，其中输入的参数是一个字符串类型的\r\nvector，表示逆波兰表达式。该函数的返回值是计算出的表达式的结果。</p>\r\n<p>逆波兰表达式是一种将运算符放在操作数之后的表示数学表达式的方法。例如，中缀表达式\r\n\"3 + 4\" 在逆波兰表示法中为 \"3 4 +\"。</p>\r\n<p>函数通过使用一个堆栈来实现计算逆波兰表达式的功能。在遍历逆波兰表达式时，如果当前的字符串为运算符，则从堆栈中弹出两个操作数，并将它们应用于该运算符。否则，如果当前的字符串为操作数，则将其作为\r\nlong long 类型解析，并将其压入堆栈中。</p>\r\n<p>最终，堆栈中仅剩一个元素，即为计算出的逆波兰表达式的结果，将其返回即可。</p>\r\n","categories":["算法笔记"],"tags":["栈","逆波兰"]},{"title":"151. 反转字符串中的单词","url":"/posts/dd14d712/","content":"<h1 id=\"leetcode-151.-反转字符串中的单词\"><a\r\nhref=\"https://leetcode.cn/problems/reverse-words-in-a-string/\">leetcode-151.\r\n反转字符串中的单词</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(string&amp; s, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end)</span></span>&#123; <span class=\"comment\">//翻转，区间写法：左闭右闭 []</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(s[i], s[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">removeExtraSpaces</span><span class=\"params\">(string&amp; s)</span> </span>&#123;<span class=\"comment\">//去除所有空格并在相邻单词之间添加空格, 快慢指针。</span></span><br><span class=\"line\">        <span class=\"type\">int</span> slow = <span class=\"number\">0</span>;   <span class=\"comment\">//整体思想参考https://programmercarl.com/0027.移除元素.html</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); ++i) &#123; <span class=\"comment\">//</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (s[i] != <span class=\"string\">&#x27; &#x27;</span>) &#123; <span class=\"comment\">//遇到非空格就处理，即删除所有空格。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (slow != <span class=\"number\">0</span>) s[slow++] = <span class=\"string\">&#x27; &#x27;</span>; <span class=\"comment\">//手动控制空格，给单词之间添加空格。slow != 0说明不是第一个单词，需要在单词前添加空格。</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span> (i &lt; s.<span class=\"built_in\">size</span>() &amp;&amp; s[i] != <span class=\"string\">&#x27; &#x27;</span>) &#123; <span class=\"comment\">//补上该单词，遇到空格说明单词结束。</span></span><br><span class=\"line\">                    s[slow++] = s[i++];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        s.<span class=\"built_in\">resize</span>(slow); <span class=\"comment\">//slow的大小即为去除多余空格后的大小。</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">reverseWords</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">removeExtraSpaces</span>(s); <span class=\"comment\">//去除多余空格，保证单词之间之只有一个空格，且字符串首尾没空格。</span></span><br><span class=\"line\">        <span class=\"built_in\">reverse</span>(s, <span class=\"number\">0</span>, s.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> start = <span class=\"number\">0</span>; <span class=\"comment\">//removeExtraSpaces后保证第一个单词的开始下标一定是0。</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= s.<span class=\"built_in\">size</span>(); ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i == s.<span class=\"built_in\">size</span>() || s[i] == <span class=\"string\">&#x27; &#x27;</span>) &#123; <span class=\"comment\">//到达空格或者串尾，说明一个单词结束。进行翻转。</span></span><br><span class=\"line\">                <span class=\"built_in\">reverse</span>(s, start, i - <span class=\"number\">1</span>); <span class=\"comment\">//翻转，注意是左闭右闭 []的翻转。</span></span><br><span class=\"line\">                start = i + <span class=\"number\">1</span>; <span class=\"comment\">//更新下一个单词的开始下标start</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["字符串","双指针"]},{"title":"1605. 给定行和列的和求可行矩阵","url":"/posts/ced0bc4d/","content":"<h1 id=\"leetcode-1605.-给定行和列的和求可行矩阵\"><a\r\nhref=\"https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/description/\">leetcode-1605.\r\n给定行和列的和求可行矩阵</a></h1>\r\n<p>一直贪心就行了，自由度很高。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">restoreMatrix</span>(vector&lt;<span class=\"type\">int</span>&gt;&amp; rowSum, vector&lt;<span class=\"type\">int</span>&gt;&amp; colSum) &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = rowSum.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span> n = colSum.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; result = <span class=\"built_in\">vector</span>(m, <span class=\"built_in\">vector</span>(n, <span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; m &amp;&amp; j &lt; n)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> v = <span class=\"built_in\">min</span>(rowSum[i], colSum[j]);</span><br><span class=\"line\">            result[i][j] = v;</span><br><span class=\"line\">            rowSum[i] -= v;</span><br><span class=\"line\">            colSum[j] -= v;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (rowSum[i] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                ++i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (colSum[j] == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                ++j;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["贪心","矩阵"]},{"title":"160. 相交链表","url":"/posts/f6a6c904/","content":"<h1 id=\"leetcode-160.-相交链表\"><a\r\nhref=\"https://leetcode.cn/problems/intersection-of-two-linked-lists/\">leetcode-160.\r\n相交链表</a></h1>\r\n<p>由于链表的特殊性质，一旦多条链表在一个节点相交，那么后面所有的节点都是重合的。所以，链表相交一定发生在链表的尾部。</p>\r\n<p>解决方案是，把两条链表尾部对齐，使两指针一起移动，如果发现地址相同，说明链表已经相交。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode *<span class=\"title\">getIntersectionNode</span><span class=\"params\">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* curA = headA;</span><br><span class=\"line\">        ListNode* curB = headB;</span><br><span class=\"line\">        <span class=\"type\">int</span> lenA = <span class=\"number\">0</span>, lenB = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (curA != <span class=\"literal\">NULL</span>) &#123; <span class=\"comment\">// 求链表A的长度</span></span><br><span class=\"line\">            lenA++;</span><br><span class=\"line\">            curA = curA-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (curB != <span class=\"literal\">NULL</span>) &#123; <span class=\"comment\">// 求链表B的长度</span></span><br><span class=\"line\">            lenB++;</span><br><span class=\"line\">            curB = curB-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        curA = headA;</span><br><span class=\"line\">        curB = headB;</span><br><span class=\"line\">        <span class=\"comment\">// 让curA为最长链表的头，lenA为其长度</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lenB &gt; lenA) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span> (lenA, lenB);</span><br><span class=\"line\">            <span class=\"built_in\">swap</span> (curA, curB);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 求长度差</span></span><br><span class=\"line\">        <span class=\"type\">int</span> gap = lenA - lenB;</span><br><span class=\"line\">        <span class=\"comment\">// 让curA和curB在同一起点上（末尾位置对齐）</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (gap--) &#123;</span><br><span class=\"line\">            curA = curA-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 遍历curA 和 curB，遇到相同则直接返回</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (curA != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (curA == curB) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> curA;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            curA = curA-&gt;next;</span><br><span class=\"line\">            curB = curB-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["双指针","链表"]},{"title":"1823. 找出游戏的获胜者","url":"/posts/3885fad4/","content":"<h1 id=\"leetcode-1823.-找出游戏的获胜者\"><a\r\nhref=\"https://leetcode.cn/problems/find-the-winner-of-the-circular-game/\">leetcode-1823.\r\n找出游戏的获胜者</a></h1>\r\n<p>首先我们定义 <span class=\"math inline\">\\(f(n,m)\\)</span> 表示 <span\r\nclass=\"math inline\">\\(n\\)</span> 个人中，每数到 <span\r\nclass=\"math inline\">\\(m\\)</span>\r\n就淘汰一个人，最后剩下的那个人的编号。</p>\r\n<p>当只有一个人的时候，那么他一定是最后留下的，即 <span\r\nclass=\"math inline\">\\(f(1,m)=0\\)</span>。</p>\r\n<p>当有两个人的时候，那么第一个人被淘汰之后，剩下的那个人就是最后留下的，即\r\n<span class=\"math inline\">\\(f(2,m)=(f(1,m)+m)\\bmod 2\\)</span>。</p>\r\n<p>当有 <span class=\"math inline\">\\(n\\)</span>\r\n个人的时候，我们假设最后留下的那个人的初始编号为 <span\r\nclass=\"math inline\">\\(k\\)</span>，那么第一轮淘汰之后，第 <span\r\nclass=\"math inline\">\\(m\\)</span> 个人就会被淘汰，剩下的 <span\r\nclass=\"math inline\">\\(n-1\\)</span>\r\n个人构成了一个新的数列，而且初始编号从 <span\r\nclass=\"math inline\">\\(k+1\\)</span> 开始，即成为了一个以 <span\r\nclass=\"math inline\">\\(k+1\\)</span> 为起点的编号从 <span\r\nclass=\"math inline\">\\(0\\)</span>\r\n开始的数列。根据归纳假设，这个数列中最后剩下的那个人的编号是 <span\r\nclass=\"math inline\">\\(f(n-1,m)\\)</span>。由于第一个淘汰的人的编号是\r\n<span class=\"math inline\">\\((k+m-1)\\bmod n\\)</span>，所以相对于初始编号\r\n<span class=\"math inline\">\\(k+1\\)</span>，他的编号是 <span\r\nclass=\"math inline\">\\(((k+m-1)\\bmod\r\nn)-1\\)</span>。而因为他被淘汰了，所以剩下的编号从 <span\r\nclass=\"math inline\">\\((k+m)\\bmod n\\)</span>\r\n开始。于是我们可以得到下面的递推式：</p>\r\n<p><span class=\"math display\">\\[\r\nf(n,m)=(f(n−1,m)+m)modn\r\n\\]</span></p>\r\n<p>最终的答案即为 <span class=\"math inline\">\\(f(n,m)\\)</span>。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">findTheWinner</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> p = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">2</span>; i&lt;= n; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            p = (p + k) % i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> p+<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["数学","约瑟夫环"]},{"title":"1615. 最大网络秩","url":"/posts/c959ad7e/","content":"<h1 id=\"leetcode-1615.-最大网络秩\"><a\r\nhref=\"https://leetcode.cn/problems/maximal-network-rank/description/\">leetcode-1615.\r\n最大网络秩</a></h1>\r\n<p>使用了枚举的办法，时间复杂度<span\r\nclass=\"math inline\">\\(O(n^2)\\)</span>。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maximalNetworkRank</span><span class=\"params\">(<span class=\"type\">int</span> n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; roads)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; rd = <span class=\"built_in\">vector</span>(n,<span class=\"built_in\">vector</span>(n,<span class=\"number\">0</span>));</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; roadNum = <span class=\"built_in\">vector</span>(n,<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(vector&lt;<span class=\"type\">int</span>&gt; road : roads)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            rd[<span class=\"built_in\">min</span>(road[<span class=\"number\">0</span>],road[<span class=\"number\">1</span>])][<span class=\"built_in\">max</span>(road[<span class=\"number\">0</span>],road[<span class=\"number\">1</span>])] = <span class=\"number\">1</span>;</span><br><span class=\"line\">            roadNum[road[<span class=\"number\">0</span>]]++;</span><br><span class=\"line\">            roadNum[road[<span class=\"number\">1</span>]]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> maxrank = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) </span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i + <span class=\"number\">1</span>; j &lt; n; j++) &#123;</span><br><span class=\"line\">                <span class=\"type\">int</span> rank =  roadNum[i] + roadNum[j] - rd[i][j];</span><br><span class=\"line\">                maxrank = <span class=\"built_in\">max</span>(maxrank,rank);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxrank;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<p>也可以用贪心的办法解决，官方题解代码如下：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maximalNetworkRank</span><span class=\"params\">(<span class=\"type\">int</span> n, vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt;&amp; roads)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">bool</span>&gt;&gt; <span class=\"built_in\">connect</span>(n, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">bool</span>&gt;(n, <span class=\"literal\">false</span>));</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">degree</span><span class=\"params\">(n)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> road : roads) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> x = road[<span class=\"number\">0</span>], y = road[<span class=\"number\">1</span>];</span><br><span class=\"line\">            connect[x][y] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            connect[y][x] = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            degree[x]++;</span><br><span class=\"line\">            degree[y]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"type\">int</span> first = <span class=\"number\">-1</span>, second = <span class=\"number\">-2</span>;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; firstArr, secondArr;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (degree[i] &gt; first) &#123;</span><br><span class=\"line\">                second = first;</span><br><span class=\"line\">                secondArr = firstArr;</span><br><span class=\"line\">                first = degree[i];</span><br><span class=\"line\">                firstArr.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">                firstArr.<span class=\"built_in\">emplace_back</span>(i);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (degree[i] == first) &#123;</span><br><span class=\"line\">                firstArr.<span class=\"built_in\">emplace_back</span>(i);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (degree[i] &gt; second)&#123;</span><br><span class=\"line\">                secondArr.<span class=\"built_in\">clear</span>();</span><br><span class=\"line\">                second = degree[i];</span><br><span class=\"line\">                secondArr.<span class=\"built_in\">emplace_back</span>(i);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (degree[i] == second) &#123;</span><br><span class=\"line\">                secondArr.<span class=\"built_in\">emplace_back</span>(i);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (firstArr.<span class=\"built_in\">size</span>() == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> u = firstArr[<span class=\"number\">0</span>];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> v : secondArr) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!connect[u][v]) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> first + second;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first + second - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> m = roads.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (firstArr.<span class=\"built_in\">size</span>() * (firstArr.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>) / <span class=\"number\">2</span> &gt; m) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> first * <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> u: firstArr) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"type\">int</span> v: firstArr) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (u != v &amp;&amp; !connect[u][v]) &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> first * <span class=\"number\">2</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> first * <span class=\"number\">2</span> - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>时间复杂度为<span class=\"math inline\">\\(O(m+n)\\)</span>。</p>\r\n","categories":["算法笔记"],"tags":["贪心","图","枚举"]},{"title":"202. 快乐数","url":"/posts/827e2fc4/","content":"<h1 id=\"leetcode-202.-快乐数\"><a\r\nhref=\"https://leetcode.cn/problems/happy-number/\">leetcode-202.\r\n快乐数</a></h1>\r\n<p>定义一个函数计算数位平方和，把每次的和记录在一个哈希表中，每计算一次检验一次，如果出现重复的元素，说明无限循环了。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getSum</span><span class=\"params\">(<span class=\"type\">int</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(num &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sum += ((num % <span class=\"number\">10</span>) * (num % <span class=\"number\">10</span>));</span><br><span class=\"line\">            num /= <span class=\"number\">10</span>;   </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isHappy</span><span class=\"params\">(<span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        unordered_set&lt;<span class=\"type\">int</span>&gt; nums;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (nums.<span class=\"built_in\">find</span>(n) == nums.<span class=\"built_in\">end</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            nums.<span class=\"built_in\">insert</span>(n);</span><br><span class=\"line\">            n = <span class=\"built_in\">getSum</span>(n);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(n == <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["哈希"]},{"title":"19. 删除链表的倒数第 N 个结点","url":"/posts/e3fcab93/","content":"<h1 id=\"leetcode-19.-删除链表的倒数第-n-个结点\"><a\r\nhref=\"https://leetcode.cn/problems/remove-nth-node-from-end-of-list/\">leetcode-19.\r\n删除链表的倒数第 N 个结点</a></h1>\r\n<p>熟悉的双指针，让fastIndex先前进n步，再让两个指针一起前进，直到fastIndex到达最后一个元素。此时，slowIndex所在的位置即为要删除节点的前一个元素，方便删除操作。</p>\r\n<p>本题稍微卡壳的地方在于，要删除的节点是第一个节点的问题，是没法找到要删除的节点的前一个节点的。但是在引入虚拟头节点dummyHead后，问题就解决了。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeNthFromEnd</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* dummyHead = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        dummyHead-&gt;next = head;</span><br><span class=\"line\">        ListNode* slowIndex = dummyHead;</span><br><span class=\"line\">        ListNode* fastIndex = dummyHead;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fastIndex = fastIndex-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fastIndex-&gt;next != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fastIndex = fastIndex-&gt;next;</span><br><span class=\"line\">            slowIndex = slowIndex-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        ListNode* temp = slowIndex-&gt;next;</span><br><span class=\"line\">        slowIndex-&gt;next = temp-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> temp; </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> dummyHead-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["双指针","链表"]},{"title":"209. 长度最小的子数组","url":"/posts/5b0e75a/","content":"<h1 id=\"leetcode-209.-长度最小的子数组\"><a\r\nhref=\"https://leetcode.cn/problems/minimum-size-subarray-sum/description/\">leetcode-209.\r\n长度最小的子数组</a></h1>\r\n<p>如果使用暴力解法，需要用两个for循环嵌套，时间复杂度很明显是O(n^2)。</p>\r\n<p>巧妙的方法是使用滑动窗口的方法，类似计算机网络中的内容，窗口由一前一后两个指针约束。窗口的前指针在循环中不停地前进，寻找最优解。当窗口中的内容不符合最优解的时候，移动后指针直到重新符合条件，再进入循环。</p>\r\n<p>这样做的好处是，通过操作两个指针，只进行了一次循环，时间复杂度降低为O(n).\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//经验不足导致的代码又臭又长</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minSubArrayLen</span><span class=\"params\">(<span class=\"type\">int</span> target, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = nums[<span class=\"number\">0</span>], fastIndex = <span class=\"number\">0</span>, slowIndex = <span class=\"number\">0</span>, length = <span class=\"number\">1</span>, minLength = nums.<span class=\"built_in\">size</span>() + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum &gt;= target)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fastIndex &lt; nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">        fastIndex++;</span><br><span class=\"line\">        length++;</span><br><span class=\"line\">        sum += nums[fastIndex];</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sum - nums[slowIndex] &gt;= target)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sum -= nums[slowIndex];</span><br><span class=\"line\">            slowIndex++;</span><br><span class=\"line\">            length --;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sum &gt;= target)</span><br><span class=\"line\">        minLength = (length &lt; minLength)? length : minLength;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(minLength == nums.<span class=\"built_in\">size</span>() + <span class=\"number\">1</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> minLength;  </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n","categories":["算法笔记"],"tags":["滑动窗口","数组"]},{"title":"203. 移除链表元素","url":"/posts/9a8d3ba6/","content":"<h1 id=\"leetcode-203.-移除链表元素\"><a\r\nhref=\"https://leetcode.cn/problems/remove-linked-list-elements/\">leetcode-203.\r\n移除链表元素</a></h1>\r\n<p>链表的种种性质操作早已熟记于心，但是上手写代码的时候还是有种种困难。\r\n话不多说，直接上代码： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">removeElements</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* dummyHead = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">0</span>,head);  <span class=\"comment\">//创建虚拟头结点，后面操作可以统一</span></span><br><span class=\"line\">        ListNode* cur = dummyHead; <span class=\"comment\">//创建用来遍历的节点，cur=current</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur-&gt;next != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(cur-&gt;next-&gt;val == val)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                ListNode* temp = cur-&gt;next;</span><br><span class=\"line\">                cur-&gt;next = cur-&gt;next-&gt;next; <span class=\"comment\">//删除操作，反而是最简单的一步</span></span><br><span class=\"line\">                <span class=\"keyword\">delete</span> temp; <span class=\"comment\">//C++一定要释放空间</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                cur = cur-&gt;next; <span class=\"comment\">//不是要删除的节点，就跳过</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        head = dummyHead-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> dummyHead;<span class=\"comment\">//释放空间</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n","categories":["算法笔记"],"tags":["链表"]},{"title":"2211. 统计道路上的碰撞次数","url":"/posts/b47441a5/","content":"<h1 id=\"leetcode-2211.-统计道路上的碰撞次数\"><a\r\nhref=\"https://leetcode.cn/problems/count-collisions-on-a-road/\">leetcode-2211.\r\n统计道路上的碰撞次数</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">countCollisions</span><span class=\"params\">(string directions)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> result =  directions.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = directions.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(directions[i] == <span class=\"string\">&#x27;R&#x27;</span>)</span><br><span class=\"line\">            result--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; directions.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(directions[i] == <span class=\"string\">&#x27;L&#x27;</span>)</span><br><span class=\"line\">            result--;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">char</span> ch : directions)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ch == <span class=\"string\">&#x27;S&#x27;</span>)</span><br><span class=\"line\">            result--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>一开始的思路是，搞一个栈，暂时不相撞的车先存在栈里面。遇到相撞的情况，就把要撞的车从里面弹出来。</p>\r\n<p>后来发现，要讨论的相撞的情况太多了。</p>\r\n<p>那么可以逆向思维，不相撞的情况有哪些？仔细思考后发现，其实只有第二个示例中的两种情况：</p>\r\n<ol type=\"1\">\r\n<li>最左面有向左的车</li>\r\n<li>最右面有向右的车</li>\r\n</ol>\r\n<p>确定了相撞的情况，但是这还不是最终想求的答案。</p>\r\n<p>有停止的车参与的相撞，只算一次，所以应该额外计算S的数量。</p>\r\n","categories":["算法笔记"],"tags":["脑筋急转弯"]},{"title":"2383. 赢得比赛需要的最少训练时长","url":"/posts/b7b4f2bb/","content":"<h1 id=\"leetcode-2383.-赢得比赛需要的最少训练时长\"><a\r\nhref=\"https://leetcode.cn/problems/minimum-hours-of-training-to-win-a-competition/description/\">leetcode-2383.\r\n赢得比赛需要的最少训练时长</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minNumberOfHours</span><span class=\"params\">(<span class=\"type\">int</span> initialEnergy, <span class=\"type\">int</span> initialExperience, vector&lt;<span class=\"type\">int</span>&gt;&amp; energy, vector&lt;<span class=\"type\">int</span>&gt;&amp; experience)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sumExperience = initialExperience;</span><br><span class=\"line\">        <span class=\"type\">int</span> sumEnergy = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> num : experience)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(sumExperience &lt;= num)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result += (num + <span class=\"number\">1</span> -sumExperience);</span><br><span class=\"line\">                sumExperience = num + <span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            sumExperience += num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> num : energy)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sumEnergy += num;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(sumEnergy &gt;= initialEnergy)</span><br><span class=\"line\">        result += (sumEnergy + <span class=\"number\">1</span> - initialEnergy);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["贪心"]},{"title":"206. 反转链表","url":"/posts/7787fb56/","content":"<h1 id=\"leetcode-206.-反转链表\"><a\r\nhref=\"https://leetcode.cn/problems/reverse-linked-list/\">leetcode-206.\r\n反转链表</a></h1>\r\n<p>灵活运用了双指针，一快一慢两个指针</p>\r\n<p><img\r\nsrc=\"https://picx.zhimg.com/80/v2-1032cc15783f29d404801aaad96a0e4e_720w.webp?source=d16d100b\"\r\nalt=\"翻转链表\" /> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseList</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* pre = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        ListNode* cur = head;</span><br><span class=\"line\">        ListNode* temp; <span class=\"comment\">//用临时节点储存cur的下个节点。</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            temp = cur-&gt;next;</span><br><span class=\"line\">            cur-&gt;next = pre;</span><br><span class=\"line\">            pre = cur;</span><br><span class=\"line\">            cur = temp;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pre;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n","categories":["算法笔记"],"tags":["双指针","链表"]},{"title":"2389. 和有限的最长子序列","url":"/posts/920f27cb/","content":"<h1 id=\"leetcode-2389.-和有限的最长子序列\"><a\r\nhref=\"https://leetcode.cn/problems/longest-subsequence-with-limited-sum/\">leetcode-2389.\r\n和有限的最长子序列</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">answerQueries</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, vector&lt;<span class=\"type\">int</span>&gt;&amp; queries)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>(), m = queries.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        <span class=\"built_in\">sort</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">f</span><span class=\"params\">(n + <span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">            f[i + <span class=\"number\">1</span>] = f[i] + nums[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">answer</span><span class=\"params\">(m)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; i++) &#123;</span><br><span class=\"line\">            answer[i] = <span class=\"built_in\">upper_bound</span>(f.<span class=\"built_in\">begin</span>(), f.<span class=\"built_in\">end</span>(), queries[i]) - f.<span class=\"built_in\">begin</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> answer;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["贪心","数组","前缀和","排序"]},{"title":"225. 用队列实现栈&&232. 用栈实现队列","url":"/posts/75057265/","content":"<h1 id=\"leetcode-225.-用队列实现栈\"><a\r\nhref=\"https://leetcode.cn/problems/implement-stack-using-queues/\">leetcode-225.\r\n用队列实现栈</a></h1>\r\n<p>用队列实现栈，就要在出队的时候，把所有元素全部出队，前n-1个元素重新入队</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyStack</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    queue&lt;<span class=\"type\">int</span>&gt; que;</span><br><span class=\"line\">    <span class=\"comment\">/** Initialize your data structure here. */</span></span><br><span class=\"line\">    <span class=\"built_in\">MyStack</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/** Push element x onto stack. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        que.<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> size = que.<span class=\"built_in\">size</span>();</span><br><span class=\"line\">        size--;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (size--) &#123; <span class=\"comment\">// 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部</span></span><br><span class=\"line\">            que.<span class=\"built_in\">push</span>(que.<span class=\"built_in\">front</span>());</span><br><span class=\"line\">            que.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> result = que.<span class=\"built_in\">front</span>(); <span class=\"comment\">// 此时弹出的元素顺序就是栈的顺序了</span></span><br><span class=\"line\">        que.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Get the top element. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">top</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> que.<span class=\"built_in\">back</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Returns whether the stack is empty. */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> que.<span class=\"built_in\">empty</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<h1 id=\"leetcode-232.-用栈实现队列\"><a\r\nhref=\"https://leetcode.cn/problems/implement-stack-using-queues/\">leetcode-232.\r\n用栈实现队列</a></h1>\r\n<p>用栈实现队列，则需要两个栈，一个输入栈，一个输出栈，出栈的时候，如果输出栈为空，就从把输入栈全部出栈并且入输出栈。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyQueue</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; stIn;</span><br><span class=\"line\">    stack&lt;<span class=\"type\">int</span>&gt; stOut;</span><br><span class=\"line\">    <span class=\"built_in\">MyQueue</span>() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">push</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">        stIn.<span class=\"built_in\">push</span>(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">pop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(stOut.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (!stIn.<span class=\"built_in\">empty</span>())</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                stOut.<span class=\"built_in\">push</span>(stIn.<span class=\"built_in\">top</span>());</span><br><span class=\"line\">                stIn.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">            &#125;          </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"type\">int</span> result = stOut.<span class=\"built_in\">top</span>();</span><br><span class=\"line\">        stOut.<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">peek</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> res = <span class=\"keyword\">this</span>-&gt;<span class=\"built_in\">pop</span>();</span><br><span class=\"line\">        stOut.<span class=\"built_in\">push</span>(res);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">empty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> stIn.<span class=\"built_in\">empty</span>() &amp;&amp; stOut.<span class=\"built_in\">empty</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["栈","队列"]},{"title":"239. 滑动窗口最大值","url":"/posts/58d1758d/","content":"<h1 id=\"leetcode-239.-滑动窗口最大值\"><a\r\nhref=\"https://leetcode.cn/problems/sliding-window-maximum/description/\">leetcode-239.\r\n滑动窗口最大值</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">maxSlidingWindow</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        deque&lt;<span class=\"type\">int</span>&gt; maxNum;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; result;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; nums.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt;= k &amp;&amp; nums[i-k] == maxNum.<span class=\"built_in\">front</span>())</span><br><span class=\"line\">            maxNum.<span class=\"built_in\">pop_front</span>();</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(maxNum.<span class=\"built_in\">size</span>() == <span class=\"number\">0</span>)</span><br><span class=\"line\">            maxNum.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(!maxNum.<span class=\"built_in\">empty</span>() &amp;&amp;nums[i] &gt; maxNum.<span class=\"built_in\">back</span>())</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    maxNum.<span class=\"built_in\">pop_back</span>();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                maxNum.<span class=\"built_in\">push_back</span>(nums[i]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &gt;= k - <span class=\"number\">1</span>)</span><br><span class=\"line\">            result.<span class=\"built_in\">push_back</span>(maxNum.<span class=\"built_in\">front</span>());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>定义一个双向队列maxNum,用来储存所有可能成为滑动窗口内最大值的数。</p>\r\n<p>一个数如果比另一个数“老”，而且不比这个数大，那么这个数绝无在后面的移动中成为最大值的可能。</p>\r\n<p>那么我们定义的队列，一定是一个从老到新，从大到小排列的队列（因为新入队的大数会把老的小数全部淘汰）。最大值一定在队列的头。进一步可以推理出出队和入队的操作：</p>\r\n<ul>\r\n<li>出队：如果这个数还在队列中（没被淘汰），那么就把它出队。</li>\r\n<li>入队：入队的同时，淘汰所有的比它更小的数。</li>\r\n</ul>\r\n<p>所以只需要维护这个队列，即可得到答案。</p>\r\n<p>时间复杂度为<span\r\nclass=\"math inline\">\\(O(n)\\)</span>,空间复杂度为<span\r\nclass=\"math inline\">\\(O(k)\\)</span>。</p>\r\n","categories":["算法笔记"],"tags":["栈","队列","滑动窗口","困难题"]},{"title":"2488. 统计中位数为 K 的子数组","url":"/posts/7911e61f/","content":"<h1 id=\"leetcode-2488.-统计中位数为-k-的子数组\"><a\r\nhref=\"https://leetcode.cn/problems/count-subarrays-with-median-k/\">leetcode-2488.\r\n统计中位数为 K 的子数组</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">countSubarrays</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; sign = <span class=\"built_in\">vector</span>(nums.<span class=\"built_in\">size</span>() + <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; sum;</span><br><span class=\"line\">        <span class=\"type\">bool</span> isK = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        sum[<span class=\"number\">0</span>]++;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= nums.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[i - <span class=\"number\">1</span>] &gt; k)</span><br><span class=\"line\">            sign[i] = sign[i - <span class=\"number\">1</span>] + <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(nums[i - <span class=\"number\">1</span>] &lt; k)</span><br><span class=\"line\">            sign[i] = sign[i - <span class=\"number\">1</span>] + <span class=\"number\">-1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                sign[i] = sign[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">                isK = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(isK)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result += sum[sign[i]];</span><br><span class=\"line\">                result += sum[sign[i] - <span class=\"number\">1</span>];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            sum[sign[i]]++;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">//cout &lt;&lt; sign[i] &lt;&lt; endl;</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>要使子数组的中位数为k，那么必须符合下列两个条件之一：</p>\r\n<ul>\r\n<li>比k大的数和比k小的数，数量一样多。</li>\r\n<li>比k大的数比比k小的数多一个。</li>\r\n</ul>\r\n<p>那么把数组作如下处理，比k大的数，标注为1；比k小的数，标注为-1；k标记为0。</p>\r\n<p>然后计算前缀和，可以把前缀和认为的“高度”，数组的标记（-1、0、1）是“坡度”。符合条件的子数组，数组的头和数组的尾，“高度”和前面的两个条件对应，只有两种情况：</p>\r\n<ul>\r\n<li>头尾高度相等。</li>\r\n<li>尾的高度比头高1。</li>\r\n</ul>\r\n<p>头的索引必然小于等于k的索引，尾的索引必然大于等于k的索引（因为子数组必然包含k）。</p>\r\n<p>把可能的头的“高度”记录在一个哈希表中，每有一个尾，只要找到可能的头，结果就加一。</p>\r\n<p>时间复杂度<span class=\"math inline\">\\(O(n)\\)</span>。</p>\r\n<p>空间复杂度<span class=\"math inline\">\\(O(n)\\)</span>。</p>\r\n","categories":["算法笔记"],"tags":["哈希表","数组","前缀和","困难题"]},{"title":"24. 两两交换链表中的节点","url":"/posts/ea8dbaa4/","content":"<h1 id=\"leetcode-24.-两两交换链表中的节点\"><a\r\nhref=\"https://leetcode.cn/problems/swap-nodes-in-pairs/\">leetcode-24.\r\n两两交换链表中的节点</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">swapPairs</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        ListNode* temp = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>();</span><br><span class=\"line\">        temp-&gt;next = head;</span><br><span class=\"line\">        ListNode* m = head;</span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(m != <span class=\"literal\">nullptr</span> &amp;&amp; m-&gt;next != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            ListNode* n = m-&gt;next;</span><br><span class=\"line\">            m-&gt;next = n-&gt;next;</span><br><span class=\"line\">            n-&gt;next = m;</span><br><span class=\"line\">            temp-&gt;next = n;</span><br><span class=\"line\">            temp = m;</span><br><span class=\"line\">            m = m-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                head = n;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            i++; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>额外添加头结点的作用一般有两个：</p>\r\n<ol type=\"1\">\r\n<li>处理链表开头的元素时更方便，避免分类讨论。</li>\r\n<li>方便返回结果。</li>\r\n</ol>\r\n<p>但是这道题有所不同，因为第一个节点和第二个节点已经交换过了，头结点temp处理过后接在第二个节点前面，返回temp-&gt;next是错误的。</p>\r\n<p>而且temp没有任何通往第一个节点的路径，唯一的办法是第一次交换时，用head记录交换后的第一个节点。</p>\r\n","categories":["算法笔记"],"tags":["双指针","链表"]},{"title":"2673. 使二叉树所有路径值相等的最小代价","url":"/posts/66f4d719/","content":"<h1 id=\"leetcode-2673.-使二叉树所有路径值相等的最小代价\"><a\r\nhref=\"https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/\">leetcode-2673.\r\n使二叉树所有路径值相等的最小代价</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minIncrements</span><span class=\"params\">(<span class=\"type\">int</span> n, vector&lt;<span class=\"type\">int</span>&gt; &amp;cost)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> ans = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = n / <span class=\"number\">2</span>; i; i--) &#123; <span class=\"comment\">// 从最后一个非叶节点开始算</span></span><br><span class=\"line\">            ans += <span class=\"built_in\">abs</span>(cost[i * <span class=\"number\">2</span> - <span class=\"number\">1</span>] - cost[i * <span class=\"number\">2</span>]); <span class=\"comment\">// 两个子节点变成一样的</span></span><br><span class=\"line\">            cost[i - <span class=\"number\">1</span>] += <span class=\"built_in\">max</span>(cost[i * <span class=\"number\">2</span> - <span class=\"number\">1</span>], cost[i * <span class=\"number\">2</span>]); <span class=\"comment\">// 累加路径和</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>这道题是第一次参加周赛的最后一题，因为时间限制没时间实现。</p>\r\n<p>事后复盘发现了问题，想得还是太复杂，虽然已经明白了路径形成的过程，通过模拟也能得到正确结果。</p>\r\n<p>但是显然只需要计算两个子节点的最大值即可</p>\r\n<p>代码来自灵神。</p>\r\n","categories":["算法笔记"],"tags":["树","二叉树","leetcode周赛"]},{"title":"28. 找出字符串中第一个匹配项的下标","url":"/posts/9d746551/","content":"<h1 id=\"leetcode-28.-找出字符串中第一个匹配项的下标\"><a\r\nhref=\"https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/\">leetcode-28.\r\n找出字符串中第一个匹配项的下标</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">getNext</span><span class=\"params\">(<span class=\"type\">const</span> string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">next</span><span class=\"params\">(s.size())</span></span>;</span><br><span class=\"line\">        next[<span class=\"number\">0</span>] = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">-1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; s.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || s[j] == s[i]) &#123;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                next[i] = j;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                j = next[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">strStr</span><span class=\"params\">(string haystack, string needle)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; next = <span class=\"built_in\">getNext</span>(needle);</span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i &lt; haystack.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (j == <span class=\"number\">-1</span> || haystack[i] == needle[j]) &#123;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">                j++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (j == needle.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> i - j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                j = next[j];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>这段代码实现了经典的字符串匹配算法 KMP。KMP\r\n算法的核心是利用已经匹配的信息来避免重复匹配，从而提高匹配效率。</p>\r\n<p>首先，我们来看 getNext 函数。该函数用于计算 needle\r\n字符串的前缀表（prefix table），也称为失配函数（failure\r\nfunction）。前缀表是一个数组，其中第 i 个元素表示 needle 字符串中以第 i\r\n个字符结尾的子串的最长前缀和最长后缀相等的长度。</p>\r\n<p>具体来说，我们定义两个指针 i 和 j，其中 i 表示当前子串的结尾位置，j\r\n表示当前子串的最长前缀和最长后缀相等的长度。初始化时，i 和 j\r\n都指向字符串的开头，前缀表的第一个元素设为 -1。</p>\r\n<p>接下来，我们在一个循环中不断计算前缀表中的元素。每次循环，我们比较\r\ns[i] 和 s[j] 是否相等，如果相等，说明可以将 j 增加\r\n1，同时将前缀表中下一个元素设为 j。如果不相等，我们需要将 j\r\n回溯到前缀表中 j 对应的值，这是因为我们已经知道前面的 j\r\n个字符是匹配的，所以可以直接跳过这些字符，从前面已经匹配的位置重新开始匹配。这个过程可以用递推式\r\nj = next[j] 来描述。</p>\r\n<p>最后，我们返回前缀表。</p>\r\n<p>我们来看 strStr 函数。该函数用于在 haystack 字符串中查找 needle\r\n字符串的第一个匹配项。首先，我们调用 getNext 函数计算出 needle\r\n字符串的前缀表。然后，我们定义两个指针 i 和 j，其中 i 表示当前在\r\nhaystack 中匹配的位置，j 表示当前在 needle 中匹配的位置。初始化时，i 和\r\nj 都指向字符串的开头。</p>\r\n<p>我们在一个循环中不断尝试匹配 haystack 和 needle\r\n中的字符。如果当前字符匹配成功，我们将 i 和 j\r\n同时向后移动一个位置，继续匹配下一个字符。如果 j 到达了 needle\r\n的末尾，说明已经找到了匹配项，我们可以返回 i -\r\nj。如果当前字符匹配失败，我们需要将 j 回溯到前缀表中 j\r\n对应的值，重新开始匹配。这个过程可以用递推式 <code>j = next[j]</code>\r\n来描述。如果 j 已经回溯到了 -1，说明在当前位置找不到匹配项，需要将 i\r\n向后移动一个位置，重新开始匹配。</p>\r\n<p>最后，如果循环结束还没有找到匹配项，说明在 haystack 中找不到\r\nneedle，需要返回 -1。</p>\r\n<p>总体来说，这段代码的时间复杂度为 <span\r\nclass=\"math inline\">\\(O(m+n)\\)</span>，其中 <span\r\nclass=\"math inline\">\\(m\\)</span> 和 <span\r\nclass=\"math inline\">\\(n\\)</span> 分别是 haystack 和 needle\r\n的长度。这是因为在计算前缀表和匹配字符串时，指针 i 和 j 各自最多向前移动\r\n<span class=\"math inline\">\\(m\\)</span> 和 <span\r\nclass=\"math inline\">\\(n\\)</span> 次。空间复杂度为 <span\r\nclass=\"math inline\">\\(O(n)\\)</span>，其中 <span\r\nclass=\"math inline\">\\(n\\)</span> 是 needle\r\n的长度，这是因为前缀表需要保存 needle\r\n中每个位置的最长前缀和最长后缀相等的长度。</p>\r\n<p>总之，这段代码非常经典和实用，可以在很多场景下使用，比如搜索引擎中的字符串匹配、文本编辑器中的搜索功能等等。</p>\r\n","categories":["算法笔记"],"tags":["字符串","KMP算法"]},{"title":"2418. 按身高排序","url":"/posts/993fa6d1/","content":"<h1 id=\"leetcode-2418.-按身高排序\"><a\r\nhref=\"https://leetcode.cn/problems/sort-the-people/\">leetcode-2418.\r\n按身高排序</a></h1>\r\n<p>这道题很简单，但是解法有趣：</p>\r\n<ul>\r\n<li>首先把这些内容装进一个map（底层由红黑树构成）中</li>\r\n<li>再按键的顺序遍历map</li>\r\n<li>最后翻转，得到想要的答案。</li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;string&gt; <span class=\"title\">sortPeople</span><span class=\"params\">(vector&lt;string&gt;&amp; names, vector&lt;<span class=\"type\">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class=\"line\">        map&lt;<span class=\"type\">int</span>, string&gt; hash;</span><br><span class=\"line\">        vector&lt;string&gt; ans;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; names.<span class=\"built_in\">size</span>(); ++i) hash[heights[i]] = names[i];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> &amp;i : hash) ans.<span class=\"built_in\">push_back</span>(i.second);</span><br><span class=\"line\">        <span class=\"built_in\">reverse</span>(ans.<span class=\"built_in\">begin</span>(), ans.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["树","哈希表","排序","红黑树"]},{"title":"3. 无重复字符的最长子串","url":"/posts/4bff4329/","content":"<h1 id=\"leetcode-3.-无重复字符的最长子串\"><a\r\nhref=\"https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/\">leetcode-3.\r\n无重复字符的最长子串</a></h1>\r\n<p>这道题最主要的考察点还是滑动窗口，但是刚刚学习了C++中的哈希表用法，练习一下api调用。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">lengthOfLongestSubstring</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> fastIndex = <span class=\"number\">0</span>, slowIndex = <span class=\"number\">0</span>, size = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> maxSize = <span class=\"number\">0</span>;</span><br><span class=\"line\">        unordered_set&lt;<span class=\"type\">char</span>&gt; words;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fastIndex &lt; s.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(words.<span class=\"built_in\">count</span>(s[fastIndex]) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                words.<span class=\"built_in\">insert</span>(s[fastIndex]);</span><br><span class=\"line\">                fastIndex++;</span><br><span class=\"line\">                size++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(size &gt; maxSize)</span><br><span class=\"line\">                maxSize++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(words.<span class=\"built_in\">count</span>(s[fastIndex]) != <span class=\"number\">0</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    words.<span class=\"built_in\">erase</span>(s[slowIndex]);</span><br><span class=\"line\">                    slowIndex++;</span><br><span class=\"line\">                    size--;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> maxSize;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["哈希","滑动窗口"]},{"title":"450. 删除二叉搜索树中的节点","url":"/posts/12fe8ccd/","content":"<h1 id=\"leetcode-450.-删除二叉搜索树中的节点\"><a\r\nhref=\"https://leetcode.cn/problems/delete-node-in-a-bst/description/\">leetcode-450.\r\n删除二叉搜索树中的节点</a></h1>\r\n<p>有以下五种情况：</p>\r\n<ul>\r\n<li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li>\r\n<li>第二种情况：左右孩子都为空（叶子节点），直接删除节点，\r\n返回NULL为根节点</li>\r\n<li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li>\r\n<li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li>\r\n<li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">TreeNode* <span class=\"title\">deleteNode</span><span class=\"params\">(TreeNode* root, <span class=\"type\">int</span> key)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> root; <span class=\"comment\">// 第一种情况：没找到删除的节点，遍历到空节点直接返回了</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;val == key) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (root-&gt;left == <span class=\"literal\">nullptr</span> &amp;&amp; root-&gt;right == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">///! 内存释放</span></span><br><span class=\"line\">                <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;left == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> retNode = root-&gt;right;</span><br><span class=\"line\">                <span class=\"comment\">///! 内存释放</span></span><br><span class=\"line\">                <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> retNode;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (root-&gt;right == <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">auto</span> retNode = root-&gt;left;</span><br><span class=\"line\">                <span class=\"comment\">///! 内存释放</span></span><br><span class=\"line\">                <span class=\"keyword\">delete</span> root;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> retNode;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span></span><br><span class=\"line\">            <span class=\"comment\">// 并返回删除节点右孩子为新的根节点。</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                TreeNode* cur = root-&gt;right; <span class=\"comment\">// 找右子树最左面的节点</span></span><br><span class=\"line\">                <span class=\"keyword\">while</span>(cur-&gt;left != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">                    cur = cur-&gt;left;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                cur-&gt;left = root-&gt;left; <span class=\"comment\">// 把要删除的节点（root）左子树放在cur的左孩子的位置</span></span><br><span class=\"line\">                TreeNode* tmp = root;   <span class=\"comment\">// 把root节点保存一下，下面来删除</span></span><br><span class=\"line\">                root = root-&gt;right;     <span class=\"comment\">// 返回旧root的右孩子作为新root</span></span><br><span class=\"line\">                <span class=\"keyword\">delete</span> tmp;             <span class=\"comment\">// 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;val &gt; key) root-&gt;left = <span class=\"built_in\">deleteNode</span>(root-&gt;left, key);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (root-&gt;val &lt; key) root-&gt;right = <span class=\"built_in\">deleteNode</span>(root-&gt;right, key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["树","二叉树","递归","二叉搜索树"]},{"title":"25. K 个一组翻转链表","url":"/posts/290cb30/","content":"<h1 id=\"leetcode-25.-k-个一组翻转链表\"><a\r\nhref=\"https://leetcode.cn/problems/reverse-nodes-in-k-group/description/\">leetcode-25.\r\nK 个一组翻转链表</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">reverseKGroup</span><span class=\"params\">(ListNode* head, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(k == <span class=\"number\">1</span>) <span class=\"keyword\">return</span> head; <span class=\"comment\">// 如果k等于1，则直接返回原链表头结点head</span></span><br><span class=\"line\">        ListNode* temp = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(); <span class=\"comment\">// 创建一个临时节点temp</span></span><br><span class=\"line\">        temp-&gt;next = head; <span class=\"comment\">// 将temp的下一个节点指向head，即temp为头节点的前一个节点</span></span><br><span class=\"line\">        <span class=\"type\">int</span> t = <span class=\"number\">0</span>; <span class=\"comment\">// 计数器，用于记录翻转了几组</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;ListNode*&gt; <span class=\"title\">n</span><span class=\"params\">(k+<span class=\"number\">1</span>, temp)</span></span>; <span class=\"comment\">// 创建一个vector，用于存储当前要翻转的k个节点</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(n[<span class=\"number\">0</span>] != <span class=\"literal\">nullptr</span>) <span class=\"comment\">// 当还有剩余节点时循环</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; k; i++) <span class=\"comment\">// 将要翻转的k个节点存入vector</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(n[i]-&gt;next != <span class=\"literal\">nullptr</span>) <span class=\"comment\">// 如果当前节点的下一个节点不为空，则将下一个节点存入vector</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    n[i+<span class=\"number\">1</span>] = n[i]-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> head; <span class=\"comment\">// 如果下一个节点为空，则直接返回原链表头结点head</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(t == <span class=\"number\">0</span>) <span class=\"comment\">// 如果是第一组，则将头结点指向翻转后的第一个节点</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                head = n[k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt; (k/<span class=\"number\">2</span>) + <span class=\"number\">1</span>; i++) <span class=\"comment\">// 将k个节点进行翻转，分别从两端向中间交换</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(i == <span class=\"number\">1</span>) <span class=\"comment\">// 如果是第一个节点，则需要更改其下一个节点和上一个节点的指针</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    n[i<span class=\"number\">-1</span>]-&gt;next = n[k-i+<span class=\"number\">1</span>];</span><br><span class=\"line\">                    n[i]-&gt;next = n[k-i+<span class=\"number\">1</span>]-&gt;next;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"comment\">// 如果不是第一个节点，则需要更改其下一个节点和上一个节点的指针，以及两端节点的指针</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    n[k-i+<span class=\"number\">2</span>]-&gt;next = n[k-i+<span class=\"number\">1</span>];</span><br><span class=\"line\">                    n[i]-&gt;next = n[i<span class=\"number\">-1</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(k%<span class=\"number\">2</span> == <span class=\"number\">0</span> &amp;&amp; i == k/<span class=\"number\">2</span>) <span class=\"comment\">// 如果k是偶数并且当前节点为中间节点，则需要特殊处理其下一个节点的指针</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    n[i+<span class=\"number\">1</span>]-&gt;next=n[i]; </span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">else</span> <span class=\"comment\">// 如果不是中间节点，则需要更改其下一个节点和上一个节点的指针，以及两端节点的指针</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    n[k-i+<span class=\"number\">1</span>]-&gt;next = n[i+<span class=\"number\">1</span>];</span><br><span class=\"line\">                    n[k-i]-&gt;next = n[i];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            n[<span class=\"number\">0</span>] = n[<span class=\"number\">1</span>]; <span class=\"comment\">// 将下一组的第一个节点存入vector[0]，循环使用vector</span></span><br><span class=\"line\">            t++; <span class=\"comment\">// 计数器加1，记录翻转的组数</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> head; <span class=\"comment\">// 返回翻转后的链表头结点head</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>看了一眼别人的题解，好像别人的写的也很长。</p>\r\n","categories":["算法笔记"],"tags":["链表","困难题"]},{"title":"344. 反转字符串","url":"/posts/f8e8b99a/","content":"<h1 id=\"leetcode-344.-反转字符串\"><a\r\nhref=\"https://leetcode.cn/problems/reverse-string/\">leetcode-344.\r\n反转字符串</a></h1>\r\n<p>太简单了，不知道写什么内容，就当熟悉语法了。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reverseString</span><span class=\"params\">(vector&lt;<span class=\"type\">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>()/<span class=\"number\">2</span>; i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(s[i],s[s.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span> - i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["字符串"]},{"title":"454. 四数相加 II","url":"/posts/8ea35345/","content":"<h1 id=\"leetcode-454.-四数相加-ii\"><a\r\nhref=\"https://leetcode.cn/problems/4sum-ii/\">leetcode-454. 四数相加\r\nII</a></h1>\r\n<ul>\r\n<li><p>首先定义 一个unordered_map，key放a和b两数之和，value\r\n放a和b两数之和出现的次数。</p></li>\r\n<li><p>遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。</p></li>\r\n<li><p>定义int变量count，用来统计 a+b+c+d = 0 出现的次数。</p></li>\r\n<li><p>在遍历大C和大D数组，找到如果 0-(c+d)\r\n在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。</p></li>\r\n<li><p>最后返回统计值 count 就可以了</p></li>\r\n</ul>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fourSumCount</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums1, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums2, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums3, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">int</span>,<span class=\"type\">int</span>&gt; umap;</span><br><span class=\"line\">        <span class=\"type\">int</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> a : nums1)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> b : nums2)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                umap[a + b]++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> c : nums3)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> d : nums4)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(umap.<span class=\"built_in\">find</span>(- c - d) != umap.<span class=\"built_in\">end</span>() )</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    count += umap[- c - d];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["哈希"]},{"title":"383. 赎金信","url":"/posts/3fb1f6fc/","content":"<h1 id=\"leetcode-383.-赎金信\"><a\r\nhref=\"https://leetcode.cn/problems/ransom-note/\">leetcode-383.\r\n赎金信</a></h1>\r\n<p>常用的办法是开一个长度为26的数组，但是用<code>unordered_map</code>也一样。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">canConstruct</span><span class=\"params\">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class=\"line\">        unordered_map&lt;<span class=\"type\">char</span>,<span class=\"type\">int</span>&gt; umap;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> a : magazine)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            umap[a]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> b : ransomNote)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(umap[b] == <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            umap[b]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["哈希"]},{"title":"541. 反转字符串 II","url":"/posts/e20c25b0/","content":"<h1 id=\"leetcode-541.-反转字符串-ii\"><a\r\nhref=\"https://leetcode.cn/problems/reverse-string-ii/description/\">leetcode-541.\r\n反转字符串 II</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">reverse</span><span class=\"params\">(string&amp; s, <span class=\"type\">int</span> start, <span class=\"type\">int</span> end)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = start, j = end; i &lt; j; i++, j--) &#123;</span><br><span class=\"line\">            <span class=\"built_in\">swap</span>(s[i], s[j]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">reverseStr</span><span class=\"params\">(string s, <span class=\"type\">int</span> k)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); i += (<span class=\"number\">2</span> * k)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 1. 每隔 2k 个字符的前 k 个字符进行反转</span></span><br><span class=\"line\">            <span class=\"comment\">// 2. 剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (i + k &lt;= s.<span class=\"built_in\">size</span>()) &#123;</span><br><span class=\"line\">                <span class=\"built_in\">reverse</span>(s, i, i + k - <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 3. 剩余字符少于 k 个，则将剩余字符全部反转。</span></span><br><span class=\"line\">            <span class=\"built_in\">reverse</span>(s, i, s.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["字符串"]},{"title":"53. 最大子数组和","url":"/posts/460c78a0/","content":"<h1 id=\"leetcode-53.-最大子数组和\"><a\r\nhref=\"https://leetcode.cn/problems/maximum-subarray/\">leetcode-53.\r\n最大子数组和</a></h1>\r\n<p>所有的动态规划，都要按照下面的模板解题：</p>\r\n<h2 id=\"理解题意\">理解题意</h2>\r\n<p>题目要我们找出和最大的连续子数组的值是多少，<strong>连续</strong>是关键字，连续很重要，不是子序列。</p>\r\n<p>题目只要求返回结果，不要求得到最大的连续子数组是哪一个。这样的问题通常可以使用<strong>动态规划</strong>解决。</p>\r\n<h2 id=\"定义状态定义子问题\">定义状态（定义子问题）</h2>\r\n<p><span class=\"math inline\">\\(dp[i]\\)</span>:表示以<span\r\nclass=\"math inline\">\\(num[i]\\)</span>\r\n<strong>结尾</strong>的<strong>连续</strong>子数组的最大和。</p>\r\n<h2\r\nid=\"状态转移方程描述子问题之间的联系\">状态转移方程（描述子问题之间的联系）</h2>\r\n<p>根据状态的定义，由于<span\r\nclass=\"math inline\">\\(nums[i]\\)</span>一定会被选取，并且以<span\r\nclass=\"math inline\">\\(nums[i]\\)</span>结尾的连续子数组与以<span\r\nclass=\"math inline\">\\(nums[i - 1]\\)</span>结尾的连续子数组只相差一个元素\r\n<span class=\"math inline\">\\(nums[i]\\)</span>。</p>\r\n<p>假设数组 nums 的值全都严格大于0，那么一定有<span\r\nclass=\"math inline\">\\(dp[i] = dp[i - 1] + nums[i]\\)</span>。</p>\r\n<p>可是<span class=\"math inline\">\\(dp[i -\r\n1]\\)</span>有可能是负数，于是分类讨论：</p>\r\n<p>如果<span class=\"math inline\">\\(dp[i - 1] &gt;\r\n0\\)</span>，那么可以把<span\r\nclass=\"math inline\">\\(nums[i]\\)</span>直接接在<span\r\nclass=\"math inline\">\\(dp[i -\r\n1]\\)</span>表示的那个数组的后面，得到和更大的连续子数组； 如果<span\r\nclass=\"math inline\">\\(dp[i - 1] &lt;= 0\\)</span>，那么<span\r\nclass=\"math inline\">\\(nums[i]\\)</span>加上前面的数<span\r\nclass=\"math inline\">\\(dp[i - 1]\\)</span>以后值不会变大。于是<span\r\nclass=\"math inline\">\\(dp[i]\\)</span> 另起炉灶，此时单独的一个<span\r\nclass=\"math inline\">\\(nums[i]\\)</span>的值，就是<span\r\nclass=\"math inline\">\\(dp[i]\\)</span>。 以上两种情况的最大值就是<span\r\nclass=\"math inline\">\\(dp[i]\\)</span>的值，写出如下状态转移方程：</p>\r\n<p><span class=\"math display\">\\[\r\ndp[i]= \\begin{cases}\r\ndp[i-1]+nums[i] &amp; dp[i−1]&gt;0 \\\\\r\nnums[i],&amp; dp[i−1]≤0 \\\\\r\n\\end{cases}\r\n\\]</span></p>\r\n<p>记为状态转移方程 1。</p>\r\n<p>状态转移方程还可以这样写，反正求的是最大值，也不用分类讨论了，就这两种情况，取最大即可，因此还可以写出状态转移方程如下：</p>\r\n<p><span class=\"math display\">\\[\r\ndp[i] = max\\left\\{nums[i],dp[i-1]+nums[i]\\right\\}\r\n\\]</span></p>\r\n<p>记为状态转移方程 2。</p>\r\n<h2 id=\"思考初始值\">思考初始值</h2>\r\n<p><span\r\nclass=\"math inline\">\\(dp[0]\\)</span>根据定义，只有1个数，一定以<span\r\nclass=\"math inline\">\\(nums[0]\\)</span>结尾，因此<span\r\nclass=\"math inline\">\\(dp[0] = nums[0]\\)</span>。</p>\r\n<h2 id=\"思考输出\">思考输出</h2>\r\n<p>这里状态的定义不是题目中的问题的定义，<strong>不能直接将最后一个状态返回回去</strong>。</p>\r\n<p>这个问题的输出是把所有的<span\r\nclass=\"math inline\">\\(dp[0]、dp[1]、……、dp[n -\r\n1]\\)</span>都看一遍，取最大值。</p>\r\n<h2 id=\"编码\">编码</h2>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">maxSubArray</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; sum = <span class=\"built_in\">vector</span>(nums.<span class=\"built_in\">size</span>() + <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"type\">int</span> result = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= nums.<span class=\"built_in\">size</span>(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            sum[i] = <span class=\"built_in\">max</span>(nums[i<span class=\"number\">-1</span>] + sum[i<span class=\"number\">-1</span>], nums[i<span class=\"number\">-1</span>]);</span><br><span class=\"line\">            result = <span class=\"built_in\">max</span>(result, sum[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["动态规划"]},{"title":"59. 螺旋矩阵II","url":"/posts/4df2c59e/","content":"<h1 id=\"leetcode-59.-螺旋矩阵ii\"><a\r\nhref=\"https://leetcode.cn/problems/spiral-matrix-ii/\">leetcode-59.\r\n螺旋矩阵II</a></h1>\r\n<p>以n=3为例，此矩阵共赋值9次，移动8次，沿4个方向移动，问题的关键在于如何把这些操作不重不漏地分类完成。</p>\r\n<p>下一步要思考的是，根据n的不同，如何把这些操作分配到不同的轮次内，一个可行的办法是转一圈，算作一个轮次。</p>\r\n<p>一个轮次内有4个方向，由此可知，至少要写4个循环才能完成目标，同一方向的操作，写在一个循环内。</p>\r\n<p>最后，在完成一圈后，移动到下一圈开始的位置，即可完成循环。</p>\r\n<figure>\r\n<img src=\"https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg\"\r\nalt=\"实例\" />\r\n<figcaption aria-hidden=\"true\">实例</figcaption>\r\n</figure>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">generateMatrix</span>(<span class=\"type\">int</span> n) &#123;</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">result</span>(n,<span class=\"built_in\">vector</span>(n,<span class=\"number\">0</span>));</span><br><span class=\"line\">        <span class=\"type\">int</span> i = <span class=\"number\">1</span>, x = <span class=\"number\">0</span>, y = <span class=\"number\">0</span>, loop = n;  <span class=\"comment\">//loop为轮次的长度</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (loop &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> step = <span class=\"number\">0</span>; step &lt; loop <span class=\"number\">-1</span>; step++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result[x][y] = i;</span><br><span class=\"line\">                y++;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> step = <span class=\"number\">0</span>; step &lt; loop - <span class=\"number\">1</span>; step++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result[x][y] = i;</span><br><span class=\"line\">                x++;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> step = <span class=\"number\">0</span>; step &lt; loop - <span class=\"number\">1</span>; step++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result[x][y] = i;</span><br><span class=\"line\">                y--;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> step = <span class=\"number\">0</span>; step &lt; loop - <span class=\"number\">2</span>; step++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                result[x][y] = i;</span><br><span class=\"line\">                x--;</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//四次循环，对应四个方向的移动</span></span><br><span class=\"line\">            result[x][y] = i;</span><br><span class=\"line\">            y++;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            <span class=\"comment\">//把位置重置到下一轮的起始点</span></span><br><span class=\"line\">            loop -= <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["数组","模拟"]},{"title":"453. 最小操作次数使数组元素相等","url":"/posts/fa3eb899/","content":"<h1 id=\"leetcode-453.-最小操作次数使数组元素相等\"><a\r\nhref=\"https://leetcode.cn/problems/minimum-moves-to-equal-array-elements/description/\">leetcode-453.\r\n最小操作次数使数组元素相等</a></h1>\r\n<p>n-1个数加一，等价于1个数减一。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">minMoves</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> sum = <span class=\"number\">0</span>, min = nums[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : nums)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i &lt; min)</span><br><span class=\"line\">            min = i;</span><br><span class=\"line\">            sum += i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sum-(min*nums.<span class=\"built_in\">size</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["数组"]},{"title":"707. 设计链表","url":"/posts/f348f3f8/","content":"<h1 id=\"leetcode-707.-设计链表\"><a\r\nhref=\"https://leetcode.cn/problems/design-linked-list/\">leetcode-707.\r\n设计链表</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyLinkedList</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 定义链表节点结构体</span></span><br><span class=\"line\">    <span class=\"keyword\">struct</span> <span class=\"title class_\">LinkedNode</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> val;</span><br><span class=\"line\">        LinkedNode* next;</span><br><span class=\"line\">        <span class=\"built_in\">LinkedNode</span>(<span class=\"type\">int</span> val):<span class=\"built_in\">val</span>(val), <span class=\"built_in\">next</span>(<span class=\"literal\">nullptr</span>)&#123;&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 初始化链表</span></span><br><span class=\"line\">    <span class=\"built_in\">MyLinkedList</span>() &#123;</span><br><span class=\"line\">        _dummyHead = <span class=\"keyword\">new</span> <span class=\"built_in\">LinkedNode</span>(<span class=\"number\">0</span>); <span class=\"comment\">// 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点</span></span><br><span class=\"line\">        _size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt; (_size - <span class=\"number\">1</span>) || index &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LinkedNode* cur = _dummyHead-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index--)&#123; <span class=\"comment\">// 如果--index 就会陷入死循环</span></span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cur-&gt;val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addAtHead</span><span class=\"params\">(<span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        LinkedNode* newNode = <span class=\"keyword\">new</span> <span class=\"built_in\">LinkedNode</span>(val);</span><br><span class=\"line\">        newNode-&gt;next = _dummyHead-&gt;next;</span><br><span class=\"line\">        _dummyHead-&gt;next = newNode;</span><br><span class=\"line\">        _size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在链表最后面添加一个节点</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addAtTail</span><span class=\"params\">(<span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        LinkedNode* newNode = <span class=\"keyword\">new</span> <span class=\"built_in\">LinkedNode</span>(val);</span><br><span class=\"line\">        LinkedNode* cur = _dummyHead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(cur-&gt;next != <span class=\"literal\">nullptr</span>)&#123;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cur-&gt;next = newNode;</span><br><span class=\"line\">        _size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果index大于链表的长度，则返回空</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">addAtIndex</span><span class=\"params\">(<span class=\"type\">int</span> index, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt; _size) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LinkedNode* newNode = <span class=\"keyword\">new</span> <span class=\"built_in\">LinkedNode</span>(val);</span><br><span class=\"line\">        LinkedNode* cur = _dummyHead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index--) &#123;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        newNode-&gt;next = cur-&gt;next;</span><br><span class=\"line\">        cur-&gt;next = newNode;</span><br><span class=\"line\">        _size++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">deleteAtIndex</span><span class=\"params\">(<span class=\"type\">int</span> index)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (index &gt;= _size || index &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LinkedNode* cur = _dummyHead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(index--) &#123;</span><br><span class=\"line\">            cur = cur -&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        LinkedNode* tmp = cur-&gt;next;</span><br><span class=\"line\">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span> tmp;</span><br><span class=\"line\">        _size--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 打印链表</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printLinkedList</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        LinkedNode* cur = _dummyHead;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (cur-&gt;next != <span class=\"literal\">nullptr</span>) &#123;</span><br><span class=\"line\">            cout &lt;&lt; cur-&gt;next-&gt;val &lt;&lt; <span class=\"string\">&quot; &quot;</span>;</span><br><span class=\"line\">            cur = cur-&gt;next;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        cout &lt;&lt; endl;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> _size;</span><br><span class=\"line\">    LinkedNode* _dummyHead;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["链表"]},{"title":"665. 非递减数列","url":"/posts/36199ffe/","content":"<h1 id=\"leetcode-65.-非递减数列\"><a\r\nhref=\"https://leetcode.cn/problems/non-decreasing-array/description/\">leetcode-65.\r\n非递减数列</a></h1>\r\n<p>这段代码实现了一个时间复杂度为 O(n)、空间复杂度为 O(1)\r\n的解法，用于判断在最多修改一个元素的情况下，给定的数组 nums\r\n能否变成一个非递减数列。</p>\r\n<p>具体来说，它通过遍历数组 nums，对于每一对相邻元素 (x, y)\r\n进行比较，如果 x &gt;\r\ny，则说明需要修改一个元素才能满足非递减的条件。此时，将修改次数 cnt\r\n加一，并判断 cnt\r\n是否超过了一次，如果超过了一次，则说明无法只修改一个元素来满足条件，直接返回\r\nfalse。</p>\r\n<p>如果 cnt\r\n不超过一次，则需要考虑修改哪个元素。为了保证修改后的数组满足非递减的条件，有两种可能的情况需要考虑：</p>\r\n<ol type=\"1\">\r\n<li><p>修改 nums[i]，使得 x &lt;= y，此时修改后的数组可能会影响到 i - 1\r\n和 i + 1 位置的元素。如果 nums[i + 1] &lt; nums[i - 1]，则说明需要将\r\nnums[i + 1] 修改为 nums[i]，否则将 nums[i] 修改为 nums[i + 1]。</p></li>\r\n<li><p>修改 nums[i + 1]，使得 x &lt;= y，此时只会影响到 i + 1\r\n位置的元素，因为 i 和 i - 1 位置的元素已经是非递减的了。因此，直接将\r\nnums[i + 1] 修改为 nums[i] 即可。</p></li>\r\n</ol>\r\n<p>最后，如果遍历完整个数组 nums 之后都没有返回\r\nfalse，则说明只需要修改不超过一次元素就可以将数组变成非递减的，返回 true\r\n即可。</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">checkPossibility</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>(), cnt = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n - <span class=\"number\">1</span>; ++i) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> x = nums[i], y = nums[i + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (x &gt; y) &#123;</span><br><span class=\"line\">                cnt++;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (cnt &gt; <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (i &gt; <span class=\"number\">0</span> &amp;&amp; y &lt; nums[i - <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                    nums[i + <span class=\"number\">1</span>] = x;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["数组"]},{"title":"66. 加一","url":"/posts/67f68e42/","content":"<h1 id=\"leetcode-66.-加一\"><a\r\nhref=\"https://leetcode.cn/problems/plus-one/description/\">leetcode-66.\r\n加一</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">plusOne</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = digits.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(digits[i] != <span class=\"number\">9</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                digits[i]++;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> digits;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            digits[i] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//出了循环，说明全是9</span></span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">result</span><span class=\"params\">(digits.size() + <span class=\"number\">1</span>, <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        result[<span class=\"number\">0</span>] = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["数组"]},{"title":"75. 颜色分类","url":"/posts/75dc9575/","content":"<h1 id=\"leetcode-75.-颜色分类\"><a\r\nhref=\"https://leetcode.cn/problems/sort-colors/description/\">leetcode-75.\r\n颜色分类</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">sortColors</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> m = <span class=\"number\">0</span>; <span class=\"comment\">// 用于记录0出现的位置</span></span><br><span class=\"line\">        <span class=\"type\">int</span> n = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; <span class=\"comment\">// 用于记录2出现的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt;= n; i++) &#123; <span class=\"comment\">// 遍历整个数组</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (i &lt;= n &amp;&amp; nums[i] == <span class=\"number\">2</span>) &#123; <span class=\"comment\">// 如果当前数字为2</span></span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(nums[i], nums[n]); <span class=\"comment\">// 将当前数字和最后一个数字进行交换</span></span><br><span class=\"line\">                --n; <span class=\"comment\">// 更新最后一个数字的位置</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] == <span class=\"number\">0</span>) &#123; <span class=\"comment\">// 如果当前数字为0</span></span><br><span class=\"line\">                <span class=\"built_in\">swap</span>(nums[i], nums[m]); <span class=\"comment\">// 将当前数字和第一个数字进行交换</span></span><br><span class=\"line\">                ++m; <span class=\"comment\">// 更新第一个数字的位置</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n","categories":["算法笔记"],"tags":["双指针","数组"]},{"title":"831. 隐藏个人信息","url":"/posts/c805edf0/","content":"<h1 id=\"leetcode-831.-隐藏个人信息\"><a\r\nhref=\"https://leetcode.cn/problems/masking-personal-information/description/\">leetcode-831.\r\n隐藏个人信息</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">maskPII</span><span class=\"params\">(string s)</span> </span>&#123;</span><br><span class=\"line\">        string result;</span><br><span class=\"line\">        <span class=\"type\">int</span> at = s.<span class=\"built_in\">find</span>(<span class=\"string\">&#x27;@&#x27;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(at != string::npos)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">transform</span>(s.<span class=\"built_in\">begin</span>(), s.<span class=\"built_in\">end</span>(), s.<span class=\"built_in\">begin</span>(), ::tolower);</span><br><span class=\"line\">            result = s.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>,<span class=\"number\">1</span>) + <span class=\"string\">&quot;*****&quot;</span>+s.<span class=\"built_in\">substr</span>(at - <span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            vector&lt;string&gt; country = &#123;<span class=\"string\">&quot;&quot;</span>, <span class=\"string\">&quot;+*-&quot;</span>, <span class=\"string\">&quot;+**-&quot;</span>, <span class=\"string\">&quot;+***-&quot;</span>&#125;;</span><br><span class=\"line\">            s = <span class=\"built_in\">regex_replace</span>(s, <span class=\"built_in\">regex</span>(<span class=\"string\">&quot;[^0-9]&quot;</span>), <span class=\"string\">&quot;&quot;</span>);</span><br><span class=\"line\">            result = country[s.<span class=\"built_in\">size</span>() - <span class=\"number\">10</span>] + <span class=\"string\">&quot;***-***-&quot;</span> + s.<span class=\"built_in\">substr</span>(s.<span class=\"built_in\">size</span>() - <span class=\"number\">4</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>简简单单的代码，包含了不少知识：</p>\r\n<h2 id=\"stringnpos的类型\">string::npos的类型</h2>\r\n<p>网上一些博客有这样一种说法，string::npos不应该被定义为int，这样会导致错误，经过查阅，这种说法既对又不对。</p>\r\n<p>在一些老版本的C++标准中，string::npos可能被定义为一个int类型的常量，这可能会导致一些类型转换问题。但在C++11及以上的标准中，string::npos被定义为size_t类型的常量，因此不会出现类型问题。</p>\r\n<h2\r\nid=\"用双引号和单引号表示的字符串有什么区别\">用双引号和单引号表示的字符串有什么区别？</h2>\r\n<p>在C++中，使用双引号 \" 表示的字符串是字符串字面量，会被解释为一个\r\nconst char* 类型的指针。例如，const char* s = \"hello\";\r\n将会创建一个指向字符串 \"hello\" 的指针。</p>\r\n<p>而使用单引号 ' 表示的是字符字面量，会被解释为一个 char\r\n类型的值。例如，char c = 'a'; 将会创建一个值为 'a' 的 char 变量。</p>\r\n<p>另外，双引号表示的字符串可以包含任意数量的字符，而单引号只能包含一个字符。因此，如果要表示一个字符串，应该使用双引号，而如果要表示一个单独的字符，应该使用单引号。</p>\r\n<h2 id=\"substr-函数在一个参数的时候代表什么\">substr\r\n函数在一个参数的时候代表什么？</h2>\r\n<p>当 substr\r\n函数只有一个参数时，它表示从该参数所指定的位置开始，一直截取到字符串的末尾。例如，std::string\r\ns = \"hello world\"; s = s.substr(6); 将把 s 的值改为 \"world\"。</p>\r\n<h2\r\nid=\"如何将大写字母转换为小写字母\">如何将大写字母转换为小写字母？</h2>\r\n<p>可以使用C++中的 std::tolower()\r\n函数将大写字母转换为小写字母。例如，char c = 'A'; c = std::tolower(c);\r\n将把 c 的值改为小写字母 a。</p>\r\n<h2 id=\"transform的用法\">transform的用法</h2>\r\n<p>std::transform是C++标准库中的一个算法，它用于对一个序列中的每个元素进行转换，并将结果存储到另一个序列中。transform的一般用法如下：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\">std::<span class=\"built_in\">transform</span>(InputIt first1, InputIt last1, OutputIt d_first, UnaryOperation unary_op);</span><br></pre></td></tr></table></figure>\r\n<p>其中，first1和last1表示输入序列的范围，d_first表示输出序列的起始位置，unary_op表示对每个输入元素要执行的操作。具体来说，transform将从first1到last1中的每个元素应用unary_op操作，并将结果存储到从d_first开始的输出序列中。</p>\r\n<p>下面是一些transform的常见用法：</p>\r\n<ol type=\"1\">\r\n<li>对容器中的元素应用函数</li>\r\n</ol>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">add_one</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; nums&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    <span class=\"function\">std::vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">result</span><span class=\"params\">(nums.size())</span></span>;</span><br><span class=\"line\">    std::<span class=\"built_in\">transform</span>(nums.<span class=\"built_in\">begin</span>(), nums.<span class=\"built_in\">end</span>(), result.<span class=\"built_in\">begin</span>(), add_one);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : result) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; i &lt;&lt; <span class=\"string\">&quot; &quot;</span>; <span class=\"comment\">// 输出：2 3 4 5 6</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>上述代码中，transform函数对nums中的每个元素应用add_one函数，并将结果存储到result容器中。</p>\r\n<ol start=\"2\" type=\"1\">\r\n<li>对字符串中的字符应用函数</li>\r\n</ol>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cctype&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::string s = <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">    std::<span class=\"built_in\">transform</span>(s.<span class=\"built_in\">begin</span>(), s.<span class=\"built_in\">end</span>(), s.<span class=\"built_in\">begin</span>(), ::tolower);</span><br><span class=\"line\">    std::cout &lt;&lt; s &lt;&lt; std::endl; <span class=\"comment\">// 输出：hello world</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<ol start=\"3\" type=\"1\">\r\n<li>对两个容器的元素应用函数</li>\r\n</ol>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x, <span class=\"type\">int</span> y)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; nums1&#123;<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; nums2&#123;<span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>&#125;;</span><br><span class=\"line\">    <span class=\"function\">std::vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">result</span><span class=\"params\">(nums1.size())</span></span>;</span><br><span class=\"line\">    std::<span class=\"built_in\">transform</span>(nums1.<span class=\"built_in\">begin</span>(), nums1.<span class=\"built_in\">end</span>(), nums2.<span class=\"built_in\">begin</span>(), result.<span class=\"built_in\">begin</span>(), add);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> i : result) &#123;</span><br><span class=\"line\">        std::cout &lt;&lt; i &lt;&lt; <span class=\"string\">&quot; &quot;</span>; <span class=\"comment\">// 输出：7 9 11 13 15</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\r\n<h2 id=\"什么是-regex_replace-函数\">什么是 regex_replace 函数？</h2>\r\n<p>regex_replace 函数是 C++\r\n标准库中正则表达式库的一部分，提供了对字符串进行正则表达式匹配和替换的功能。使用该函数可以将字符串中匹配到的部分替换为指定的内容。</p>\r\n","categories":["算法笔记"],"tags":["字符串","STL"]},{"title":"977. 有序数组的平方","url":"/posts/b14e4c6/","content":"<h1 id=\"leetcode-977.-有序数组的平方\"><a\r\nhref=\"https://leetcode.cn/problems/squares-of-a-sorted-array/description/\">leetcode-977.\r\n有序数组的平方</a></h1>\r\n<p>此题是一道操作双指针题，两个指针分别从数组的首尾出发，两两比较，将较大的那个平方后输出到结果集中。\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">sortedSquares</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> k = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">result</span><span class=\"params\">(nums.size(), <span class=\"number\">0</span>)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>, j = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>; i &lt;= j;) &#123; <span class=\"comment\">// 注意这里要i &lt;= j，因为最后要处理两个元素</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[i] * nums[i] &lt; nums[j] * nums[j])  &#123;</span><br><span class=\"line\">                result[k--] = nums[j] * nums[j];</span><br><span class=\"line\">                j--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                result[k--] = nums[i] * nums[i];</span><br><span class=\"line\">                i++;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure> <img\r\nsrc=\"https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif\"\r\ntitle=\"示意图\" alt=\"有序数组的平方\" /></p>\r\n","categories":["算法笔记"],"tags":["双指针","数组"]},{"title":"82. 删除排序链表中的重复元素 II","url":"/posts/c67c6f0d/","content":"<h1 id=\"leetcode-82.-删除排序链表中的重复元素-ii\"><a\r\nhref=\"https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/\">leetcode-82.\r\n删除排序链表中的重复元素 II</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">ListNode* <span class=\"title\">deleteDuplicates</span><span class=\"params\">(ListNode* head)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(head == <span class=\"literal\">nullptr</span>) <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">        ListNode* temp = <span class=\"keyword\">new</span> <span class=\"built_in\">ListNode</span>(<span class=\"number\">101</span>);</span><br><span class=\"line\">        temp-&gt;next = head;</span><br><span class=\"line\">        ListNode* slowIndex = temp;</span><br><span class=\"line\">        ListNode* fastIndex = head;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(fastIndex != <span class=\"literal\">nullptr</span> &amp;&amp; fastIndex-&gt;next)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> value = fastIndex-&gt;val;</span><br><span class=\"line\">            fastIndex = fastIndex-&gt;next;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(value == fastIndex-&gt;val)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(fastIndex != <span class=\"literal\">nullptr</span> &amp;&amp; fastIndex-&gt;val == value)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    slowIndex-&gt;next = fastIndex-&gt;next;</span><br><span class=\"line\">                    ListNode* d = fastIndex;</span><br><span class=\"line\">                    fastIndex = fastIndex-&gt;next;</span><br><span class=\"line\">                    <span class=\"keyword\">delete</span> d;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">else</span></span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                slowIndex = slowIndex-&gt;next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> temp-&gt;next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>用一个temp头结点，加到链表的开头，记录需要返回的位置(因为初始节点的开头head可能被删掉，如果不加入temp，必须得分类讨论)。</p>\r\n<p>用两个指针，fastIndex检查节点的值是否重复，slowIndex则停留在检查过的值的末端位置，这个设计充分展现了链表“能去不能回”的特性。</p>\r\n","categories":["算法笔记"],"tags":["双指针","链表"]},{"title":"CSAPP 第一章：计算机系统漫游","url":"/posts/19b7c283/","content":"<h1 id=\"csapp-第一章计算机系统漫游\">CSAPP 第一章：计算机系统漫游</h1>\r\n<h2 id=\"信息就是位上下文\">1.1 信息就是位+上下文</h2>\r\n<p>计算机以二进制形式表示信息，每个二进制位表示一种状态，可以表示数字、字符等等。\r\n上下文指的是信息被解释的环境，同样的位在不同上下文中可能有不同的含义。\r\n字节是计算机中常用的信息单位，一个字节通常表示8位二进制数据。</p>\r\n<h2 id=\"程序被其他程序翻译成不同的格式\">1.2\r\n程序被其他程序翻译成不同的格式</h2>\r\n<p>操作系统负责将高级语言程序翻译成机器语言程序，其中编译器将高级语言翻译成汇编语言，汇编器将汇编语言翻译成机器语言。\r\n目标代码是机器语言的二进制表示形式，可执行目标代码是可直接在计算机上运行的机器语言程序。\r\n共享库是一段被多个程序共享的目标代码，使得程序在运行时所需的内存更小。</p>\r\n<h2 id=\"了解编译系统如何工作是大有益处的\">1.3\r\n了解编译系统如何工作是大有益处的</h2>\r\n<ul>\r\n<li>优化程序性能</li>\r\n<li>理解链接是出现的错误</li>\r\n<li>避免安全漏洞</li>\r\n</ul>\r\n<h2 id=\"处理器读取并解释存储在内存中的指令\">1.4\r\n处理器读取并解释存储在内存中的指令</h2>\r\n<p>存储器层次结构指的是计算机中各个存储设备（寄存器、缓存、主存、硬盘等）按照距离处理器远近划分的层次结构。\r\n处理器解释并执行存储在内存中的指令，指令集体系结构定义了处理器能够执行的指令集合。\r\n程序计数器是一个寄存器，保存当前正在执行的指令地址，处理器按顺序逐条执行指令。</p>\r\n<h2 id=\"高速缓存至关重要\">1.5 高速缓存至关重要</h2>\r\n<p>高速缓存是存储器层次结构中的一级缓存，用于加速处理器访问主存中的数据。\r\n高速缓存采用空间局部性和时间局部性原理，预测处理器未来访问的数据，提前将其缓存到高速缓存中。\r\n高速缓存的命中率指的是处理器需要的数据在高速缓存中的比例，高速缓存的访问时间短于主存，能显著提升程序性能。</p>\r\n<h2 id=\"存储设备形成层次结构\">1.6 存储设备形成层次结构</h2>\r\n<p>存储设备也有层次结构，根据访问时间、容量和价格的不同分为寄存器、高速缓存、主存、硬盘等层次。\r\n存储设备的层次结构决定了数据的访问速度和容量，越靠近处理器的存储设备速度越快，容量越小。\r\n存储器和磁盘都采用二进制编址方案，即将每个存储单元（或扇区）赋予一个唯一的二进制地址，用于在存储设备中寻找数据。</p>\r\n<h2 id=\"操作系统管理硬件\">1.7 操作系统管理硬件</h2>\r\n<p>操作系统是计算机中负责管理各种硬件设备的程序，包括进程、内存、文件等。\r\n操作系统为进程提供了虚拟地址空间，使得每个进程看到的内存空间都是相同的。\r\n文件系统是操作系统中负责管理磁盘上文件和目录的程序，文件被组织成目录树结构。</p>\r\n<h2 id=\"系统之间利用网络通信\">1.8 系统之间利用网络通信</h2>\r\n<p>高速网络使得计算机之间可以快速传输大量数据，网络中传输的数据以分组为单位。\r\n因特网是一种全球范围内的计算机网络，互联了数十亿个计算机。\r\n网络协议是计算机间通信的规则，常见的网络协议有TCP/IP协议。</p>\r\n<h2 id=\"重要主题\">1.9 重要主题</h2>\r\n<h3 id=\"amdahl定律\">Amdahl定律</h3>\r\n<p>该定律指出，一个程序在多处理器系统上的加速比取决于其可并行化部分的比例和处理器的数量。</p>\r\n<p>假设一个程序的总运行时间为<span\r\nclass=\"math inline\">\\(T\\)</span>，其中有一个比例为<span\r\nclass=\"math inline\">\\(\\alpha\\)</span>的部分可以被并行化（即可以使用多个处理器同时执行），而剩余的比例为<span\r\nclass=\"math inline\">\\(1 -\r\n\\alpha\\)</span>的部分必须在单个处理器上顺序执行。如果该程序在单个处理器上运行的时间为<span\r\nclass=\"math inline\">\\(T_1\\)</span>，在<span\r\nclass=\"math inline\">\\(N\\)</span>个处理器上运行的时间为<span\r\nclass=\"math inline\">\\(T_N\\)</span>，则该程序在<span\r\nclass=\"math inline\">\\(N\\)</span>个处理器上的加速比为：</p>\r\n<p><span class=\"math display\">\\[\r\nSpeedup_{overall} = \\frac{1}{(1 - \\alpha) + \\frac{\\alpha}{N}}\r\n\\]</span></p>\r\n<h3 id=\"并发与并行\">并发与并行</h3>\r\n<p>并发指的是多个计算机或进程在同一时间内执行多个任务的能力，可以提高程序的性能。\r\n操作系统需要管理多个进程之间的并发访问，包括进程调度、同步、互斥等机制。\r\n并发编程需要注意同步和互斥问题，多线程编程需要注意线程安全问题。</p>\r\n","categories":["CSAPP"],"tags":["CSAPP","计算机组成原理","chatGPT"]},{"title":"CSAPP 第二章：信息的表示和处理","url":"/posts/6870ef63/","content":"<h1 id=\"csapp-第二章信息的表示和处理\">CSAPP\r\n第二章：信息的表示和处理</h1>\r\n<h2 id=\"信息存储\">2.1 信息存储</h2>\r\n<h3 id=\"位和字节\">位和字节</h3>\r\n<ul>\r\n<li>计算机中最小的存储单位是位（bit），每个位可以存储0或1。</li>\r\n<li>8个位构成一个字节（byte），通常用于表示一个字符或一个整数的值。</li>\r\n<li>计算机中的数据是按字节为单位存储的，每个字节都有一个唯一的地址。</li>\r\n</ul>\r\n<h3 id=\"十六进制表示法\">十六进制表示法</h3>\r\n<ul>\r\n<li>十六进制表示法用于方便地表示二进制数。</li>\r\n<li>每个十六进制数字对应于4个二进制位，因此一个字节可以表示为两个十六进制数字。</li>\r\n<li>十六进制数字包括0到9和A到F。</li>\r\n</ul>\r\n<h3 id=\"字数据大小\">字数据大小</h3>\r\n<ul>\r\n<li>计算机中常用的字大小有1字节（8位）、2字节（16位）、4字节（32位）和8字节（64位）。</li>\r\n<li>不同的字大小可以表示的最大值不同，例如1字节可以表示的最大值为255（<span\r\nclass=\"math inline\">\\(2^8-1\\)</span>），而4字节可以表示的最大值为4294967295（<span\r\nclass=\"math inline\">\\(2^{32}-1\\)</span>）。</li>\r\n</ul>\r\n<h3 id=\"数据类型\">数据类型</h3>\r\n<ul>\r\n<li>不同类型的数据在计算机中存储的方式不同。</li>\r\n<li>布尔类型通常存储为1字节，0表示假，非0表示真。</li>\r\n<li>整数类型可以使用有符号或无符号表示，有符号类型使用补码表示，无符号类型使用无符号整数表示。</li>\r\n<li>浮点数类型通常使用IEEE标准表示，包括符号位、指数位和尾数位。</li>\r\n</ul>\r\n<h3 id=\"c语言数据类型\">C语言数据类型</h3>\r\n<ul>\r\n<li>C语言支持各种数据类型，包括整数类型、浮点数类型、字符类型等。\r\n不同的数据类型在内存中占用的字节数不同，可以使用sizeof运算符获取。</li>\r\n<li>在C语言中，常量可以直接使用字面值表示，例如整数常量、浮点数常量、字符常量等。</li>\r\n<li>为什么防止不同编译器的不同设置引起的奇怪问题，引入了数据大小固定的数据类型，例如int32_t和int64_t。</li>\r\n</ul>\r\n<h3 id=\"大端和小端\">大端和小端</h3>\r\n<p>在计算机中，数据在内存中存储时需要占用多个字节。大端和小端是两种不同的字节序，用于确定多字节数据中字节的存储顺序。</p>\r\n<ul>\r\n<li><p>大端字节序：在大端字节序中，最高位字节（即最高有效字节）存储在最低地址处，最低位字节（即最低有效字节）存储在最高地址处。例如，十六进制数0x12345678在大端字节序中存储为12\r\n34 56\r\n78，最高位字节0x12存储在最低地址处，最低位字节0x78存储在最高地址处。</p></li>\r\n<li><p>小端字节序：在小端字节序中，最低位字节（即最低有效字节）存储在最低地址处，最高位字节（即最高有效字节）存储在最高地址处。例如，十六进制数0x12345678在小端字节序中存储为78\r\n56 34\r\n12，最低位字节0x78存储在最低地址处，最高位字节0x12存储在最高地址处。</p></li>\r\n</ul>\r\n<p>两种字节序的区别在于多字节数据的字节存储顺序，而单字节数据的字节存储顺序是相同的。在网络通信和数据传输中，通常使用大端字节序。一些计算机处理器（如PowerPC）采用大端字节序，而另一些计算机处理器（如x86）采用小端字节序。在程序开发中，需要考虑字节序的问题，以免造成数据解析错误或不兼容的问题。</p>\r\n<h3 id=\"布尔代数\">布尔代数</h3>\r\n<p>布尔代数是一种数学分支，也是一种逻辑代数。它以二元关系和二元运算为基础，用于描述逻辑命题和逻辑运算，其中的基本元素只有两个值，通常用0和1表示。在布尔代数中，0表示假，1表示真。</p>\r\n<p>布尔代数的运算包括与（AND）、或（OR）、非（NOT）和异或（XOR）等。以AND运算为例，当两个元素的值均为1时，AND运算的结果为1，否则为0。OR运算的结果是两个元素的值中至少有一个为1时为1，否则为0。NOT运算的结果是一个元素的值取反，即1变成0，0变成1。XOR运算的结果是两个元素的值不相同时为1，相同时为0。</p>\r\n<p>利用异或的性质解题：<a\r\nhref=\"https://vinouno.github.io/posts/93cfc1bf/\">leetcode-136.\r\n只出现一次的数字</a></p>\r\n<p>布尔代数广泛应用于计算机科学领域中的逻辑设计、编译器设计、数据结构、算法设计等方面。例如，在逻辑电路的设计中，可以使用布尔代数的公式来简化电路的设计，从而减少电路的复杂性和成本。在编译器的设计中，布尔代数也被用来描述和优化中间代码和目标代码的生成和优化过程。在数据结构和算法设计中，布尔代数常常被用来描述逻辑运算和条件判断等。</p>\r\n<h3 id=\"c语言中的逻辑运算\">C语言中的逻辑运算</h3>\r\n<p>逻辑与（&amp;&amp;）运算符表示两个表达式都为真时结果为真，只要有一个表达式为假则结果为假。例如，a\r\n&amp;&amp; b表示当a和b都为真时结果为真，否则结果为假。</p>\r\n<p>逻辑或（||）运算符表示两个表达式有一个为真时结果为真，只有两个表达式都为假时结果为假。例如，a\r\n|| b表示当a或b中有一个为真时结果为真，否则结果为假。</p>\r\n<p>逻辑非（!）运算符表示对一个表达式取反。例如，!a表示当a为假时结果为真，当a为真时结果为假。</p>\r\n<h3 id=\"c语言中的移位\">C语言中的移位</h3>\r\n<p>C语言中的移位运算是位运算的一种，包括左移运算符（&lt;&lt;）、逻辑右移运算符（&gt;&gt;&gt;）、算术右移运算符（&gt;&gt;）。</p>\r\n<p>左移运算符（&lt;&lt;）将一个数的二进制表示向左移动指定的位数，右侧空出的位补0。例如，a\r\n&lt;&lt; 2表示将a的二进制表示向左移动2位，即将a的值乘以4。</p>\r\n<p>逻辑右移运算符（&gt;&gt;&gt;）将一个数的二进制表示向右移动指定的位数，左侧空出的位补0。例如，a\r\n&gt;&gt;&gt; 1表示将a的二进制表示向右移动1位，左侧空出的位补0。</p>\r\n<p>算术右移运算符（&gt;&gt;）将一个数的二进制表示向右移动指定的位数，左侧空出的位补符号位，即正数补0，负数补1。例如，a\r\n&gt;&gt; 1表示将a的二进制表示向右移动1位，即将a的值除以2。</p>\r\n<p>在C语言标准中，并没有明确定义算术右移和逻辑右移的方法，具体的实现方式取决于编译器和处理器的实现。在实际中，大部分的处理器都采用了算术右移的方式来进行有符号数的右移操作，即将左侧空出的位补上符号位；而无符号数的右移操作一般采用逻辑右移的方式，即左侧空出的位补0。</p>\r\n<p>由于C语言标准并没有规定右移的行为，因此在进行有符号数的右移操作时，存在一些跨平台的兼容性问题，不同的编译器和处理器可能会有不同的实现方式。因此，为了避免这些问题，建议在进行右移操作时，尽量使用无符号数进行位运算，或者使用移位后进行符号扩展的方法。</p>\r\n<p>移位运算在C语言中常用于优化计算，比如将乘法运算转化为移位运算。需要注意的是，移位运算符的使用需要遵循一定的规则，如不可将一个数向右移动超过它的位数，否则结果将不可预知。在使用算术右移时，需要注意负数的符号扩展问题，可以通过逻辑右移再进行符号位的处理。</p>\r\n<h2 id=\"整数表示\">2.2 整数表示</h2>\r\n<h3 id=\"补码\">补码</h3>\r\n<p>补码是一种用来表示有符号整数的编码方式。对于一个n位二进制数，它的补码表示方法如下：</p>\r\n<ul>\r\n<li>对于正数，它的补码就是它的原码（即二进制数的绝对值）</li>\r\n<li>对于负数，它的补码是将它的原码除符号位以外的所有位按位取反，然后再加1所得到的结果</li>\r\n</ul>\r\n<p>对于一个n位的补码数X，其数值表示为：</p>\r\n<p><span class=\"math display\">\\[\r\nX = -w_{n-1} × 2^{n-1} + ∑_{i=0}^{n-2}w_i × 2^i\r\n\\]</span></p>\r\n<p>其中，<span\r\nclass=\"math inline\">\\(w_{n-1}\\)</span>表示符号位，若为0则表示正数，若为1则表示负数。</p>\r\n<p>以一个8位的有符号整数-7为例，其原码为：</p>\r\n<p><span class=\"math display\">\\[\r\n-7_{10} = 10000111_{2}\r\n\\]</span></p>\r\n<p>将其转换为补码：</p>\r\n<ol type=\"1\">\r\n<li>对于符号位，符号位为1，表示负数。</li>\r\n<li>对于除符号位以外的所有位，将其取反得到01111000。</li>\r\n<li>将取反后的结果加1，得到01111001。</li>\r\n</ol>\r\n<p>因此，-7的补码表示为01111001。</p>\r\n<h3\r\nid=\"有符号数和无符号数的运算与转化\">有符号数和无符号数的运算与转化</h3>\r\n<p>有符号数和无符号数的运算和转化涉及到它们在内存中存储的方式不同，可能会导致意想不到的结果。</p>\r\n<p>首先，无符号数的取值范围是 <span class=\"math inline\">\\(0\\)</span> 到\r\n<span class=\"math inline\">\\(2^n-1\\)</span>，其中 <span\r\nclass=\"math inline\">\\(n\\)</span> 是该类型的位数。因此，当无符号数的值为\r\n<span class=\"math inline\">\\(0\\)</span> 时，其所有位都为 <span\r\nclass=\"math inline\">\\(0\\)</span>。</p>\r\n<p>而对于有符号数，它的第一位通常表示它的符号。使用补码表示时，有符号数的取值范围是\r\n<span class=\"math inline\">\\(-2^{n-1}\\)</span> 到 <span\r\nclass=\"math inline\">\\(2^{n-1}-1\\)</span>。对于一个 <span\r\nclass=\"math inline\">\\(n\\)</span> 位的有符号数，最高位的权重是 <span\r\nclass=\"math inline\">\\(-2^{n-1}\\)</span>，其余位的权重分别为 <span\r\nclass=\"math inline\">\\(2^{n-2}\\)</span>、<span\r\nclass=\"math inline\">\\(2^{n-3}\\)</span>、<span\r\nclass=\"math inline\">\\(\\cdots\\)</span>、<span\r\nclass=\"math inline\">\\(2^0\\)</span>。</p>\r\n<p>当有符号数和无符号数发生运算时，C语言会将无符号数当作有符号数进行运算。如果无符号数的值小于\r\n<span\r\nclass=\"math inline\">\\(0\\)</span>，那么它会被解释为有符号数的一个较大的正数值，这可能导致意想不到的结果。</p>\r\n<p>当将有符号数转换为无符号数时，如果该数的值为负，则将其值加上 <span\r\nclass=\"math inline\">\\(2^n\\)</span>（其中 <span\r\nclass=\"math inline\">\\(n\\)</span>\r\n是该类型的位数），直到它成为一个非负数。这种转换也可能导致意想不到的结果，例如：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> y = <span class=\"number\">-20</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%u\\n&quot;</span>, x + y);</span><br></pre></td></tr></table></figure>\r\n<p>上面的代码中，y 被转换为一个无符号数，其值为 <span\r\nclass=\"math inline\">\\(2^{32}-20\\)</span>。因此，x + y 的值为 <span\r\nclass=\"math inline\">\\(2^{32}-10\\)</span>，它通常不是我们想要的结果。</p>\r\n<h3 id=\"拓展与截断\">拓展与截断</h3>\r\n<p>拓展和截断是指对于一个数据类型，将其从一种宽度（width）转换为另一种宽度的过程。</p>\r\n<p>拓展指将一个较窄的数据类型转换为一个较宽的数据类型时所进行的操作。例如，将一个8位的无符号数拓展为一个16位的无符号数，就需要将其高位补0。拓展操作可以通过左移、右移和或操作等方式来实现。</p>\r\n<p>例如，将一个8位的无符号数x拓展为一个16位的无符号数y，可以使用下面的代码：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">char</span> x = <span class=\"number\">0x23</span>; <span class=\"comment\">// 0000 0010</span></span><br><span class=\"line\"><span class=\"type\">unsigned</span> <span class=\"type\">short</span> y = (<span class=\"type\">unsigned</span> <span class=\"type\">short</span>) x; <span class=\"comment\">// 0000 0000 0010 0011</span></span><br></pre></td></tr></table></figure>\r\n<p>在上面的代码中，我们将x拓展为一个16位的无符号数y，使用了显式类型转换的方式。</p>\r\n<p>截断指将一个较宽的数据类型转换为一个较窄的数据类型时所进行的操作。例如，将一个32位的整数截断为一个16位的整数，就需要将其高位截断。截断操作会导致数据的精度降低，可能会导致精度损失和数据溢出等问题。</p>\r\n<p>例如，将一个32位的有符号整数x截断为一个16位的有符号整数y，可以使用下面的代码：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">0x0000ffff</span>; <span class=\"comment\">// 0000 0000 0000 0000 1111 1111 1111 1111</span></span><br><span class=\"line\"><span class=\"type\">short</span> y = (<span class=\"type\">short</span>) x; <span class=\"comment\">// 1111 1111 1111 1111</span></span><br></pre></td></tr></table></figure>\r\n<p>在上面的代码中，我们将x截断为一个16位的有符号整数y，使用了显式类型转换的方式。由于x的高位都是0，因此截断的结果和原始值相同。</p>\r\n<p>需要注意的是，对于有符号整数的拓展和截断操作，其具体的结果取决于CPU的架构和编译器的实现。例如，对于有符号整数的截断操作，一些编译器会采用“截断高位，保留低位”的方式，而另一些编译器则会采用“截断低位，保留符号位”的方式。因此，在进行数据类型转换时，应该根据具体的编译器和CPU架构来决定具体的实现方式。</p>\r\n<h2 id=\"整数运算\">2.3 整数运算</h2>\r\n<h3 id=\"无符号数加法\">无符号数加法</h3>\r\n<p>在无符号数加法中，操作数被当做没有符号的正数进行处理。无符号数加法遵循模算术（模为\r\n2 的 n 次方，n\r\n是数的位数），当结果超出模范围时，结果会对模取模，保留余数。例如，8\r\n位无符号数的模为 256，当两个 8 位无符号数相加时，如果结果大于\r\n255，则结果会对 256 取模，例如：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">200</span> + <span class=\"number\">100</span> = <span class=\"number\">44</span> (mod <span class=\"number\">256</span>)</span><br></pre></td></tr></table></figure>\r\n<h3 id=\"补码加法\">补码加法</h3>\r\n<p>补码加法则是一种计算机中常用的有符号数加法方式。在补码表示中，正数的补码和无符号数的表示相同，而负数的补码是将其对应正数的二进制表示取反后加\r\n1\r\n所得到的二进制数。补码加法与无符号数加法的区别在于，补码加法中，数的范围是从\r\n<span class=\"math inline\">\\(-2^{n-1}\\)</span> 到 <span\r\nclass=\"math inline\">\\(2^{n-1}-1\\)</span>，其中 n\r\n是数的位数。在补码加法中，如果两个数的和超出了这个范围，则会发生溢出。</p>\r\n<p>在补码加法中，当两个数相加时，如果最高位进位了，就会导致溢出，此时计算机会将结果的最高位截断并将其存储在进位标志寄存器中，以便程序员检测是否发生了溢出。</p>\r\n<h3 id=\"有符号数的溢出\">有符号数的溢出</h3>\r\n<p>对于有符号数，溢出有以下两种情况：</p>\r\n<p>正数加正数得到负数，或者负数加负数得到正数。这种情况被称为“符号位溢出”，因为结果的符号与输入操作数的符号不同。这种溢出通常是由于操作数的符号位的进位或借位错误造成的。</p>\r\n<p>两个正数相加得到一个大于等于最大正数，或者两个负数相加得到一个小于等于最小负数。这种情况被称为“数值位溢出”，因为结果的绝对值超出了有符号数的表示范围。这种溢出通常是由于两个操作数的绝对值相加超出了数据类型的范围造成的。</p>\r\n<p>处理这些溢出的方法如下：</p>\r\n<p><strong>符号位溢出</strong>：可以通过在操作数的高位添加一位来检测符号位溢出。当符号位和进位不同时，就发生了符号位溢出。处理符号位溢出的方法包括检查符号位和进位是否相同，并相应地修改结果的符号位。</p>\r\n<p><strong>数值位溢出</strong>：可以通过比较加法的操作数和结果的符号位来检测数值位溢出。如果操作数的符号位相同，但结果的符号位与它们不同，则发生了数值位溢出。处理数值位溢出的方法包括将操作数和结果向上或向下舍入，或者将结果截断为最大或最小值。</p>\r\n<p>在实际应用中，为了避免这些溢出，通常需要进行数据类型检查和数据范围限制，以确保操作数不会超出数据类型的表示范围。此外，在编写代码时，应该尽可能地避免使用可能导致溢出的算术运算。</p>\r\n<h3 id=\"无符号乘法\">无符号乘法</h3>\r\n<p>无符号乘法是指对两个无符号整数进行乘法运算，得到的结果也是一个无符号整数。在无符号乘法中，计算机将两个数按位相乘，然后再将结果相加得到最终的乘积。由于无符号整数没有正负之分，因此无符号乘法不需要考虑进位或溢出的问题。</p>\r\n<p>可以简单地表示无符号乘法的公式如下：</p>\r\n<p><span class=\"math display\">\\[\r\nC = A * B mod 2^ω\r\n\\]</span></p>\r\n<h3 id=\"补码乘法\">补码乘法</h3>\r\n<ol type=\"1\">\r\n<li><p>对无符号和补码乘法，乘法运算的位级表示都是一样的。</p></li>\r\n<li><p>机器使用一种乘法指令来进行有符号和无符号整数的乘法，也就是都采用无符号乘法处理，再取低位。</p></li>\r\n<li><p>无符号和补码的乘法低位是相同的。证明如下：</p></li>\r\n</ol>\r\n<p><img\r\nsrc=\"https://raw.githubusercontent.com/vinouno/blog_image/main/%E8%A1%A5%E7%A0%81%E4%B9%98%E6%B3%95%E8%AF%81%E6%98%8E.jpg\" /></p>\r\n<p>补码乘法的过程主要包括三个步骤：补码表示、乘法运算和结果转换。</p>\r\n<p>下面是补码乘法的详细步骤：</p>\r\n<ol type=\"1\">\r\n<li><p>将两个乘数转换为它们的补码形式。如果乘数是正数，则它们的补码与原码相同；如果乘数是负数，则需要将它们的绝对值转换为二进制补码形式，并将符号位取反，然后再将符号位和数值位组合起来得到补码。</p></li>\r\n<li><p>将两个补码乘起来，得到一个结果的补码。在这个过程中，可以使用常规的乘法算法，将乘数逐位与被乘数相乘，并将结果相加。需要注意的是，结果的位数可能会超过原始数的位数，需要进行适当的位扩展。</p></li>\r\n<li><p>将结果的补码转换为原码。如果结果是正数，则它们的补码与原码相同；如果结果是负数，则需要将它们的绝对值转换为二进制补码形式，并将符号位取反，然后再将符号位和数值位组合起来得到原码。</p></li>\r\n</ol>\r\n<p>举例说明补码乘法：</p>\r\n<figure class=\"highlight dns\"><table><tr><td class=\"code\"><pre><span class=\"line\">          <span class=\"number\">1111 1111</span>        -<span class=\"number\">1</span></span><br><span class=\"line\">       x  <span class=\"number\">1111 1001</span>     x  -<span class=\"number\">7</span></span><br><span class=\"line\">      ----------------    ------</span><br><span class=\"line\">          <span class=\"number\">11111111</span>          <span class=\"number\">7</span></span><br><span class=\"line\">         <span class=\"number\">00000000</span></span><br><span class=\"line\">        <span class=\"number\">00000000</span></span><br><span class=\"line\">       <span class=\"number\">11111111</span></span><br><span class=\"line\">      <span class=\"number\">11111111</span></span><br><span class=\"line\">     <span class=\"number\">11111111</span></span><br><span class=\"line\">    <span class=\"number\">11111111</span></span><br><span class=\"line\">   <span class=\"number\">11111111</span></span><br><span class=\"line\">   ----------------</span><br><span class=\"line\"><span class=\"number\">1</span>  <span class=\"number\">00000000111</span>       ---&gt;  <span class=\"number\">7</span> (notice the Most significant bit is zero)</span><br><span class=\"line\">(last <span class=\"number\">8</span>-bits needed) </span><br></pre></td></tr></table></figure>\r\n<h3 id=\"乘以常数\">乘以常数</h3>\r\n<p>把一个数乘以<span\r\nclass=\"math inline\">\\(2^n\\)</span>,相当于左移n位。</p>\r\n<p>整数乘法运算在大多数机器上都相当慢（10个或者更多的时钟周期），而其他整数运算（加法、减法、位运算和移位）只需要一个时钟周期。</p>\r\n<p>因此许多C语言编译器识图用移位、加法和减法的组合来代替乘法。</p>\r\n<p>例如表达式<span\r\nclass=\"math inline\">\\(x*14=x&lt;&lt;3+x&lt;&lt;2+x&lt;&lt;1\\)</span>，当然更好的办法是<span\r\nclass=\"math inline\">\\(x*14=x&lt;&lt;4-x&lt;&lt;1\\)</span>。</p>\r\n<h3 id=\"除以2的幂\">除以2的幂</h3>\r\n<p>同样地，我们可以用分别用逻辑右移和算术右移代替无符号数和补码的除以2的幂的除法。</p>\r\n<p>逻辑右移的情况下，不需要任何额外的操作。</p>\r\n<p>但是在算术右移的时候，会出现向下取整的情况。当结果是负数的时候，就会出现不合适的舍入。这时候，我们就应该先加上一个偏置值(<span\r\nclass=\"math inline\">\\(2^k - 1\\)</span>)，再进行移位。</p>\r\n<p>测试题：在不使用任何乘除法、模运算、条件语句、比较运算符、循环的情况下，写一个函数，返回整数参数<span\r\nclass=\"math inline\">\\(x/16\\)</span>的值。</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">div16</span><span class=\"params\">(<span class=\"type\">int</span> x)</span>&#123;</span><br><span class=\"line\">   <span class=\"type\">int</span> bias = (x &gt;&gt; <span class=\"number\">31</span>) &amp;<span class=\"number\">0XF</span>;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> (x + bias) &gt;&gt; <span class=\"number\">4</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<h2 id=\"浮点数\">2.4 浮点数</h2>\r\n<p>现实的应用中，需要表示一些非常大的数字或者非常接近0的数字，以及更普遍地作为实数运算的近似值的计算，这是就需要浮点数的表示。</p>\r\n<p>其中IEEE754标准定义的浮点数规则，广泛地被应用。</p>\r\n<h3 id=\"二进制小数\">二进制小数</h3>\r\n<p>在二进制中，不同位置的数字带有<span\r\nclass=\"math inline\">\\(2^n\\)</span>的权，基于同样的原则，我们也能推广到负位置上，不同位置上的数字，也可以代表<span\r\nclass=\"math inline\">\\(\\frac{1}{2}、\\frac{1}{4}\\)</span>等等。</p>\r\n<p>这样的表示方法，就带来一个问题：用有限位数的二进制数表示十进制小数，只能近似地表示（当然，增加二进制数的表示长度，可以提升近似地精度）。</p>\r\n<h3 id=\"ieee浮点表示\">IEEE浮点表示</h3>\r\n<p>IEEE 754是一种常用的标准。它定义了浮点数的表示方法和运算规则。</p>\r\n<h4 id=\"浮点数的组成部分\">浮点数的组成部分</h4>\r\n<p>IEEE\r\n754浮点数由三个主要部分组成：符号位（Sign）、指数位（Exponent）和尾数位（Significand/Mantissa）。每个部分在浮点数的二进制表示中具有特定的意义。</p>\r\n<ul>\r\n<li><p>符号位（Sign）：用于表示浮点数的正负号。0表示正数，1表示负数。</p></li>\r\n<li><p>指数位（Exponent）：表示浮点数的指数部分，用于确定浮点数的数量级。指数位的值采用偏移表示法（移码），其中偏移值为2^(n-1)\r\n- 1，其中n是指数位的位数。</p></li>\r\n<li><p>尾数位（Significand/Mantissa）：表示浮点数的小数部分。尾数位决定了浮点数的精度。</p></li>\r\n</ul>\r\n<p>在单精度浮点数中，三个部分分别占1、8、23位，而在双精度浮点数中，三个部分分别占1、11、52位。</p>\r\n<h4 id=\"规格化与非规格化\">规格化与非规格化</h4>\r\n<ul>\r\n<li><p>规格化值（Normalized\r\nValue）：如果浮点数中指数部分的编码值既不是全0，又不是全1，且在科学表示法的表示方式下，分数\r\n(fraction)\r\n部分最高有效位（即整数字）是1，那么这个浮点数将被称为规约形式的浮点数。“规约”是指用唯一确定的浮点形式去表示一个值。由于这种表示下的尾数有一位隐含的二进制有效数字，为了与二进制科学计数法的尾数（mantissa）相区别，IEEE754称之为有效数（significant）。</p></li>\r\n<li><p>非规格化值（Denormalized\r\nValue）：如果浮点数的指数部分的编码值是0，分数部分非零，那么这个浮点数将被称为非规约形式的浮点数。一般是某个数字相当接近零时才会使用非规约型式来表示。\r\nIEEE\r\n754标准规定：非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值小1。例如，最小的规约形式的单精度浮点数的指数部分编码值为1，指数的实际值为-126；而非规约的单精度浮点数的指数域编码值为0，对应的指数实际值也是-126而不是-127。实际上非规约形式的浮点数仍然是有效可以使用的，只是它们的绝对值已经小于所有的规约浮点数的绝对值；即所有的非规约浮点数比规约浮点数更接近0。规约浮点数的尾数大于等于1且小于2，而非规约浮点数的尾数小于1且大于0。</p></li>\r\n</ul>\r\n<h4 id=\"特殊值\">特殊值</h4>\r\n<p>三个特殊值需要指出：</p>\r\n<ol type=\"1\">\r\n<li>如果指数是0并且尾数的小数部分是0，这个数±0（和符号位相关）</li>\r\n<li>如果指数为<span\r\nclass=\"math inline\">\\(2^e-1\\)</span>并且尾数的小数部分是0，这个数是±∞（同样和符号位相关）</li>\r\n<li>如果指数为<span\r\nclass=\"math inline\">\\(2^e-1\\)</span>并且尾数的小数部分非0，这个数表示为非数（NaN）。</li>\r\n</ol>\r\n<h4 id=\"总结\">总结</h4>\r\n<p>总结以上所有的情况：</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>形式</th>\r\n<th>指数</th>\r\n<th>小数部分</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>零</td>\r\n<td>0</td>\r\n<td>0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>非规约形式</td>\r\n<td>0</td>\r\n<td>大于0小于1</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>规约形式</td>\r\n<td>1到2^(e)-2</td>\r\n<td>大于等于1小于2</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>无穷</td>\r\n<td>2^(e)-1</td>\r\n<td>0</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>NaN</td>\r\n<td>2^(e)-1</td>\r\n<td>非0</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>单精度浮点数各种极值情况：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 11%\" />\r\n<col style=\"width: 5%\" />\r\n<col style=\"width: 6%\" />\r\n<col style=\"width: 8%\" />\r\n<col style=\"width: 11%\" />\r\n<col style=\"width: 26%\" />\r\n<col style=\"width: 30%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>类别</th>\r\n<th>正负号</th>\r\n<th>实际指数</th>\r\n<th>有偏移指数</th>\r\n<th>指数域</th>\r\n<th>尾数域</th>\r\n<th>数值</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>零</td>\r\n<td>0</td>\r\n<td>-127</td>\r\n<td>0</td>\r\n<td>0000 0000</td>\r\n<td>000 0000 0000 0000 0000 0000</td>\r\n<td>0.0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>负零</td>\r\n<td>1</td>\r\n<td>-127</td>\r\n<td>0</td>\r\n<td>0000 0000</td>\r\n<td>000 0000 0000 0000 0000 0000</td>\r\n<td>-0.0</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>1</td>\r\n<td>0</td>\r\n<td>0</td>\r\n<td>127</td>\r\n<td>0111 1111</td>\r\n<td>000 0000 0000 0000 0000 0000</td>\r\n<td>1.0</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>-1</td>\r\n<td>1</td>\r\n<td>0</td>\r\n<td>127</td>\r\n<td>0111 1111</td>\r\n<td>000 0000 0000 0000 0000 0000</td>\r\n<td>-1.0</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>最小的非规约数</td>\r\n<td>*</td>\r\n<td>-126</td>\r\n<td>0</td>\r\n<td>0000 0000</td>\r\n<td>000 0000 0000 0000 0000 0001</td>\r\n<td>±2^-23 × 2^-126 ≈ ±2^-149 ≈ ±1.4×10^-45</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>中间大小的非规约数</td>\r\n<td>*</td>\r\n<td>-126</td>\r\n<td>0</td>\r\n<td>0000 0000</td>\r\n<td>100 0000 0000 0000 0000 0000</td>\r\n<td>±2^-1 × 2^-126 ≈ ±2^-127 ≈ ±5.88×10^-39</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>最大的非规约数</td>\r\n<td>*</td>\r\n<td>-126</td>\r\n<td>0</td>\r\n<td>0000 0000</td>\r\n<td>111 1111 1111 1111 1111 1111</td>\r\n<td>±(1-2^-23) × 2^-126 ≈ ±1.18×10^-38</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>最小的规约数</td>\r\n<td>*</td>\r\n<td>-126</td>\r\n<td>1</td>\r\n<td>0000 0001</td>\r\n<td>000 0000 0000 0000 0000 0000</td>\r\n<td>±2^-126 ≈ ±1.18×10^-38</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>最大的规约数</td>\r\n<td>*</td>\r\n<td>127</td>\r\n<td>254</td>\r\n<td>1111 1110</td>\r\n<td>111 1111 1111 1111 1111 1111</td>\r\n<td>±(2<sup>-2</sup>-23) × 2^127 ≈ ±3.4×10^38</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>正无穷</td>\r\n<td>0</td>\r\n<td>128</td>\r\n<td>255</td>\r\n<td>1111 1111</td>\r\n<td>000 0000 0000 0000 0000 0000</td>\r\n<td>+∞</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>负无穷</td>\r\n<td>1</td>\r\n<td>128</td>\r\n<td>255</td>\r\n<td>1111 1111</td>\r\n<td>000 0000 0000 0000 0000 0000</td>\r\n<td>-∞</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>NaN</td>\r\n<td>*</td>\r\n<td>128</td>\r\n<td>255</td>\r\n<td>1111 1111</td>\r\n<td>非全0</td>\r\n<td>NaN</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"浮点数的舍入\">浮点数的舍入</h3>\r\n<p>任何有效数上的运算结果，通常都存放在较长的寄存器中，当结果被放回浮点格式时，必须将多出来的比特丢弃。\r\n有多种方法可以用来执行舍入作业，实际上IEEE标准列出4种不同的方法：</p>\r\n<ul>\r\n<li>舍入到最接近：舍入到最接近，在一样接近的情况下偶数优先（Ties To\r\nEven，这是默认的舍入方式）：会将结果舍入为最接近且可以表示的值，但是当存在两个数一样接近的时候，则取其中的偶数（在二进制中是以0结尾的）。</li>\r\n<li>朝+∞方向舍入：会将结果朝正无限大的方向舍入。</li>\r\n<li>朝-∞方向舍入：会将结果朝负无限大的方向舍入。</li>\r\n<li>朝0方向舍入：会将结果朝0的方向舍入。</li>\r\n</ul>\r\n<h3 id=\"浮点数的运算性质\">浮点数的运算性质</h3>\r\n<p>浮点数的运算不遵循结合性和分配性。</p>\r\n","categories":["CSAPP"],"tags":["CSAPP","C语言","二进制","补码","浮点数"]},{"title":"C++中的STL无序（哈希）容器","url":"/posts/99013716/","content":"<h1 id=\"常见的三种哈希结构\">常见的三种哈希结构</h1>\r\n<p>当我们想使用哈希法来解决问题的时候，我们一般会选择如下三种数据结构。</p>\r\n<ul>\r\n<li>数组</li>\r\n<li>set（集合）</li>\r\n<li>map (映射)</li>\r\n</ul>\r\n<p>这里数组就没啥可说的了，我们来看一下set。</p>\r\n<p>在C++中，set 和 map\r\n分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p>\r\n<table style=\"width:100%;\">\r\n<colgroup>\r\n<col style=\"width: 14%\" />\r\n<col style=\"width: 14%\" />\r\n<col style=\"width: 14%\" />\r\n<col style=\"width: 14%\" />\r\n<col style=\"width: 14%\" />\r\n<col style=\"width: 14%\" />\r\n<col style=\"width: 14%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">集合</th>\r\n<th style=\"text-align: center;\">底层实现</th>\r\n<th style=\"text-align: center;\">是否有序</th>\r\n<th style=\"text-align: center;\">数值是否可以重复</th>\r\n<th style=\"text-align: center;\">能否更改数值</th>\r\n<th style=\"text-align: center;\">查询效率</th>\r\n<th style=\"text-align: center;\">增删效率</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">std::set</td>\r\n<td style=\"text-align: center;\">红黑树</td>\r\n<td style=\"text-align: center;\">有序</td>\r\n<td style=\"text-align: center;\">否</td>\r\n<td style=\"text-align: center;\">否</td>\r\n<td style=\"text-align: center;\">O(log n)</td>\r\n<td style=\"text-align: center;\">O(log n)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">std::multiset</td>\r\n<td style=\"text-align: center;\">红黑树</td>\r\n<td style=\"text-align: center;\">有序</td>\r\n<td style=\"text-align: center;\">是</td>\r\n<td style=\"text-align: center;\">否</td>\r\n<td style=\"text-align: center;\">O(log n)</td>\r\n<td style=\"text-align: center;\">O(log n)</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">std::unordered_set</td>\r\n<td style=\"text-align: center;\">哈希表</td>\r\n<td style=\"text-align: center;\">无序</td>\r\n<td style=\"text-align: center;\">否</td>\r\n<td style=\"text-align: center;\">否</td>\r\n<td style=\"text-align: center;\">O(1)</td>\r\n<td style=\"text-align: center;\">O(1)</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>std::unordered_set底层实现为哈希表，std::set 和std::multiset\r\n的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p>\r\n<table style=\"width:100%;\">\r\n<colgroup>\r\n<col style=\"width: 14%\" />\r\n<col style=\"width: 14%\" />\r\n<col style=\"width: 14%\" />\r\n<col style=\"width: 14%\" />\r\n<col style=\"width: 14%\" />\r\n<col style=\"width: 14%\" />\r\n<col style=\"width: 14%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\">集合</th>\r\n<th style=\"text-align: center;\">底层实现</th>\r\n<th style=\"text-align: center;\">是否有序</th>\r\n<th style=\"text-align: center;\">数值是否可以重复</th>\r\n<th style=\"text-align: center;\">能否更改数值</th>\r\n<th style=\"text-align: center;\">查询效率</th>\r\n<th style=\"text-align: center;\">增删效率</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">std::map</td>\r\n<td style=\"text-align: center;\">红黑树</td>\r\n<td style=\"text-align: center;\">key有序</td>\r\n<td style=\"text-align: center;\">key不可重复</td>\r\n<td style=\"text-align: center;\">key不可修改</td>\r\n<td style=\"text-align: center;\">O(log n)</td>\r\n<td style=\"text-align: center;\">O(log n)</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">std::multimap</td>\r\n<td style=\"text-align: center;\">红黑树</td>\r\n<td style=\"text-align: center;\">key有序</td>\r\n<td style=\"text-align: center;\">key可重复</td>\r\n<td style=\"text-align: center;\">key可修改</td>\r\n<td style=\"text-align: center;\">O(log n)</td>\r\n<td style=\"text-align: center;\">O(log n)</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">std::unordered_map</td>\r\n<td style=\"text-align: center;\">哈希表</td>\r\n<td style=\"text-align: center;\">key无序</td>\r\n<td style=\"text-align: center;\">key不可重复</td>\r\n<td style=\"text-align: center;\">key不可修改</td>\r\n<td style=\"text-align: center;\">O(1)</td>\r\n<td style=\"text-align: center;\">O(1)</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap\r\n的底层实现是红黑树。同理，std::map 和std::multimap\r\n的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p>\r\n<p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p>\r\n<p>那么再来看一下map ，在map 是一个key value\r\n的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。</p>\r\n<p>其他语言例如：java里的HashMap ，TreeMap\r\n都是一样的原理。可以灵活贯通。</p>\r\n<p>虽然std::set、std::multiset\r\n的底层实现是红黑树，不是哈希表，std::set、std::multiset\r\n使用红黑树来索引和存储，不过给我们的使用方式，还是哈希法的使用方式，即key和value。所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。\r\nmap也是一样的道理。</p>\r\n<p>这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set\r\nhash_map，这个与unordered_set，unordered_map又有什么关系呢？</p>\r\n<p>实际上功能都是一样一样的，\r\n但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map\r\n是C++11标准之前民间高手自发造的轮子。</p>\r\n","categories":["算法笔记"],"tags":["哈希","C++","STL"]},{"title":"ChatGPT关于LeetCode的问答","url":"/posts/2813fea9/","content":"<h1\r\nid=\"q如果想要全部答出周赛问题那么要做哪些种类的题目\">Q：如果想要全部答出周赛问题，那么要做哪些种类的题目？</h1>\r\n<p>A：要想答出所有 LeetCode\r\n周赛题目，你需要具备良好的编程基础知识和一定的数据结构和算法的理解。此外，下面几种题目类型也是很有必要练习的：</p>\r\n<ul>\r\n<li><p>数组和字符串问题：对于这类问题，需要对字符串或数组进行遍历，并对其进行处理，如反转字符串，查找最长不重复子串等。</p></li>\r\n<li><p>数学问题：这类问题通常涉及到简单的数学计算，如求最大公因数，最小公倍数，数学归纳等。</p></li>\r\n<li><p>树和图问题：树和图是经典的数据结构问题，如二叉树遍历，最短路径，图的拓扑排序等。</p></li>\r\n<li><p>动态规划问题：动态规划是一种通过将复杂问题分解为若干个子问题并记录子问题的解，从而得到原问题的解的方法。</p></li>\r\n<li><p>贪心算法问题：贪心算法是通过在每一步选择最佳决策来寻找全局最优解的一种方法。</p></li>\r\n</ul>\r\n<h1\r\nid=\"qleetcode周赛中频率最高的几种问题分别是什么\">Q：LeetCode周赛中频率最高的几种问题分别是什么？</h1>\r\n<p>A: LeetCode 周赛中频率最高的问题类型通常包括：</p>\r\n<ul>\r\n<li><p>数组和字符串：这类问题包括对数组和字符串的操作，例如排序、搜索、反转、拼接等。</p></li>\r\n<li><p>数学：这类问题包括数学算法，例如最大公约数、最小公倍数、素数等。</p></li>\r\n<li><p>链表：这类问题包括对链表的操作，例如遍历、删除节点、反转等。</p></li>\r\n<li><p>树：这类问题包括对树的操作，例如遍历、查找、插入等。</p></li>\r\n<li><p>图：这类问题包括图的遍历、最短路径等。</p></li>\r\n<li><p>动态规划：这类问题包括动态规划算法，例如最长公共子序列、最长上升子序列等。</p></li>\r\n<li><p>贪心：这类问题包括贪心算法，例如选择排列、最优解等。</p></li>\r\n</ul>\r\n<p>以上是 LeetCode\r\n周赛中频率最高的问题类型，不同的周赛可能会有所不同。因此，为了全部答对周赛问题，最好涵盖多个算法类型和数据结构，并对这些算法进行充分的练习。</p>\r\n","categories":["算法笔记"],"tags":["ChatGPT","LeetCode周赛"]},{"title":"二分查找的模板与边界问题","url":"/posts/864a13af/","content":"<h1 id=\"二分查找的模板与边界问题\">二分查找的模板与边界问题</h1>\r\n<p>二分查找有两套模板，模板A代码如下：</p>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bsearch_1</span><span class=\"params\">(<span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l &lt; r)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l + r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">check</span>(mid)) r = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>模板B代码如下： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">bsearch_2</span><span class=\"params\">(<span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (l &lt; r)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> mid = (l + r + <span class=\"number\">1</span>) /<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"built_in\">check</span>(mid)) l = mid;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> r = mid - <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\r\n<h2 id=\"两套代码有什么区别\">两套代码有什么区别</h2>\r\n<ul>\r\n<li>模板A区间[l,r]划分成[l,mid]和[mid+1,r],更新操作是<code>r=mid</code>或者<code>l=mid+1</code>，计算mid时不需要加1，即<code>mid=(l+r)/2</code>。</li>\r\n<li>模板B区间[l,r]划分成[l,mid-1]和[mid,r],更新操作是<code>r=mid-1</code>或者<code>l=mid</code>，计算mid时不需要加1，即<code>mid=(l+r+1)/2</code>。</li>\r\n</ul>\r\n<h2\r\nid=\"为什么使用两套模板的mid计算方法不同\">为什么使用两套模板的mid计算方法不同？</h2>\r\n<p>当使用模板B时，会有以下这种特殊情况：<code>r=l+1</code>。此时，如果使用<code>mid=(l+r)/2</code>，向下取整，使得<code>mid=l</code>，从而形成无限循环。</p>\r\n<h2\r\nid=\"什么时候用模板a什么时候用模板b\">什么时候用模板A？什么时候用模板B？</h2>\r\n<p>左边界要更新为<code>l=mid+1</code>,使用模板A。\r\n左边界要更新为<code>l=mid</code>，则使用模板B。</p>\r\n<h2 id=\"数据溢出怎么办\">数据溢出怎么办？</h2>\r\n<p>把mid的计算方式更改为<code>mid=l+((r-l)/2)</code>。</p>\r\n<h2 id=\"example\">Example</h2>\r\n<p>你现在已经完全掌握二分查找了，快来试试看吧：<a\r\nhref=\"https://leetcode.cn/problems/search-in-rotated-sorted-array/\">leetcode-33.\r\n搜索旋转排序数组</a> 示例代码： <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">search</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> target)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//使用模板A，找到旋转点，用p储存之</span></span><br><span class=\"line\">        <span class=\"type\">int</span> l = <span class=\"number\">0</span>, r = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = (l + r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &lt; nums[r]) </span><br><span class=\"line\">            r = mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;       </span><br><span class=\"line\">        <span class=\"type\">int</span> p = l;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//[0,p]为有序数组，使用模板A二分查找</span></span><br><span class=\"line\">        r = p - <span class=\"number\">1</span>, l = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = (l + r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &gt;= target) </span><br><span class=\"line\">            r = mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[l] == target)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//p之后为有序数组，使用模板A二分查找</span></span><br><span class=\"line\">        l = p, r = nums.<span class=\"built_in\">size</span>() - <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l &lt; r)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> mid = (l + r)/<span class=\"number\">2</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[mid] &gt;= target) </span><br><span class=\"line\">            r = mid;</span><br><span class=\"line\">            <span class=\"keyword\">else</span> l = mid + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(nums[l] == target)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> l;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n","categories":["算法笔记"],"tags":["数组","二分查找"]},{"title":"CSAPP 第三章：程序的机器级表示","url":"/posts/adc3eca/","content":"<h1 id=\"csapp-第三章程序的机器级表示\">CSAPP\r\n第三章：程序的机器级表示</h1>\r\n<h2 id=\"历史观点\">3.1 历史观点</h2>\r\n<h3 id=\"摩尔定律\">摩尔定律</h3>\r\n<p>摩尔定律（Moore's\r\nLaw：是由英特尔公司的联合创始人之一戈登·摩尔（Gordon\r\nMoore）在1965年提出的经验观察和预测。摩尔定律指出，集成电路上可容纳的晶体管数量每隔约18个月翻倍，同时造价减半。换句话说，摩尔定律认为集成电路的性能将以指数级增长，而成本则将相对下降。</p>\r\n<p>摩尔定律的观察基础是在集成电路中使用的晶体管数量和密度不断增加，这使得处理器的速度和性能也在不断提高。这一观察发展为一个准则，成为计算机硬件行业的重要指导原则。</p>\r\n<p>摩尔定律的实际效应是，在相同的芯片面积上，可以集成更多的晶体管，从而提高处理器的性能。这使得计算机和其他电子设备变得更快、更小、更强大，并带来了信息技术的快速发展。</p>\r\n<h3 id=\"x86和x86-64\">X86和X86-64</h3>\r\n<p>x86是一种32位的处理器架构，最初由英特尔（Intel）开发并推广。它是基于英特尔的8086和8088处理器设计的，并成为个人电脑（PC）中最为广泛使用的架构之一。x86架构支持32位寻址和32位数据处理，其指令集和寄存器设计是基于32位的。</p>\r\n<p>x86-64（也称为AMD64或x64）是x86架构的64位扩展。它由AMD首先引入，并得到了其他处理器制造商的采纳，包括英特尔。x86-64架构扩展了x86的寻址空间和寄存器大小，支持64位寻址和64位数据处理。这使得x86-64处理器能够处理更大的内存地址空间和执行更复杂的计算任务。与传统的32位x86架构相比，x86-64架构在处理器性能和内存管理方面有显著的优势。</p>\r\n<p>x86-64架构是目前个人电脑和服务器领域最为广泛使用的处理器架构之一。它支持运行32位和64位的操作系统和应用程序，提供了更高的性能和更大的灵活性。许多现代操作系统和软件都提供了针对x86-64架构的优化版本，以充分利用其性能和功能。</p>\r\n<h2 id=\"程序编码\">3.2 程序编码</h2>\r\n<h3 id=\"汇编过程\">汇编过程</h3>\r\n<p>编译C语言程序的过程：</p>\r\n<ol type=\"1\">\r\n<li><p>预处理（Preprocessing）：编译器对源代码进行预处理，包括宏展开、头文件包含等操作。预处理器可以根据#include指令将其他文件的内容插入源文件中，并对宏进行替换。</p></li>\r\n<li><p>编译（Compilation）：编译器将预处理后的源代码转换为汇编代码（Assembly\r\nCode），即将C语言的代码转换为机器可以理解的低级指令。</p></li>\r\n<li><p>汇编（Assembly）：汇编器将汇编代码转换为机器码，即可执行的二进制指令。汇编器将每条汇编指令翻译成对应的机器指令，并生成目标文件（Object\r\nFile）。</p></li>\r\n<li><p>链接（Linking）：链接器将目标文件与所需的库文件进行链接，生成最终的可执行文件（Executable\r\nFile）。链接器将目标文件中的函数和变量引用与其定义进行匹配，解析符号引用，并将它们关联起来。</p></li>\r\n</ol>\r\n<h3 id=\"attatt和intel的语法区别\">ATT（AT&amp;T）和Intel的语法区别</h3>\r\n<p>ATT（AT&amp;T）和Intel是两种不同的汇编语法格式，它们主要在语法结构和指令书写上存在一些区别。</p>\r\n<ol type=\"1\">\r\n<li>语法结构：\r\n<ul>\r\n<li>ATT语法：源操作数在前，目的操作数在后，使用逗号分隔。例如：<code>movl %eax, %ebx</code>。</li>\r\n<li>Intel语法：目的操作数在前，源操作数在后，使用逗号分隔。例如：<code>mov ebx, eax</code>。</li>\r\n</ul></li>\r\n<li>寄存器命名：\r\n<ul>\r\n<li>ATT语法：寄存器名称以<code>%</code>开头。例如：<code>%eax</code>。</li>\r\n<li>Intel语法：寄存器名称没有特殊的符号前缀。例如：<code>eax</code>。</li>\r\n</ul></li>\r\n<li>立即数和内存引用：\r\n<ul>\r\n<li>ATT语法：立即数使用<code>$</code>符号表示，内存引用使用括号表示。例如：<code>movl $10, %eax</code>（将立即数10移动到eax寄存器）；<code>movl (%ebx), %eax</code>（将ebx寄存器指向的内存地址的值移动到eax寄存器）。</li>\r\n<li>Intel语法：立即数没有特殊符号表示，内存引用使用方括号表示。例如：<code>mov eax, 10</code>（将立即数10移动到eax寄存器）；<code>mov eax, [ebx]</code>（将ebx寄存器指向的内存地址的值移动到eax寄存器）。</li>\r\n</ul></li>\r\n<li>操作数大小：\r\n<ul>\r\n<li>ATT语法：根据操作数的大小，使用不同的后缀来表示，如<code>b</code>表示字节（byte），<code>w</code>表示字（word），<code>l</code>表示双字（double\r\nword）。例如：<code>movb $1, %al</code>（将立即数1移动到al寄存器，al为8位寄存器）。</li>\r\n<li>Intel语法：操作数的大小根据指令而定，不需要显式指定后缀。例如：<code>mov al, 1</code>（将立即数1移动到al寄存器，al为8位寄存器）。</li>\r\n</ul></li>\r\n</ol>\r\n<p>需要注意的是，不同的汇编器可能支持不同的语法格式，默认使用的是特定的汇编语法。在使用汇编语言时，应根据所选的语法格式编写相应的汇编代码。</p>\r\n<h2 id=\"数据格式\">3.3 数据格式</h2>\r\n<p>下面是常见的C语言数据类型在x86-64架构中的Intel数据类型、汇编代码后缀和大小（以字节为单位）的表格：</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>C数据类型</th>\r\n<th>Intel数据类型</th>\r\n<th>汇编代码后缀</th>\r\n<th>大小（字节）</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>char</td>\r\n<td>BYTE</td>\r\n<td>b</td>\r\n<td>1</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>short</td>\r\n<td>WORD</td>\r\n<td>w</td>\r\n<td>2</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>int</td>\r\n<td>DWORD</td>\r\n<td>l</td>\r\n<td>4</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>long</td>\r\n<td>QWORD</td>\r\n<td>q</td>\r\n<td>8</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>long long</td>\r\n<td>QWORD</td>\r\n<td>q</td>\r\n<td>8</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>float</td>\r\n<td>DWORD</td>\r\n<td>s</td>\r\n<td>4</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>double</td>\r\n<td>QWORD</td>\r\n<td>l</td>\r\n<td>8</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"访问信息\">3.4 访问信息</h2>\r\n<h3 id=\"x86-64中的整数寄存器\">X86-64中的整数寄存器</h3>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 7%\" />\r\n<col style=\"width: 7%\" />\r\n<col style=\"width: 7%\" />\r\n<col style=\"width: 8%\" />\r\n<col style=\"width: 20%\" />\r\n<col style=\"width: 48%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>64位</th>\r\n<th>32位</th>\r\n<th>16位</th>\r\n<th>8位</th>\r\n<th>名称</th>\r\n<th>作用</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>%rax</td>\r\n<td>%eax</td>\r\n<td>%ax</td>\r\n<td>%al</td>\r\n<td>返回值寄存器</td>\r\n<td>存放函数返回值</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>%rbx</td>\r\n<td>%ebx</td>\r\n<td>%bx</td>\r\n<td>%bl</td>\r\n<td>数据寄存器</td>\r\n<td>被调用者保存</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>%rcx</td>\r\n<td>%ecx</td>\r\n<td>%cx</td>\r\n<td>%cl</td>\r\n<td>第4个参数寄存器</td>\r\n<td>用于存放第4个函数参数</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>%rdx</td>\r\n<td>%edx</td>\r\n<td>%dx</td>\r\n<td>%dl</td>\r\n<td>第3个参数寄存器</td>\r\n<td>用于存放第3个函数参数</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>%rsi</td>\r\n<td>%esi</td>\r\n<td>%si</td>\r\n<td>%sil</td>\r\n<td>第2个参数寄存器</td>\r\n<td>用于存放第2个函数参数</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>%rdi</td>\r\n<td>%edi</td>\r\n<td>%di</td>\r\n<td>%dil</td>\r\n<td>第1个参数寄存器</td>\r\n<td>用于存放第1个函数参数</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>%rbp</td>\r\n<td>%ebp</td>\r\n<td>%bp</td>\r\n<td>%bpl</td>\r\n<td>基址指针寄存器</td>\r\n<td>被调用者保存</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>%rsp</td>\r\n<td>%esp</td>\r\n<td>%sp</td>\r\n<td>%spl</td>\r\n<td>栈指针寄存器</td>\r\n<td>用于指向栈顶位置</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>%r8</td>\r\n<td>%r8d</td>\r\n<td>%r8w</td>\r\n<td>%r8b</td>\r\n<td>第5个参数寄存器</td>\r\n<td>用于存放第5个函数参数</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>%r9</td>\r\n<td>%r9d</td>\r\n<td>%r9w</td>\r\n<td>%r9b</td>\r\n<td>第6个参数寄存器</td>\r\n<td>用于存放第6个函数参数</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>%r10</td>\r\n<td>%r10d</td>\r\n<td>%r10w</td>\r\n<td>%r10b</td>\r\n<td>附加寄存器</td>\r\n<td>调用者保存</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>%r11</td>\r\n<td>%r11d</td>\r\n<td>%r11w</td>\r\n<td>%r11b</td>\r\n<td>附加寄存器</td>\r\n<td>调用者保存</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>%r12</td>\r\n<td>%r12d</td>\r\n<td>%r12w</td>\r\n<td>%r12b</td>\r\n<td>数据寄存器</td>\r\n<td>被调用者保存</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>%r13</td>\r\n<td>%r13d</td>\r\n<td>%r13w</td>\r\n<td>%r13b</td>\r\n<td>数据寄存器</td>\r\n<td>被调用者保存</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>%r14</td>\r\n<td>%r14d</td>\r\n<td>%r14w</td>\r\n<td>%r14b</td>\r\n<td>数据寄存器</td>\r\n<td>被调用者保存</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>%r15</td>\r\n<td>%r15d</td>\r\n<td>%r15w</td>\r\n<td>%r15b</td>\r\n<td>数据寄存器</td>\r\n<td>被调用者保存</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"操作数指示符\">操作数指示符</h3>\r\n<p>下面是一个关于操作数格式的表格示例，使用ATT格式的汇编代码：</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>类型</th>\r\n<th>格式</th>\r\n<th>操作数值</th>\r\n<th>名称</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>立即数</td>\r\n<td>立即值</td>\r\n<td>$42</td>\r\n<td>立即数42</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>寄存器</td>\r\n<td>寄存器名</td>\r\n<td>%eax</td>\r\n<td>通用寄存器</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>寄存器</td>\r\n<td>内存引用</td>\r\n<td>(%ebx)</td>\r\n<td>寄存器间接寻址</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>寄存器</td>\r\n<td>寄存器+偏移</td>\r\n<td>12(%ecx)</td>\r\n<td>寄存器偏移寻址</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>寄存器</td>\r\n<td>寄存器+立即值</td>\r\n<td>0x1234(%edx)</td>\r\n<td>立即值偏移寻址</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>存储器</td>\r\n<td>基址(, 索引)</td>\r\n<td>(%ebx, %esi)</td>\r\n<td>基址索引寻址</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>存储器</td>\r\n<td>基址(, , 缩放因子)</td>\r\n<td>(%ecx,,8)</td>\r\n<td>变址寻址</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"数据传输指令\">数据传输指令</h3>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>指令</th>\r\n<th>描述</th>\r\n<th>数据大小</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>movb</td>\r\n<td>传输一个字节大小的数据</td>\r\n<td>8位</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>movw</td>\r\n<td>传输一个字（16位）大小的数据</td>\r\n<td>16位</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>movl</td>\r\n<td>传输一个双字（32位）大小的数据</td>\r\n<td>32位</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>movq</td>\r\n<td>传输一个四字（64位）大小的数据</td>\r\n<td>64位</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>movzbw</td>\r\n<td>将无符号字节数据拓展为字大小</td>\r\n<td>8位拓展为16位</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>movsbw</td>\r\n<td>将有符号字节数据拓展为字大小</td>\r\n<td>8位拓展为16位</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>在x86-64架构的汇编语言中，movl指令会将32位数据的低32位复制到目的操作数的低32位，并将目的操作数的高32位清零。</p>\r\n<p>movz指令将无符号字节数据拓展为字大小，填充零位；movs指令将有符号字节数据拓展为字大小，保持符号位不变。</p>\r\n<h3 id=\"压入和弹出栈数据\">压入和弹出栈数据</h3>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 6%\" />\r\n<col style=\"width: 23%\" />\r\n<col style=\"width: 70%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>指令</th>\r\n<th>效果</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>pushq</td>\r\n<td>将值压入栈顶</td>\r\n<td>该指令将给定的源操作数的值压入栈顶，并将栈指针减小8个字节（根据操作数的大小）</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>popq</td>\r\n<td>将值从栈顶弹出</td>\r\n<td>该指令将栈顶的值弹出，并将栈指针增加8个字节（根据操作数的大小），并将值存储到目的操作数中</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>这些指令用于栈的操作，栈是一个后进先出（LIFO）的数据结构。在x86-64汇编语言中，栈被广泛用于函数调用、局部变量存储和寄存器保存等任务。</p>\r\n<p>使用pushq指令时，要指定要推入栈顶的操作数，可以是寄存器、内存位置或立即数。例如，<code>pushq %rax</code>\r\n将将寄存器 %rax 的值压入栈顶。</p>\r\n<p>使用popq指令时，要指定从栈顶弹出的目的操作数，可以是寄存器或内存位置。例如，<code>popq %rbx</code>\r\n将从栈顶弹出一个值，并将其存储到寄存器 %rbx。</p>\r\n<p>这些指令对栈指针进行相应的调整，以确保栈的正确管理（可以发现，栈是倒过来的）。在使用这些指令时，需要注意栈的正确使用，以避免栈溢出或栈指针错误的情况。</p>\r\n<h2 id=\"算术逻辑操作\">3.5 算术逻辑操作</h2>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 5%\" />\r\n<col style=\"width: 18%\" />\r\n<col style=\"width: 76%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>指令</th>\r\n<th>效果</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>leaq</td>\r\n<td>计算有效地址</td>\r\n<td>将源操作数的内存地址计算并存储到目的操作数中</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>inc</td>\r\n<td>增加操作数的值</td>\r\n<td>将源操作数的值增加1，结果存储到目的操作数中</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>dec</td>\r\n<td>减少操作数的值</td>\r\n<td>将源操作数的值减少1，结果存储到目的操作数中</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>neg</td>\r\n<td>取反操作数的值</td>\r\n<td>将源操作数的值取反（取负），结果存储到目的操作数中</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>not</td>\r\n<td>取反操作数的位</td>\r\n<td>将源操作数的位取反，结果存储到目的操作数中</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>add</td>\r\n<td>加法操作</td>\r\n<td>将源操作数的值与目的操作数相加，结果存储到目的操作数中</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>sub</td>\r\n<td>减法操作</td>\r\n<td>将源操作数的值与目的操作数相减，结果存储到目的操作数中</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>imul</td>\r\n<td>有符号乘法操作</td>\r\n<td>将源操作数与目的操作数进行有符号乘法运算，结果存储到目的操作数中</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>xor</td>\r\n<td>异或操作</td>\r\n<td>将源操作数与目的操作数进行按位异或运算，结果存储到目的操作数中</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>or</td>\r\n<td>或操作</td>\r\n<td>将源操作数与目的操作数进行按位或运算，结果存储到目的操作数中</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>and</td>\r\n<td>与操作</td>\r\n<td>将源操作数与目的操作数进行按位与运算，结果存储到目的操作数中</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>sal</td>\r\n<td>左移算术（带符号）</td>\r\n<td>将源操作数的位向左移动指定的位数，空位用0填充，结果存储到目的操作数中（带符号左移）</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>shl</td>\r\n<td>左移逻辑（无符号）</td>\r\n<td>将源操作数的位向左移动指定的位数，空位用0填充，结果存储到目的操作数中（无符号左移）</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>sar</td>\r\n<td>右移算术（带符号）</td>\r\n<td>将源操作数的位向右移动指定的位数，空位用符号位填充，结果存储到目的操作数中（带符号右移）</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>shr</td>\r\n<td>右移逻辑（无符号）</td>\r\n<td>将源操作数的位向右移动指定的位数，空位用0填充，结果存储到目的操作数中（无符号右移）</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h3 id=\"加载有效地址\">加载有效地址</h3>\r\n<p>leaq和movq基本等同，但是目的数必须是寄存器。</p>\r\n<p>leaq可以用来做一些巧妙的操作，但是往往这和设计用途无关。</p>\r\n<h3 id=\"一元和二元操作\">一元和二元操作</h3>\r\n<p>一元操作的源和目的是同一个数。</p>\r\n<p>二元操作的源操作数是第一个，目的操作数是第二个。</p>\r\n<p>例如 subq %rax,%rdx是使%rdx的值变为%rdx减去%rax的值。</p>\r\n<h3 id=\"移位操作\">移位操作</h3>\r\n<p>左移指令有两个名字：SAl和SHL。两者的效果是一样的。，都是在右面填上0。</p>\r\n<p>右移指令在x86汇编语言中，SAR和SHR指令的不同字母来自以下单词：</p>\r\n<p>SAR：Shift Arithmetic Right（算术右移） SHR：Shift Logical\r\nRight（逻辑右移）</p>\r\n<p>移位量可以是一个立即数，也可以放在单字节寄存器%cl中。</p>\r\n<h3 id=\"特殊的算术操作\">特殊的算术操作</h3>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 6%\" />\r\n<col style=\"width: 25%\" />\r\n<col style=\"width: 68%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>指令</th>\r\n<th>效果</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>imulq</td>\r\n<td>有符号乘法操作（四字节）</td>\r\n<td>将源操作数与目的操作数进行有符号乘法运算，结果存储到目的操作数中</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>mulq</td>\r\n<td>无符号乘法操作（四字节）</td>\r\n<td>将源操作数与目的操作数进行无符号乘法运算，结果存储到目的操作数中</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>cqto</td>\r\n<td>扩展符号位（四字节到八字节）</td>\r\n<td>将四字节的有符号值扩展到八字节，并存储到目的操作数中（对于imulq和divq指令的操作准备）</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>idivq</td>\r\n<td>有符号除法操作（四字节）</td>\r\n<td>将目的操作数除以源操作数，商存储到目的操作数中，余数存储到%rdx寄存器中</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td>divq</td>\r\n<td>无符号除法操作（四字节）</td>\r\n<td>将目的操作数除以源操作数，商存储到目的操作数中，余数存储到%rdx寄存器中</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>对于imulq指令，当只使用一个操作数时，它会将源操作数与目的操作数（即%rax寄存器）进行有符号乘法运算，并将结果存储在%rdx:%rax寄存器对中。这个寄存器对存储了64位结果，其中高32位存储在%rdx寄存器中，低32位存储在%rax寄存器中。</p>\r\n<h2 id=\"控制\">3.6 控制</h2>\r\n<p>有时需要有条件的执行，数据决定指令执行的顺序，这时就要使用jump指令改变执行顺序。</p>\r\n<h3 id=\"条件码\">条件码</h3>\r\n<p>条件码是指在计算机体系结构中用于记录运算结果状态的一组标志位。常见的条件码包括进位标志（Carry\r\nFlag，CF）、零标志（Zero Flag，ZF）、符号标志（Sign\r\nFlag，SF）和溢出标志（Overflow Flag，OF）。</p>\r\n<ol type=\"1\">\r\n<li>进位标志（CF）：\r\n<ul>\r\n<li>用途：记录算术和逻辑运算中的进位或借位情况。</li>\r\n<li>设置条件：当无符号数相加产生进位，或者无符号数相减产生借位时，CF被设置为1；否则，CF被设置为0。</li>\r\n</ul></li>\r\n<li>零标志（ZF）：\r\n<ul>\r\n<li>用途：记录运算结果是否为零。</li>\r\n<li>设置条件：当运算结果为零时，ZF被设置为1；否则，ZF被设置为0。</li>\r\n</ul></li>\r\n<li>符号标志（SF）：\r\n<ul>\r\n<li>用途：记录运算结果的符号。</li>\r\n<li>设置条件：当运算结果为负数时，SF被设置为1；当运算结果为非负数时，SF被设置为0。</li>\r\n</ul></li>\r\n<li>溢出标志（OF）：\r\n<ul>\r\n<li>用途：记录有符号数运算中是否发生溢出。</li>\r\n<li>设置条件：当有符号数相加或相减产生溢出时，OF被设置为1；否则，OF被设置为0。</li>\r\n</ul></li>\r\n</ol>\r\n<p>这些条件码在程序执行过程中，可以被用于控制程序的流程，比如进行条件判断、循环等。根据条件码的状态，程序可以根据不同的条件选择不同的执行路径。例如，使用条件跳转指令根据CF、ZF、SF和OF的状态进行分支判断，从而实现程序的控制流程。</p>\r\n<p>好的，下面是对x86-64架构下的<code>cmp</code>和<code>test</code>指令进行说明的表格：</p>\r\n<table>\r\n<colgroup>\r\n<col style=\"width: 6%\" />\r\n<col style=\"width: 22%\" />\r\n<col style=\"width: 71%\" />\r\n</colgroup>\r\n<thead>\r\n<tr class=\"header\">\r\n<th>指令</th>\r\n<th>效果</th>\r\n<th>描述</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td>cmp</td>\r\n<td>比较操作数</td>\r\n<td>比较源操作数和目的操作数的值，根据比较结果设置标志位</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td>test</td>\r\n<td>位测试操作</td>\r\n<td>对源操作数和目的操作数进行按位与运算，并根据结果设置标志位</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<p>这两个指令，cmp等价于sub，test等价于and，唯一的区别在于，这个操作只改变条件码而不改变操作数。</p>\r\n<h3 id=\"访问条件码\">访问条件码</h3>\r\n<p>在x86-64架构下，<code>set</code>指令是一个条件设置指令，用于根据某个条件的结果设置一个目标操作数的值。它根据条件的真假结果设置目标操作数的值为1或0。<code>set</code>指令通常与条件跳转指令（如<code>jmp</code>、<code>jz</code>等）一起使用，用于在条件满足时设置一个寄存器或内存位置的值。</p>\r\n<p><code>set</code>指令有多个变种，每个变种都对应不同的条件码（flags）和条件判断。这些变种包括：</p>\r\n<ul>\r\n<li><code>seta</code> /\r\n<code>setnbe</code>：如果无符号数大于（Above）指定条件，则将目标操作数设置为1，否则设置为0。</li>\r\n<li><code>setae</code> / <code>setnb</code> /\r\n<code>setnc</code>：如果无符号数大于等于（Above or\r\nEqual）指定条件，则将目标操作数设置为1，否则设置为0。</li>\r\n<li><code>setb</code> / <code>setnae</code> /\r\n<code>setc</code>：如果无符号数小于（Below）指定条件，则将目标操作数设置为1，否则设置为0。</li>\r\n<li><code>setbe</code> / <code>setna</code>：如果无符号数小于等于（Below\r\nor Equal）指定条件，则将目标操作数设置为1，否则设置为0。</li>\r\n<li><code>sete</code> /\r\n<code>setz</code>：如果等于（Equal）指定条件，则将目标操作数设置为1，否则设置为0。</li>\r\n<li><code>setg</code> /\r\n<code>setnle</code>：如果有符号数大于（Greater）指定条件，则将目标操作数设置为1，否则设置为0。</li>\r\n<li><code>setge</code> /\r\n<code>setnl</code>：如果有符号数大于等于（Greater or\r\nEqual）指定条件，则将目标操作数设置为1，否则设置为0。</li>\r\n<li><code>setl</code> /\r\n<code>setnge</code>：如果有符号数小于（Less）指定条件，则将目标操作数设置为1，否则设置为0。</li>\r\n<li><code>setle</code> / <code>setng</code>：如果有符号数小于等于（Less\r\nor Equal）指定条件，则将目标操作数设置为1，否则设置为0。</li>\r\n<li><code>setne</code> / <code>setnz</code>：如果不等于（Not\r\nEqual）指定条件，则将目标操作数设置为1，否则设置为0。</li>\r\n</ul>\r\n<p>这些变种可以根据特定的条件码和条件判断来设置目标操作数的值，目标操作数可以是一个寄存器或内存位置。例如，如果指令的结果满足\"等于\"条件，<code>sete %al</code>会将AL寄存器的值设置为1；否则，它将设置AL寄存器的值为0。</p>\r\n<h3 id=\"跳转\">跳转</h3>\r\n<ol type=\"1\">\r\n<li>无条件跳转：\r\n无条件跳转指令用于无条件地改变程序的执行流程，跳转到指定的代码位置。其中，常见的无条件跳转指令有：</li>\r\n</ol>\r\n<ul>\r\n<li><code>jmp</code>：无条件跳转到目标地址，目标地址可以是一个绝对地址或相对地址。\r\n例如：<code>jmp label</code> 将会无条件跳转到标签为 <code>label</code>\r\n的位置。</li>\r\n</ul>\r\n<ol start=\"2\" type=\"1\">\r\n<li>直接/间接跳转：\r\n直接跳转指令通过指定目标地址来改变程序的执行流程。目标地址可以通过直接给出或者存储在寄存器或内存中。常见的直接跳转指令有：</li>\r\n</ol>\r\n<ul>\r\n<li><code>jmp reg</code>：跳转到寄存器中存储的目标地址。\r\n例如：<code>jmp eax</code>\r\n将会跳转到<code>eax</code>寄存器中存储的地址。</li>\r\n<li><code>jmp [mem]</code>：跳转到内存中存储的目标地址。\r\n例如：<code>jmp [0x1000]</code>\r\n将会跳转到地址为<code>0x1000</code>处存储的目标地址。</li>\r\n<li>跳转目标是从寄存器或者内存位置读出的，成为间接跳转，写法是加一个操作符<code>*</code>，例如<code>jmp *%rax</code>。</li>\r\n</ul>\r\n<ol type=\"1\">\r\n<li>有条件跳转：\r\n有条件跳转指令根据特定的条件码（flags）和条件判断来确定是否进行跳转。根据条件的真假结果，可以有符号数和无符号数的情况。常见的有条件跳转指令有：</li>\r\n</ol>\r\n<ul>\r\n<li>有符号数条件跳转：\r\n<ul>\r\n<li><code>jg</code> /\r\n<code>jnle</code>：如果有符号数大于（Greater）指定条件，则跳转。</li>\r\n<li><code>jge</code> / <code>jnl</code>：如果有符号数大于等于（Greater\r\nor Equal）指定条件，则跳转。</li>\r\n<li><code>jl</code> /\r\n<code>jnge</code>：如果有符号数小于（Less）指定条件，则跳转。</li>\r\n<li><code>jle</code> / <code>jng</code>：如果有符号数小于等于（Less or\r\nEqual）指定条件，则跳转。</li>\r\n<li><code>je</code> /\r\n<code>jz</code>：如果等于（Equal）指定条件，则跳转。</li>\r\n<li><code>jne</code> / <code>jnz</code>：如果不等于（Not\r\nEqual）指定条件，则跳转。\r\n例如：<code>jg label</code>将会在有符号数大于指定条件时跳转到标签为<code>label</code>的位置。</li>\r\n</ul></li>\r\n<li>无符号数条件跳转：\r\n<ul>\r\n<li><code>ja</code> /\r\n<code>jnbe</code>：如果无符号数大于（Above）指定条件，则跳转。</li>\r\n<li><code>jae</code> / <code>jnb</code> /\r\n<code>jnc</code>：如果无符号数大于等于（Above or\r\nEqual）指定条件，则跳转。</li>\r\n</ul></li>\r\n<li><code>jb</code> / <code>jnae</code> /\r\n<code>jc</code>：如果无符号数小于（Below）指定条件，则跳转。</li>\r\n<li><code>jbe</code> / <code>jna</code>：如果无符号数小于等于（Below or\r\nEqual）指定条件，则跳转。</li>\r\n<li><code>je</code> /\r\n<code>jz</code>：如果等于（Equal）指定条件，则跳转。</li>\r\n<li><code>jne</code> / <code>jnz</code>：如果不等于（Not\r\nEqual）指定条件，则跳转。\r\n例如：<code>ja label</code>将会在无符号数大于指定条件时跳转到标签为<code>label</code>的位置。</li>\r\n</ul>\r\n<p>这些跳转指令可以根据特定条件的结果来决定是否跳转到目标位置，从而实现程序执行流程的控制。</p>\r\n<p>在计算机中，PC（程序计数器）用于存储下一条要执行的指令的地址。在跳转指令的执行过程中，PC会被修改为跳转目标的地址，以实现代码的跳转和程序流程的改变。</p>\r\n<p>相对跳转（PC相对寻址）是一种常见的跳转方式，其中跳转目标相对于当前指令的地址进行偏移。PC相对寻址使用一个相对于当前指令的偏移量，该偏移量可以是正数或负数，用于计算跳转目标的地址。</p>\r\n<p>在x86-64架构中，相对跳转通常使用有符号的偏移量。例如，<code>jmp rel32</code>\r\n指令使用一个32位的有符号相对偏移量，该偏移量会与当前指令的地址相加，从而计算出跳转目标的地址。相对跳转指令会将这个计算出的跳转目标地址加载到PC中，使得程序执行流程转移到该地址处。</p>\r\n<p>例如，假设当前指令的地址为0x1000（jmp的下一条指令），执行了一条相对跳转指令\r\n<code>jmp rel32</code>，偏移量为-10。那么，PC会被修改为 0x1000 + (-10) =\r\n0xFF6 的值，即跳转到地址 0xFF6 执行下一条指令。</p>\r\n<p>PC相对寻址允许程序在不同的代码位置之间进行跳转，提供了灵活性和动态性，可以根据程序的需求在不同的条件下选择不同的执行路径。</p>\r\n<h3 id=\"用条件控制\">用条件控制</h3>\r\n<p>在x86-64架构下，条件控制和条件传送是两种不同的方式来实现条件分支：</p>\r\n<ul>\r\n<li><p>条件控制是通过条件跳转指令（如<code>jmp</code>、<code>jz</code>、<code>jnz</code>等）来实现条件分支。程序在执行到条件跳转指令时，会根据指定的条件判断是否满足跳转条件，如果满足，则会跳转到指定的目标位置执行相应的代码；如果不满足，则会继续顺序执行下一条指令。这种方式需要进行跳转操作，可能会导致指令预测失败，从而降低性能。</p></li>\r\n<li><p>条件传送是通过条件传送指令（如<code>cmov</code>系列指令）来实现条件分支。这些指令会根据条件判断来选择是否将数据从源操作数传送到目标操作数。如果条件满足，则将源操作数的值传送到目标操作数；如果条件不满足，则不进行传送操作。这种方式不需要跳转操作，因此可以避免指令预测失败的开销，提高性能。</p></li>\r\n</ul>\r\n<p>条件传送方式在指令流水线中更高效，主要是因为它避免了分支预测失败的开销，减少了流水线的清空操作，并且提高了指令级并行性，允许更多的指令同时执行。这使得条件传送在一些需要频繁进行条件分支的代码段中能够更好地发挥性能优势。然而，需要根据具体的代码特点和性能需求进行权衡选择，有时条件控制方式可能更适合。</p>\r\n<p><code>cmov</code>指令在条件传送中起到了关键的作用。它是条件传送指令中的一种，用于执行条件传送操作。<code>cmov</code>指令的基本语法如下：</p>\r\n<figure class=\"highlight css\"><table><tr><td class=\"code\"><pre><span class=\"line\">cmovXX dest, <span class=\"attribute\">src</span></span><br></pre></td></tr></table></figure>\r\n<p>其中，<code>XX</code>是条件码（如<code>e</code>、<code>ne</code>、<code>g</code>、<code>ge</code>、<code>l</code>、<code>le</code>等），根据不同的条件码可以执行不同的条件判断。<code>dest</code>表示目标操作数，<code>src</code>表示源操作数。</p>\r\n<p><code>cmov</code>指令的工作原理是先进行条件判断，如果条件满足，则将源操作数的值传送到目标操作数；如果条件不满足，则不进行传送操作。这样可以根据条件的真假来灵活选择数据传送的方式，而不需要进行跳转操作。</p>\r\n<p>通过使用<code>cmov</code>指令进行条件传送，可以提高程序的执行效率，尤其在一些需要频繁进行条件分支的代码段中。然而，需要注意的是，<code>cmov</code>指令的执行时间可能会比条件跳转指令长，因此在一些执行时间敏感的代码段中，需要权衡选择合适的方式来实现条件分支。</p>\r\n<p>只有在每个分支都容易计算的时候，才会使用条件传送，这样能避免条件控制带来的预测错误的开销。当然也会有一些特殊的情况，比如条件不成立，则分支中有空指针，显然不能进行条件传送。所以尽管条件传送效率更高，但是大部分情况下仍然选择条件控制。</p>\r\n<h2 id=\"过程\">3.7 过程</h2>\r\n<h3 id=\"运行时栈\">运行时栈</h3>\r\n<p>x86-64架构中的运行时栈（Runtime\r\nStack）是一种用于支持函数调用和局部变量存储的数据结构。它是计算机内存中的一块特殊区域，由处理器和操作系统共同管理。</p>\r\n<p>运行时栈通常以“栈”的形式组织数据，采用后进先出（LIFO）的方式进行操作。它在函数调用和返回过程中提供了一种有效的方式来保存和恢复现场，包括函数参数、返回地址和局部变量等。</p>\r\n<p>以下是一些关于x86-64运行时栈的重要概念和特点：</p>\r\n<ol type=\"1\">\r\n<li><p>栈指针（Stack\r\nPointer）：在x86-64中，栈指针是一个特殊的寄存器，通常称为<code>RSP</code>（64位模式下）或者<code>ESP</code>（32位模式下）。栈指针指向栈顶的位置，即最后一个入栈的元素。</p></li>\r\n<li><p>栈帧（Stack\r\nFrame）：栈帧是函数在运行时栈中的一块区域，用于存储函数的局部变量、函数参数和其他与函数执行相关的数据。每次函数调用时，都会创建一个新的栈帧，用于保存当前函数的上下文信息。</p></li>\r\n<li><p>函数调用过程：当一个函数被调用时，以下步骤通常发生在运行时栈中：</p>\r\n<ul>\r\n<li>将函数参数压入栈中。</li>\r\n<li>保存当前函数的返回地址。</li>\r\n<li>分配栈空间用于存储局部变量。</li>\r\n<li>将控制转移到被调用函数的入口点。</li>\r\n<li>在被调用函数中，可以访问参数和局部变量。</li>\r\n<li>当函数执行完毕时，恢复返回地址，并释放栈空间。</li>\r\n<li>将控制返回给调用函数。</li>\r\n</ul></li>\r\n<li><p>栈溢出（Stack\r\nOverflow）：由于运行时栈的大小是有限的，当递归调用层级过深或者在函数中分配过多的局部变量时，可能会导致栈空间不足，从而发生栈溢出错误。</p></li>\r\n</ol>\r\n<p>运行时栈在x86-64架构中是一个重要的组成部分，它提供了函数调用和局部变量存储的机制。了解运行时栈的工作原理和特点有助于理解函数调用、栈帧布局和内存管理等底层的运行时机制。</p>\r\n<h3 id=\"转移控制\">转移控制</h3>\r\n<p>在x86-64架构中，<code>call</code>（调用）和<code>ret</code>（返回）是用于函数调用和返回的指令。</p>\r\n<ol type=\"1\">\r\n<li><code>call</code> 指令：\r\n<ul>\r\n<li><code>call</code> 指令用于调用一个函数或跳转到指定的代码段。</li>\r\n<li>在执行 <code>call</code>\r\n指令时，会将当前指令的下一条指令的地址（即返回地址）压入栈中，保存现场。</li>\r\n<li>然后，<code>call</code>\r\n指令会将控制转移到目标函数或代码段的入口点，开始执行目标代码。</li>\r\n<li>当目标函数或代码段执行完毕后，通过 <code>ret</code>\r\n指令返回调用者。</li>\r\n</ul></li>\r\n<li><code>ret</code> 指令：\r\n<ul>\r\n<li><code>ret</code>\r\n指令用于函数返回，将控制权从被调用函数返回到调用者。</li>\r\n<li>在执行 <code>ret</code>\r\n指令时，它会从栈中弹出保存的返回地址，并将控制转移到该地址所指向的指令。</li>\r\n<li>这样，程序的执行流程回到了调用者处，继续执行后续的代码。</li>\r\n</ul></li>\r\n</ol>\r\n<p>在函数调用过程中，<code>call</code> 和 <code>ret</code>\r\n指令的配对使用，确保了函数的正确调用和返回：</p>\r\n<ol type=\"1\">\r\n<li>调用者：\r\n<ul>\r\n<li>调用者在准备调用函数之前，将函数参数压入栈中，按照函数调用约定传递参数。</li>\r\n<li>调用者使用 <code>call</code>\r\n指令将控制转移给被调用函数，并将返回地址压入栈中。</li>\r\n</ul></li>\r\n<li>被调用函数：\r\n<ul>\r\n<li>被调用函数接收参数，并在栈上分配空间用于保存局部变量。</li>\r\n<li>被调用函数执行完毕后，使用 <code>ret</code>\r\n指令将控制权返回给调用者。</li>\r\n</ul></li>\r\n<li>调用者继续执行：\r\n<ul>\r\n<li>当被调用函数执行完毕，控制权返回到调用者处。</li>\r\n<li>调用者从栈中弹出返回地址，并继续执行后续的代码。</li>\r\n</ul></li>\r\n</ol>\r\n<p>这样，通过 <code>call</code> 和 <code>ret</code>\r\n指令的组合，实现了函数之间的调用和返回，确保了程序的正确执行流程和返回路径。</p>\r\n<h3 id=\"数据传送\">数据传送</h3>\r\n<p>x86-64中，通过寄存器传递参数，但是有上限（详情见<strong>86-64中的整数寄存器</strong>），多于的参数只能通过栈传递。</p>\r\n<h3 id=\"栈上的局部储存\">栈上的局部储存</h3>\r\n<p>大部分情况下，不需要超出寄存器大小的本地存储趋于，但是有时候局部数据必须存放在内存中：</p>\r\n<ul>\r\n<li>寄存器不足够存放所有的本地数据</li>\r\n<li>对一个局部变量使用地址运算符'&amp;',因此必须产生一个地址</li>\r\n<li>局部变量是数组或者结构。</li>\r\n</ul>\r\n<h3 id=\"寄存器中的局部储存空间\">寄存器中的局部储存空间</h3>\r\n<p>寄存器组是唯一被所有过程共享的资源，虽然给定时刻只有一个过程是活动的，但是我们仍然必须确保，被调用者不会覆盖调用者稍后会使用的寄存器。</p>\r\n<p>因此，x86-64采用了统一的寄存器使用管理，所有的过程都必须遵循。</p>\r\n<p>按照惯例，寄存器%rbx、%rbp和%r12-%r15被划分为被调用者保存寄存器。被调用的过程要么保证这个值不变，要么压入栈中，在返回时复原这个值。</p>\r\n<p>其它寄存器，除了栈指针%rsp，所有函数都可以任意修改这个寄存器。</p>\r\n<h2 id=\"数组的分配和访问\">3.8 数组的分配和访问</h2>\r\n<h3 id=\"基本原则\">基本原则</h3>\r\n<p>在计算数组元素的地址时，可以使用以下公式：</p>\r\n<figure class=\"highlight excel\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">address</span> = base_address + element_size * <span class=\"built_in\">index</span></span><br></pre></td></tr></table></figure>\r\n<p>其中： - <code>address</code> 是数组元素的地址。 -\r\n<code>base_address</code> 是数组的起始地址或首元素的地址。 -\r\n<code>element_size</code> 是每个数组元素的大小（以字节为单位）。 -\r\n<code>index</code> 是要访问的元素的索引（从0开始）。</p>\r\n<p>通过将索引乘以每个元素的大小，然后加上起始地址，可以计算出特定元素的地址。</p>\r\n<p>例如，假设有一个数组 <code>arr</code>，起始地址为\r\n<code>0x1000</code>，每个元素的大小为 4\r\n字节（32位整数），要计算第三个元素（索引为\r\n2）的地址，可以使用以下公式：</p>\r\n<figure class=\"highlight apache\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">address</span> = <span class=\"number\">0</span>x1000 + <span class=\"number\">4</span> * <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\r\n<p>计算结果为 <code>0x1008</code>，即第三个元素的地址为\r\n<code>0x1008</code>。</p>\r\n<h3 id=\"嵌套的数组\">嵌套的数组</h3>\r\n<p>如果数组是嵌套的，也就是多维数组，计算数组元素的地址就会稍微复杂一些。在多维数组中，每个维度都有一个对应的索引，因此需要使用多个索引来定位数组中的元素。</p>\r\n<p>对于一个二维数组，可以使用以下公式来计算元素的地址：</p>\r\n<figure class=\"highlight excel\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">address</span> = base_address + (element_size * (row_index * <span class=\"built_in\">columns</span> + column_index))</span><br></pre></td></tr></table></figure>\r\n<p>其中： - <code>address</code> 是数组元素的地址。 -\r\n<code>base_address</code> 是数组的起始地址或首元素的地址。 -\r\n<code>element_size</code> 是每个数组元素的大小（以字节为单位）。 -\r\n<code>row_index</code> 是行索引，指定要访问的行。 -\r\n<code>column_index</code> 是列索引，指定要访问的列。 -\r\n<code>columns</code> 是数组的列数，表示每行有多少个元素。</p>\r\n<p>在一个三维数组中，需要使用类似的公式，但是会涉及更多的索引和维度。</p>\r\n<p>需要注意的是，对于多维数组，计算地址的公式可能会因不同的数组排列方式（行主序、列主序等）而有所不同。在一些情况下，还可能需要进行乘法优化或使用偏移量来处理特殊的嵌套数组布局。</p>\r\n<h3 id=\"定长数组和变长数组\">定长数组和变长数组</h3>\r\n<p>对于定长数组，每个元素的大小已知且相同，可以使用之前提到的公式来计算元素的地址。</p>\r\n<p>例如，对于一个定长数组 <code>arr</code>，起始地址为\r\n<code>base_address</code>，每个元素的大小为\r\n<code>element_size</code>，要计算第 <code>index</code>\r\n个元素的地址，可以使用以下公式：</p>\r\n<figure class=\"highlight excel\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">address</span> = base_address + (element_size * <span class=\"built_in\">index</span>)</span><br></pre></td></tr></table></figure>\r\n<p>其中 <code>address</code> 是数组元素的地址。</p>\r\n<p>对于变长数组（例如动态分配的数组），情况略有不同。由于数组的大小是在运行时确定的，每个元素的地址无法使用简单的公式进行计算。通常，变长数组的元素是通过指针或引用进行访问，而不是直接计算地址。</p>\r\n<p>在使用变长数组时，通常需要使用动态内存分配函数（例如\r\n<code>malloc()</code>）在堆上分配内存，并使用指针来访问数组元素。此时，可以使用指针运算来访问数组元素，而不需要直接计算地址。</p>\r\n<p>例如，假设有一个变长数组 <code>arr</code>，通过动态内存分配函数\r\n<code>malloc()</code> 在堆上分配了一块内存，并返回了指向数组首元素的指针\r\n<code>arr_ptr</code>。要访问第 <code>index</code>\r\n个元素，可以使用以下指针运算：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\">element_ptr = arr_ptr + index</span><br></pre></td></tr></table></figure>\r\n<p>其中 <code>element_ptr</code> 是指向第 <code>index</code>\r\n个元素的指针。</p>\r\n<p>需要注意的是，对于变长数组，必须在分配内存后才能进行访问，而且还需要确保在不再使用数组时释放相关的内存，以避免内存泄漏。</p>\r\n<p>总结起来，对于定长数组，可以使用公式计算元素的地址。对于变长数组，通常需要使用指针来访问数组元素。</p>\r\n<h2 id=\"异质的数据结构\">3.9 异质的数据结构</h2>\r\n<h3 id=\"结构体\">结构体</h3>\r\n<p>在x86-64架构中，结构体的实现与其他架构类似，使用一系列的字节来存储结构体的成员。下面是一种常见的实现方式：</p>\r\n<ol type=\"1\">\r\n<li><p>内存对齐：结构体在内存中存储时，通常要进行内存对齐，以保证结构体成员在内存中的地址是对齐的。这有助于提高内存访问的效率。可以使用编译器提供的特定指令或指令集来实现内存对齐。</p></li>\r\n<li><p>成员偏移：每个结构体成员在结构体中的偏移量决定了其在内存中的位置。编译器会根据结构体成员的类型和对齐要求计算出偏移量，并将成员放置在适当的位置。</p></li>\r\n<li><p>结构体大小：结构体的大小取决于其成员的类型和排列方式。成员之间可能存在填充字节，以确保内存对齐。</p></li>\r\n</ol>\r\n<p>以下是一个示例结构体的定义和实现：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 定义结构体</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> name[<span class=\"number\">20</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> age;</span><br><span class=\"line\">    <span class=\"type\">float</span> height;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 创建结构体变量</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Person</span> <span class=\"title\">person</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 访问结构体成员并赋值</span></span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(person.name, <span class=\"string\">&quot;John&quot;</span>);</span><br><span class=\"line\">    person.age = <span class=\"number\">25</span>;</span><br><span class=\"line\">    person.height = <span class=\"number\">1.75</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输出结构体成员的值</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Name: %s\\n&quot;</span>, person.name);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Age: %d\\n&quot;</span>, person.age);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Height: %.2f\\n&quot;</span>, person.height);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>在上述示例中，我们定义了一个名为<code>Person</code>的结构体，它包含了一个字符数组<code>name</code>、一个整数<code>age</code>和一个浮点数<code>height</code>作为成员。在<code>main()</code>函数中，我们创建了一个<code>person</code>结构体变量，并通过点运算符<code>.</code>来访问和赋值结构体的成员。最后，我们使用<code>printf()</code>函数输出结构体成员的值。</p>\r\n<p>需要注意的是，结构体的具体实现可能因编译器、编译选项和对齐要求等因素而有所差异。因此，在实际编程中，最好遵循编译器的规范，并确保对结构体的访问和操作是正确和可移植的。</p>\r\n<h3 id=\"联合\">联合</h3>\r\n<p>联合（Union）是一种特殊的数据类型，允许在相同的内存位置存储不同类型的数据。与结构体不同，联合只能同时存储其中一个成员的值。以下是联合的实现方式：</p>\r\n<ol type=\"1\">\r\n<li><p>内存共享：联合的所有成员共享相同的内存空间，其大小取决于最大成员的大小。这意味着联合的不同成员会占用相同的内存位置。</p></li>\r\n<li><p>成员访问：通过使用联合变量的名称和成员名称，可以访问和操作联合的成员。</p></li>\r\n</ol>\r\n<p>下面是一个简单的联合示例：</p>\r\n<figure class=\"highlight c\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">Data</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> intValue;</span><br><span class=\"line\">    <span class=\"type\">float</span> floatValue;</span><br><span class=\"line\">    <span class=\"type\">char</span> stringValue[<span class=\"number\">20</span>];</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">Data</span> <span class=\"title\">data</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    data.intValue = <span class=\"number\">42</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Integer value: %d\\n&quot;</span>, data.intValue);</span><br><span class=\"line\"></span><br><span class=\"line\">    data.floatValue = <span class=\"number\">3.14</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Float value: %.2f\\n&quot;</span>, data.floatValue);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">sprintf</span>(data.stringValue, <span class=\"string\">&quot;Hello&quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;String value: %s\\n&quot;</span>, data.stringValue);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\r\n<p>在上述示例中，我们定义了一个名为<code>Data</code>的联合，它包含了一个整数<code>intValue</code>、一个浮点数<code>floatValue</code>和一个字符数组<code>stringValue</code>作为成员。在<code>main()</code>函数中，我们创建了一个<code>data</code>联合变量，并通过点运算符<code>.</code>来访问和赋值联合的成员。需要注意的是，对于联合来说，我们只能同时访问其中一个成员，对一个成员的赋值会影响其他成员。</p>\r\n<p>请注意，联合的使用需要谨慎，特别是在涉及类型转换和内存访问方面。由于联合的成员共享相同的内存空间，对一个成员的修改可能会影响其他成员的值。因此，在使用联合时，请确保正确地访问和操作联合的成员，以避免潜在的错误和问题。</p>\r\n<h3 id=\"数据对齐\">数据对齐</h3>\r\n<p>数据对齐是为了提高内存访问效率和处理器的性能而进行的一种优化技术。数据对齐确保数据在内存中按照特定的规则进行存储，使得访问对齐的数据可以更快速地进行，减少内存访问的开销。</p>\r\n<p>以下是一些原因说明为什么要进行数据对齐：</p>\r\n<ol type=\"1\">\r\n<li><p>提高内存访问效率：处理器通常以特定的块大小（例如字节、字、双字等）从内存中读取数据。如果数据按照处理器的访问要求进行对齐，处理器可以直接从内存中读取整块数据，而不需要进行额外的操作。这样可以提高内存读取的效率。</p></li>\r\n<li><p>减少内存访问次数：当结构体或对象中的成员按照对齐要求进行排列时，可以避免在访问不对齐的数据时进行多次内存读取。相反，可以通过一次对齐的读取来获取多个成员的值，从而减少内存访问的次数，提高效率。</p></li>\r\n</ol>\r\n<p>需要注意的是，数据对齐可能会导致一些额外的内存空间被填充，以确保成员之间的对齐。这些额外的填充字节可能会增加结构体或对象的大小。因此，在设计数据结构时，需要权衡内存使用和访问效率之间的平衡。</p>\r\n<p>数据对齐是由编译器根据平台的要求自动完成的。大多数编程语言和编译器提供了一些机制，如编译器指令、编译选项或属性，以控制数据对齐的方式和行为。</p>\r\n<h2 id=\"在机器级程序中将控制欲数据结合起来\">3.10\r\n在机器级程序中将控制欲数据结合起来</h2>\r\n<h3 id=\"指针\">指针</h3>\r\n<p>C语言的指针是其核心特性之一，它允许直接访问内存地址，进而实现高效的内存操作和数据结构表示。指针在C语言中扮演着重要的角色，并且对于理解机器代码和底层内存操作至关重要。</p>\r\n<p>首先，让我们讨论指针的概念。指针是一个变量，它存储了内存地址的值。可以通过使用取地址运算符<code>&amp;</code>将变量的地址赋给指针变量。例如，<code>int *ptr;</code>声明了一个指向整数的指针。然后，通过将某个整数变量的地址赋给<code>ptr</code>，可以使<code>ptr</code>指向该变量。</p>\r\n<p>指针的重要性在于它提供了直接访问内存的能力。通过解引用操作符<code>*</code>，可以访问指针指向的内存位置上存储的值。例如，<code>*ptr</code>将返回指针<code>ptr</code>指向的整数值。</p>\r\n<p>指针的使用要正确且谨慎。以下是一些指针相关的关键原则：</p>\r\n<ul>\r\n<li>每个指针都有值</li>\r\n<li>指针用'&amp;'运算符创建</li>\r\n<li>数组与指针紧密联系</li>\r\n<li>*操作符用来间接引用指针</li>\r\n<li>将指针强制转化类型，只改变类型不改变值</li>\r\n<li>指针也可以指向函数，指向的是第一条指令的地址</li>\r\n</ul>\r\n<h3 id=\"内存越界引用和缓存区溢出\">内存越界引用和缓存区溢出</h3>\r\n<ul>\r\n<li><p>内存越界引用（Memory Out-of-Bounds Reference）：\r\n内存越界引用指的是程序试图访问超出其分配内存范围的位置的行为。当程序访问超过其分配内存边界的位置时，可能会导致未定义的行为和安全漏洞。</p>\r\n<p>例如，在C语言中，如果你声明了一个数组 <code>int arr[5];</code>\r\n，它有五个元素，索引从0到4。如果你试图访问 <code>arr[5]</code> 或者\r\n<code>arr[100]</code>，这就是内存越界引用，因为你超出了数组的有效索引范围。这样的行为可能会导致程序崩溃、数据损坏或者安全漏洞，因为你可能会误用或覆盖其他内存区域的数据。</p>\r\n<p>内存越界引用可能导致的问题包括程序崩溃、内存泄漏、数据损坏、安全漏洞（如利用越界引用进行代码执行）等。因此，在编写程序时，务必要注意数组和指针的边界，并确保不发生内存越界引用。</p></li>\r\n<li><p>缓冲区溢出（Buffer Overflow）：\r\n缓冲区溢出是指向一个缓冲区写入超过其容量的数据量的行为。当程序向一个固定大小的缓冲区写入超过其可容纳的数据时，多余的数据会覆盖到相邻的内存区域，可能导致程序崩溃或者被攻击者利用。</p>\r\n<p>缓冲区溢出通常发生在使用不安全的字符串处理函数（如C语言中的\r\n<code>strcpy</code>、<code>sprintf</code>\r\n等）时，因为这些函数不会检查目标缓冲区的容量。攻击者可以利用缓冲区溢出漏洞，覆盖关键数据、修改程序行为、执行恶意代码等。</p>\r\n<p>为了避免缓冲区溢出漏洞，可以使用安全的字符串处理函数（如C语言中的\r\n<code>strncpy</code>、<code>snprintf</code>\r\n等），并且要仔细检查输入数据的大小，确保不会写入超过缓冲区容量的数据。</p></li>\r\n</ul>\r\n<h3 id=\"对抗缓存区溢出攻击\">对抗缓存区溢出攻击</h3>\r\n<ol type=\"1\">\r\n<li><p>栈随机化（Stack Randomization）：\r\n栈随机化是一种安全增强技术，它通过在每次程序运行时随机选择栈的起始地址来改变栈的内存布局。在\r\nLinux 系统中，栈随机化是 ASLR（Address Space Layout\r\nRandomization）的一部分。</p>\r\n<p>ASLR\r\n通过随机化程序的内存布局，包括栈、堆、共享库、代码段等，来增加攻击者对系统的预测难度。栈随机化是\r\nASLR\r\n的一项措施，它使得栈的位置在每次程序运行时都会发生随机变化，从而减少了栈溢出攻击的成功概率。</p>\r\n<p>栈随机化通过使攻击者无法准确预测栈的位置来防止栈溢出攻击。即使攻击者成功地溢出了栈缓冲区，他们也无法确定准确的返回地址或其他敏感数据的位置，从而阻止了攻击的成功执行。</p></li>\r\n<li><p>栈破坏检测（Stack Protection）：\r\n栈破坏检测是一种用于检测栈溢出攻击的技术。其中一种常见的栈破坏检测技术是使用金丝雀值（Canary\r\nValue），它也是 ASLR 的一部分。</p>\r\n<p>在 Linux\r\n系统中，当启用栈保护机制时，编译器会自动将一个特殊的随机值（金丝雀值）插入到栈帧中函数返回地址之前。在函数返回时，系统会检查金丝雀值是否保持不变。如果金丝雀值被篡改，系统会判定栈溢出攻击已发生，并采取相应的安全措施，如终止程序运行或触发警报。</p>\r\n<p>栈破坏检测技术通过使用金丝雀值可以检测栈溢出攻击。攻击者在进行溢出时，必须同时修改栈缓冲区和相应的金丝雀值。如果金丝雀值被修改，检测机制就会触发并采取相应的措施。</p></li>\r\n<li><p>ASLR（Address Space Layout Randomization）： ASLR\r\n是一种操作系统级的安全技术，旨在增加攻击者对系统内存布局的预测难度。除了栈随机化之外，ASLR\r\n还包括对代码段、堆、共享库等内存区域的随机化。</p>\r\n<p>在 Linux 中，启用 ASLR\r\n后，操作系统会在每次程序加载时，随机地将程序的内存布局进行重排。这意味着相同的程序在不同的运行实例中，其内存布局会发生随机变化。</p>\r\n<p>ASLR\r\n防止了许多常见的攻击技术，如栈溢出、代码注入等。通过随机化内存布局，攻击者无法准确预测关键数据和代码的位置，从而增加了攻击的难度。</p></li>\r\n</ol>\r\n<h3 id=\"支持变长栈帧\">支持变长栈帧</h3>\r\n<p>支持变长栈帧（Variable Length Stack\r\nFrames）是一种在函数调用过程中动态调整栈帧大小的技术。这通常用于支持具有可变数量参数或动态分配局部变量的函数。下面是几种常见的支持变长栈帧的方法：</p>\r\n<ol type=\"1\">\r\n<li><p>栈指针调整：\r\n变长栈帧的一种常见方法是通过在函数开始时动态调整栈指针来为变量分配空间。这通常涉及使用额外的指令来增加或减少栈指针的偏移量，以适应变量的大小。</p>\r\n<p>例如，对于具有可变数量参数的函数，可以使用类似于C语言中的<code>va_list</code>和相关的宏（如<code>va_start</code>和<code>va_end</code>）来获取参数的地址，并使用栈指针调整来分配和访问参数。</p></li>\r\n<li><p>动态分配空间：\r\n另一种支持变长栈帧的方法是通过动态分配空间来容纳变量。这可以通过在堆上分配内存并将指针存储在栈帧中来实现。</p>\r\n<p>例如，如果函数需要动态分配一个可变大小的数组，可以使用堆分配函数（如<code>malloc</code>）来分配内存，并将返回的指针存储在栈帧中的变量中。在函数结束时，需要确保释放已分配的内存，以避免内存泄漏。</p></li>\r\n<li><p>额外的栈帧元数据：\r\n对于支持变长栈帧的函数，通常需要存储关于栈帧结构的额外元数据信息。这些信息可以包括参数的数量、大小以及局部变量的数量和偏移量等。</p>\r\n<p>这些额外的栈帧元数据通常存储在特定的位置，如栈帧的开头或结尾。通过解析和使用这些元数据，函数可以动态地访问和操作变长栈帧中的变量。</p></li>\r\n</ol>\r\n","categories":["CSAPP"],"tags":["CSAPP","汇编语言"]},{"title":"从bilibili获取到的json解析","url":"/posts/715dfc00/","content":"<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;code&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span>                                  <span class=\"comment\">// 返回码，0 表示请求成功</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;message&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;0&quot;</span><span class=\"punctuation\">,</span>                             <span class=\"comment\">// 返回信息，一般与返回码对应，0 表示成功</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;ttl&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span>                                   <span class=\"comment\">// TTL，即过期时间</span></span><br><span class=\"line\">    <span class=\"attr\">&quot;data&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span>                                   <span class=\"comment\">// 返回数据</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;bvid&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;BV12M4y1m7kf&quot;</span><span class=\"punctuation\">,</span>                 <span class=\"comment\">// 视频BV号</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;aid&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">909171516</span><span class=\"punctuation\">,</span>                       <span class=\"comment\">// 视频AV号</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;videos&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">4</span><span class=\"punctuation\">,</span>                            <span class=\"comment\">// 视频分P数</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;tid&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">171</span><span class=\"punctuation\">,</span>                             <span class=\"comment\">// 视频分类ID</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;tname&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;电子竞技&quot;</span><span class=\"punctuation\">,</span>                    <span class=\"comment\">// 视频分类名</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;copyright&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;pic&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;http://i2.hdslb.com/bfs/archive/104cf33fbf2b35e48a3063939f75d3f99d7ee64a.jpg&quot;</span><span class=\"punctuation\">,</span>    <span class=\"comment\">// 封面图片链接</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;title&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;【2023LPL春季赛】3月26日 WBG vs RA&quot;</span><span class=\"punctuation\">,</span>    <span class=\"comment\">// 视频标题</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;pubdate&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1679834315</span><span class=\"punctuation\">,</span>                   <span class=\"comment\">// 视频发布时间</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;ctime&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1679834315</span><span class=\"punctuation\">,</span>                     <span class=\"comment\">// 视频创建时间</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;desc&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;【2023LPL春季赛】3月26日 WBG vs RA&quot;</span><span class=\"punctuation\">,</span>    <span class=\"comment\">// 视频描述</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;desc_v2&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span>                             <span class=\"comment\">// 视频描述的备选字段</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;raw_text&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;【2023LPL春季赛】3月26日 WBG vs RA&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;type&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;biz_id&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;state&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;duration&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">9933</span><span class=\"punctuation\">,</span>                        <span class=\"comment\">// 视频时长（单位：秒）</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;rights&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span>                              <span class=\"comment\">// 视频权限</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;bp&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;elec&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;download&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;movie&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;pay&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;hd5&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;no_reprint&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;autoplay&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;ugc_pay&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;is_cooperation&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;ugc_pay_preview&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;no_background&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;clean_mode&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;is_stein_gate&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;is_360&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;no_share&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;arc_pay&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;free_watch&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;owner&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span>                               <span class=\"comment\">// 视频上传者信息</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;mid&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">50329118</span><span class=\"punctuation\">,</span>                      <span class=\"comment\">// 上传者的用户ID</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;name&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;哔哩哔哩英雄联盟赛事&quot;</span><span class=\"punctuation\">,</span>      <span class=\"comment\">// 上传者的昵称</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;face&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;https://i2.hdslb.com/bfs/face/544c89e68f2b1f12ffcbb8b3c062a3328e8692d9.jpg&quot;</span>    <span class=\"comment\">// 上传者的头像链接</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;stat&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span>                                <span class=\"comment\">// 视频的各项统</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;aid&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">909171516</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 视频ID</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;view&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">863879</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 播放量</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;danmaku&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">6896</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 弹幕数</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;reply&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1563</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 评论数</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;favorite&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">717</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 收藏数</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;coin&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">843</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 硬币数</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;share&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">388</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 分享数</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;now_rank&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 当前排名</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;his_rank&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 历史最高排名</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;like&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">8575</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 点赞数</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;dislike&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 点踩数</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;evaluation&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 评级</span></span><br><span class=\"line\">             <span class=\"attr\">&quot;argue_msg&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span> <span class=\"comment\">// 爭議信息</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;dynamic&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;【2023LPL春季赛】3月26日 WBG vs RA&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 视频动态标题</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;cid&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1071905598</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 弹幕池ID</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;dimension&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span> <span class=\"comment\">// 视频分辨率信息</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;width&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1920</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 宽度</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;height&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1080</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 高度</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;rotate&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span> <span class=\"comment\">// 旋转角度</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;premiere&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">null</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 首播时间</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;teenage_mode&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 青少年模式开关</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;is_chargeable_season&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 是否是付费季度</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;is_story&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 是否是剧情系列</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;no_cache&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span> <span class=\"comment\">// 是否禁用缓存</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;pages&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;cid&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1071905598</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 视频对应的cid</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;page&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 视频分P数，这里表示第1个分P</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;from&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;vupload&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 视频来源，这里表示自主上传</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;part&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;第一局&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 视频分P的名称</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;duration&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">3605</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 视频时长，单位为秒</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;vid&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 视频vid，一般是从其他平台转载时才有值</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;weblink&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 视频网页链接，一般是从其他平台转载时才有值</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;dimension&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span> <span class=\"comment\">// 视频的尺寸信息</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;width&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1920</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 视频宽度，单位为像素</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;height&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1080</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 视频高度，单位为像素</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;rotate&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span> <span class=\"comment\">// 视频是否需要旋转，0表示不需要，1表示需要</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;cid&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1071978332</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;page&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">2</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;from&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;vupload&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;part&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;第二局&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;duration&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">3130</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;vid&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;weblink&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;dimension&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;width&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1920</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;height&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1080</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;rotate&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;cid&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1072032305</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;page&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">3</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;from&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;vupload&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;part&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;第三局&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;duration&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">2593</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;vid&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;weblink&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;dimension&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;width&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1920</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;height&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1080</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;rotate&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;cid&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1072047043</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;page&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">4</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;from&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;vupload&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;part&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;赛后采访&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;duration&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">605</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;vid&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;weblink&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                <span class=\"attr\">&quot;dimension&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;width&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1920</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;height&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">1080</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">                    <span class=\"attr\">&quot;rotate&quot;</span><span class=\"punctuation\">:</span> <span class=\"number\">0</span></span><br><span class=\"line\">                <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">            <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\">        <span class=\"punctuation\">]</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;subtitle&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span> <span class=\"comment\">// 字幕相关信息</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;allow_submit&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 是否允许提交字幕</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;list&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">[</span><span class=\"punctuation\">]</span> <span class=\"comment\">// 字幕列表</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;is_season_display&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span><span class=\"punctuation\">,</span> <span class=\"comment\">// 是否展示季节标志</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;user_garb&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span> <span class=\"comment\">// 头衔信息</span></span><br><span class=\"line\">            <span class=\"attr\">&quot;url_image_ani_cut&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span> <span class=\"comment\">// 动画头衔图片链接</span></span><br><span class=\"line\">        <span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;honor_reply&quot;</span><span class=\"punctuation\">:</span> <span class=\"punctuation\">&#123;</span><span class=\"punctuation\">&#125;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 回复勋章相关信息</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;like_icon&quot;</span><span class=\"punctuation\">:</span> <span class=\"string\">&quot;&quot;</span><span class=\"punctuation\">,</span> <span class=\"comment\">// 点赞图标链接</span></span><br><span class=\"line\">        <span class=\"attr\">&quot;need_jump_bv&quot;</span><span class=\"punctuation\">:</span> <span class=\"literal\"><span class=\"keyword\">false</span></span> <span class=\"comment\">// 是否需要跳转到BV号</span></span><br><span class=\"line\">    <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\r\n","categories":["github项目"],"tags":["python","github","爬虫","json"]},{"title":"二叉树的遍历","url":"/posts/ea4681d0/","content":"<h1 id=\"leetcode-94.-二叉树的中序遍历\"><a\r\nhref=\"https://leetcode.cn/problems/binary-tree-inorder-traversal/\">leetcode-94.\r\n二叉树的中序遍历</a></h1>\r\n<figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">traversal</span><span class=\"params\">(TreeNode* cur, vector&lt;<span class=\"type\">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cur == <span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"built_in\">traversal</span>(cur-&gt;left, vec);  <span class=\"comment\">// 左</span></span><br><span class=\"line\">        vec.<span class=\"built_in\">push_back</span>(cur-&gt;val);    <span class=\"comment\">// 中</span></span><br><span class=\"line\">        <span class=\"built_in\">traversal</span>(cur-&gt;right, vec); <span class=\"comment\">// 右</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">inorderTraversal</span><span class=\"params\">(TreeNode* root)</span> </span>&#123;</span><br><span class=\"line\">        vector&lt;<span class=\"type\">int</span>&gt; result;</span><br><span class=\"line\">        <span class=\"built_in\">traversal</span>(root, result);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\r\n<p>经典代码，递归调用遍历函数，前序、中序和后序的区别只在于遍历函数的顺序。</p>\r\n","categories":["算法笔记"],"tags":["树","二叉树","递归","前序遍历","中序遍历","后序遍历"]},{"title":"像素画-薇古丝（未完成）","url":"/posts/c49d4bce/","content":"<h1 id=\"像素画薇古丝\">像素画薇古丝</h1>\r\n<p><img\r\nsrc=\"https://raw.githubusercontent.com/vinouno/blog_image/main/%E8%96%87%E5%8F%A4%E4%B8%9D-400-%E6%9C%AA%E5%AE%8C%E6%88%90.png\" /></p>\r\n<p>外形大体上满意（就是头发画的很僵硬）。\r\n但是高光和阴影很难达到满意的效果，尝试数次，放弃，待进步后完成。</p>\r\n","categories":["绘画笔记"],"tags":["像素画","未完成"]},{"title":"关于free和delete","url":"/posts/3a68c5f2/","content":"<p>free 函数和 delete\r\n运算符都用于释放内存空间，但它们之间有一些重要的区别。</p>\r\n<p>首先，free 函数是 C 语言标准库中的函数，而 delete 运算符是 C++\r\n语言中的运算符。</p>\r\n<p>其次，free 函数只能释放由 malloc、calloc 或 realloc\r\n分配的内存空间，而 delete 运算符既可以释放由\r\nnew、new[]、malloc、calloc、realloc 分配的内存空间，也可以释放由\r\nnew、new[] 分配的对象空间。</p>\r\n<p>此外，当释放内存空间时，free\r\n函数只是释放内存空间，而不会调用被释放对象的析构函数；而 delete\r\n运算符除了释放内存空间外，还会调用被释放对象的析构函数，从而执行对象的清理工作。</p>\r\n<p>总之，虽然 free 函数和 delete\r\n运算符都可以释放内存空间，但是由于它们的使用场景和行为有所不同，因此在\r\nC++ 中建议使用 delete 运算符来释放内存空间。</p>\r\n","categories":["算法笔记"],"tags":["C++"]},{"title":"像素画练习（临摹）-稻草人费德提克","url":"/posts/2083f273/","content":"<h1 id=\"原图\">原图</h1>\r\n<p>从P站上找了一张稻草人的像素图，尝试第一次临摹。</p>\r\n<p><img\r\nsrc=\"https://raw.githubusercontent.com/vinouno/blog_image/main/%E7%A8%BB%E8%8D%89%E4%BA%BA-%E5%8E%9F%E5%9B%BE.png\" /></p>\r\n<h1 id=\"轮廓临摹\">轮廓临摹</h1>\r\n<p>这个还是比较满意的，外形基本复现成功了。我想让稻草人的腿更长一点，就把它的腿拉长了，看上去也没太违和。</p>\r\n<p><img\r\nsrc=\"https://raw.githubusercontent.com/vinouno/blog_image/main/%E7%A8%BB%E8%8D%89%E4%BA%BA-400.png\" /></p>\r\n<h1 id=\"上色\">上色</h1>\r\n<p>上色的结果不是特别满意，想让稻草人灰暗一点，这样才有恐怖的感觉。但是试了很多次，总感觉不是特别满意，没画出原图那种“脏”的感觉，不像一个扭曲的怪物，还是要对调色多加练习。</p>\r\n<p><img\r\nsrc=\"https://raw.githubusercontent.com/vinouno/blog_image/main/%E7%A8%BB%E8%8D%89%E4%BA%BA-400-%E4%B8%8A%E8%89%B2.png\" /></p>\r\n","categories":["绘画笔记"],"tags":["像素画","临摹","绘画练习"]},{"title":"哈希表","url":"/posts/850f2080/","content":"<h1 id=\"哈希表\">哈希表</h1>\r\n<p>哈希的原理就不再赘述了。第一题虽然使用数组完成题目，但是已经涉及到哈希的思想。</p>\r\n<p><a href=\"https://leetcode.cn/problems/valid-anagram/\">leetcode-242.\r\n有效的字母异位词</a> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isAnagram</span><span class=\"params\">(string s, string t)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> record[<span class=\"number\">26</span>] = &#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; s.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 并不需要记住字符a的ASCII，只要求出一个相对数值就可以了</span></span><br><span class=\"line\">            record[s[i] - <span class=\"string\">&#x27;a&#x27;</span>]++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; t.<span class=\"built_in\">size</span>(); i++) &#123;</span><br><span class=\"line\">            record[t[i] - <span class=\"string\">&#x27;a&#x27;</span>]--;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">26</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (record[i] != <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// record数组如果有的元素不为零0，说明字符串s和t 一定是谁多了字符或者谁少了字符。</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// record数组所有元素都为零0，说明字符串s和t是字母异位词</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n<p>第二题用了哈希表，要注意<code>unordered_set</code>的使用方法。</p>\r\n<p><a\r\nhref=\"https://leetcode.cn/problems/intersection-of-two-arrays/\">leetcode-349.\r\n两个数组的交集</a> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">intersection</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums1, vector&lt;<span class=\"type\">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class=\"line\">        unordered_set&lt;<span class=\"type\">int</span>&gt; result_set; <span class=\"comment\">// 存放结果，之所以用set是为了给结果集去重</span></span><br><span class=\"line\">        <span class=\"function\">unordered_set&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">nums_set</span><span class=\"params\">(nums1.begin(), nums1.end())</span></span>; <span class=\"comment\">//两个迭代器复制元素</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> num : nums2) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 发现nums2的元素 在nums_set里又出现过</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums_set.<span class=\"built_in\">find</span>(num) != nums_set.<span class=\"built_in\">end</span>()) &#123;</span><br><span class=\"line\">                result_set.<span class=\"built_in\">insert</span>(num);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(result_set.<span class=\"built_in\">begin</span>(), result_set.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n","categories":["算法笔记"],"tags":["哈希"]},{"title":"弹幕词云生成器","url":"/posts/29fc4cd/","content":"<h1 id=\"弹幕词云生成器\"><a\r\nhref=\"https://github.com/vinouno/BilibiliDanmuCrawler\">弹幕词云生成器</a></h1>\r\n<p>这是一个python爬虫的初学练手项目，作用是从 bilibili.com\r\n爬取弹幕并生成词云。</p>\r\n<h2 id=\"爬取弹幕\">爬取弹幕</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_cid</span>(<span class=\"params\">bvid</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;获取视频cid&quot;&quot;&quot;</span></span><br><span class=\"line\">    url = <span class=\"string\">&#x27;https://api.bilibili.com/x/web-interface/view?bvid=&#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(bvid)</span><br><span class=\"line\">    headers = &#123;</span><br><span class=\"line\">        <span class=\"string\">&#x27;User-Agent&#x27;</span>: <span class=\"string\">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299&#x27;</span>,</span><br><span class=\"line\">        <span class=\"string\">&#x27;Referer&#x27;</span>: <span class=\"string\">&#x27;https://www.bilibili.com/video/&#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(bvid)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    response = requests.get(url, headers=headers)</span><br><span class=\"line\">    data = response.json()</span><br><span class=\"line\">    cid = data[<span class=\"string\">&#x27;data&#x27;</span>][<span class=\"string\">&#x27;cid&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cid</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    # 将Python对象转化为JSON格式的字符串，并输出</span></span><br><span class=\"line\"><span class=\"string\">    print(json.dumps(data, indent=4, ensure_ascii=False))</span></span><br><span class=\"line\"><span class=\"string\">    print(cid)</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>\r\n<p>传入视频的BV号，在<code>headers</code>里面定义了一个请求头，用于描述发起请求的客户端信息。在这段代码中，我们手动设置了一个浏览器用户代理，用于模拟浏览器的行为。</p>\r\n<p>然后把获取到的响应转换成json格式，从响应里提取出视频的<code>cid</code>值。</p>\r\n<p>这篇文章，详细解析了获取到的json：<a\r\nhref=\"https://vinouno.github.io/posts/715dfc00/\">从bilibili获取到的json解析</a>。可以看到一个视频里，不同分p有不同的<code>cid</code>。</p>\r\n<p>问我为什么不写不同分p的情况？因为我懒，有需要再写(2023.4.14日备注，此问题已修复)。</p>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_danmu</span>(<span class=\"params\">cid</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;获取弹幕&quot;&quot;&quot;</span></span><br><span class=\"line\">    url = <span class=\"string\">&#x27;https://comment.bilibili.com/&#123;&#125;.xml&#x27;</span>.<span class=\"built_in\">format</span>(cid)</span><br><span class=\"line\">    response = requests.get(url)</span><br><span class=\"line\">    xml_content = response.content.decode(<span class=\"string\">&#x27;utf-8&#x27;</span>)</span><br><span class=\"line\">    root = ET.fromstring(xml_content)</span><br><span class=\"line\">    danmu_list = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> root.<span class=\"built_in\">iter</span>(<span class=\"string\">&#x27;d&#x27;</span>):</span><br><span class=\"line\">        danmu = d.text</span><br><span class=\"line\">        p_attrs = d.attrib[<span class=\"string\">&#x27;p&#x27;</span>]</span><br><span class=\"line\">        p_attrs_list = p_attrs.split(<span class=\"string\">&#x27;,&#x27;</span>)</span><br><span class=\"line\">        danmu_dict = &#123;</span><br><span class=\"line\">            <span class=\"string\">&#x27;text&#x27;</span>: danmu,</span><br><span class=\"line\">            <span class=\"string\">&#x27;time&#x27;</span>: <span class=\"built_in\">float</span>(p_attrs_list[<span class=\"number\">0</span>]),</span><br><span class=\"line\">            <span class=\"string\">&#x27;mode&#x27;</span>: <span class=\"built_in\">int</span>(p_attrs_list[<span class=\"number\">1</span>]),</span><br><span class=\"line\">            <span class=\"string\">&#x27;fontsize&#x27;</span>: <span class=\"built_in\">int</span>(p_attrs_list[<span class=\"number\">2</span>]),</span><br><span class=\"line\">            <span class=\"string\">&#x27;color&#x27;</span>: <span class=\"built_in\">int</span>(p_attrs_list[<span class=\"number\">3</span>]),</span><br><span class=\"line\">            <span class=\"string\">&#x27;timestamp&#x27;</span>: <span class=\"built_in\">int</span>(p_attrs_list[<span class=\"number\">4</span>]),</span><br><span class=\"line\">            <span class=\"string\">&#x27;pool&#x27;</span>: <span class=\"built_in\">int</span>(p_attrs_list[<span class=\"number\">5</span>]),</span><br><span class=\"line\">            <span class=\"string\">&#x27;userid&#x27;</span>: p_attrs_list[<span class=\"number\">6</span>],</span><br><span class=\"line\">            <span class=\"string\">&#x27;rowid&#x27;</span>: <span class=\"built_in\">int</span>(p_attrs_list[<span class=\"number\">7</span>]),</span><br><span class=\"line\">            <span class=\"string\">&#x27;duration&#x27;</span>: <span class=\"built_in\">int</span>(p_attrs_list[<span class=\"number\">8</span>]),</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        danmu_list.append(danmu_dict)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> danmu_list</span><br></pre></td></tr></table></figure>\r\n<p>传入<code>cid</code>，b站的弹幕都存在<code>https://comment.bilibili.com/&#123;cid&#125;.xml</code>里，这个地址可以用浏览器直接访问。用爬虫访问这个URL，获取弹幕列表。</p>\r\n<h2 id=\"生成词云\">生成词云</h2>\r\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">word_cloud_generator</span>(<span class=\"params\">json_name</span>):</span><br><span class=\"line\">    <span class=\"comment\"># 读取json文件</span></span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(json_name, <span class=\"string\">&#x27;r&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        data = json.load(f)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 获取所有弹幕内容</span></span><br><span class=\"line\">    text = <span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        text += item[<span class=\"string\">&#x27;text&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 加载停用词表</span></span><br><span class=\"line\">    stopwords = <span class=\"built_in\">set</span>()</span><br><span class=\"line\">    <span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&#x27;cn_stopwords.txt&#x27;</span>, <span class=\"string\">&#x27;r&#x27;</span>, encoding=<span class=\"string\">&#x27;utf-8&#x27;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> f:</span><br><span class=\"line\">            stopwords.add(line.strip())</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 使用jieba进行分词，去掉停用词</span></span><br><span class=\"line\">    words = [word <span class=\"keyword\">for</span> word <span class=\"keyword\">in</span> jieba.cut(text) <span class=\"keyword\">if</span> word <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> stopwords]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 将分词结果转换为字符串</span></span><br><span class=\"line\">    words_str = <span class=\"string\">&#x27; &#x27;</span>.join(words)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 生成词云</span></span><br><span class=\"line\">    wc = WordCloud(background_color=<span class=\"string\">&#x27;white&#x27;</span>, width=<span class=\"number\">1000</span>, height=<span class=\"number\">800</span>, font_path=<span class=\"string\">&#x27;msyh.ttc&#x27;</span>)</span><br><span class=\"line\">    wc.generate(words_str)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    # 显示词云</span></span><br><span class=\"line\"><span class=\"string\">    plt.imshow(wc)</span></span><br><span class=\"line\"><span class=\"string\">    plt.axis(&#x27;off&#x27;)</span></span><br><span class=\"line\"><span class=\"string\">    plt.show()</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 保存词云</span></span><br><span class=\"line\">    filename = os.path.splitext(json_name)[<span class=\"number\">0</span>] + <span class=\"string\">&#x27;.png&#x27;</span></span><br><span class=\"line\">    wc.to_file(filename)</span><br></pre></td></tr></table></figure>\r\n<p>把获取的弹幕进行分词，这里使用了<code>jieba</code>中文分词，把句子分成词语。然后加载停用词表，去掉诸如这个、那个、是、吧等类似无意义的词语。设置词云图片的背景颜色，图片大小，生成词云图片。</p>\r\n<p><img\r\nsrc=\"https://raw.githubusercontent.com/vinouno/blog_image/main/danmu_BV12M4y1m7kf-%E9%A2%84%E8%A7%88.png\" /></p>\r\n","categories":["github项目"],"tags":["python","github","爬虫","词云","中文分词"]},{"title":"反常积分敛散性判别的万能公式","url":"/posts/78354348/","content":"<h1 id=\"万能公式\">万能公式</h1>\r\n<p><img\r\nsrc=\"https://raw.githubusercontent.com/vinouno/blog_image/main/%E7%A7%AF%E5%88%86%E5%88%A4%E6%95%9B%E4%B8%87%E8%83%BD%E5%85%AC%E5%BC%8F.png\" /></p>\r\n","categories":["考研数学笔记"],"tags":["考研数学","反常积分判敛"]},{"title":"微积分-求导数的难点","url":"/posts/56a5fadf/","content":"<h1 id=\"概述\">概述</h1>\r\n<p>汇总一下求导数方面的难点题</p>\r\n<h2 id=\"第453题\">660-第453题</h2>\r\n<p>设<span\r\nclass=\"math inline\">\\(F(x)=\\int_{0}^{x}\\mathrm{e}^{tx-t^2}\\)</span>，则<span\r\nclass=\"math inline\">\\(F^{&#39;}(x)=\\)</span></p>\r\n<p>这道题很明显可以发现，被积函数含参变量x，必须得消除x才能求导。</p>\r\n<p>难点就在于如何消除。</p>\r\n<p>通过配方法，在做变量替换，化为纯变限积分函数。</p>\r\n<h2 id=\"第455题\">660-第455题</h2>\r\n<p>设<span\r\nclass=\"math inline\">\\(f(x)=x^{100}\\mathrm{e}^{x^2}\\)</span>,则<span\r\nclass=\"math inline\">\\(f^{(200)}(0)=\\)</span></p>\r\n<p>求几百次导数，显然不能用常规的办法。</p>\r\n<p>既然要求x=0的取值，又求特别高阶，就用麦克劳林公式。</p>\r\n<p>根据下图写出f(x)的麦克劳林公式：</p>\r\n<p><img\r\nsrc=\"https://raw.githubusercontent.com/vinouno/blog_image/main/%E5%B8%B8%E7%94%A8%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F.jpg\" /></p>\r\n<p><span class=\"math display\">\\[\r\nf(x)=\\sum_{k=0}^{n}\\frac{x^{2k+100}}{k!}+o(x^{2n+100})\r\n\\]</span></p>\r\n<p>由于泰勒公式的唯一性，<span\r\nclass=\"math inline\">\\(f^{(200)}(0)=200!\\cdot\\frac{1}{50!}\\)</span>。</p>\r\n","categories":["考研数学笔记"],"tags":["微积分","导数"]},{"title":"算法笔记-综述","url":"/posts/41de9669/","content":"<h1 id=\"算法笔记-综述\">算法笔记-综述</h1>\r\n<p>聊聊算法笔记分类下的文章。</p>\r\n<h2\r\nid=\"在这个分类下写文章的初衷是什么\">在这个分类下写文章的初衷是什么？</h2>\r\n<p>目前，只是个人对leetcode刷题过程的记录，相当于私人笔记本。</p>\r\n<h2\r\nid=\"为什么有的文章带标题题号而有的文章没有\">为什么有的文章带标题题号，而有的文章没有？</h2>\r\n<p>标题带题号的文章，都是写题过程记的流水账，文字很少，只是对题目的简单描述，这种文章只起到记录的作用。</p>\r\n<p>不带题号的文章，大多是对一类型题的总结，文字内容比较多。</p>\r\n<h2 id=\"文章保证原创吗\">文章保证原创吗？</h2>\r\n<p>不保证，文章内有很多内容都是来自<a\r\nhref=\"https://programmercarl.com/\">代码随想录</a>和leetcode上的题解。</p>\r\n<h2 id=\"那为什么不标注出处\">那为什么不标注出处？</h2>\r\n<ul>\r\n<li>懒</li>\r\n<li>我认为没有必要。本站不打算吸引很多浏览者，个人性质的笔记没必要大费周章写明出处。</li>\r\n</ul>\r\n","categories":["算法笔记"],"tags":["综述"]},{"title":"考研复试：英语口语准备","url":"/posts/cc253f21/","content":"<p>自我介绍</p>\r\n<p>Good morning, teachers. I am really glad to be here for this\r\ninterview. Now, please allow me to give a brief self-introduction.</p>\r\n<p>My name is XXX, I come from Shuozhou, Shanxi Province, a beautiful\r\ncity. and I graduated from the University of Electronic Science and\r\nTechnology of China, majoring in Software Engineering.</p>\r\n<p>In general, I am a student who loves technology. Throughout my four\r\nyears in university, I engaged in numerous engineering practices and\r\ncompleted many projects.During my college years, I worked in the studio\r\nand the lab center of the college of Software, and completed some web\r\nback-end projects and put them into practical use, and my engineering\r\nability was recognized by the teachers of the college. Not only that,\r\nbut I was also active in algorithmic competitions and learning the\r\nbasics and won awards and scholarships.</p>\r\n<p>If I am fortunate enough to be admitted, I will be honored to study\r\nunder the guidance of the esteemed faculty members. I will undoubtedly\r\ndedicate myself to diligent study, actively practice what I learn, and\r\nstrive to become a person of value to our nation and society. This\r\nconcludes my self-introduction. Thank you for listening.</p>\r\n<p>你的家乡</p>\r\n<p>I'm from Shuozhou, Shanxi Province, and the local specialty is\r\nKnife-cut noodles. Shuozhou, historically known as Yanmen, is the\r\nhometown of Zhang Liao and Yu Chi Gong, two esteemed figures in Chinese\r\nhistory. Moreover, it is the ancestral home of Sa Zhenbing, a pivotal\r\nfigure in China's naval history. The unique influence of Sa Zhenbing on\r\nthe Chinese navy has sparked my interest in choosing your\r\ninstitution.</p>\r\n<p>你的爱好</p>\r\n<p>I enjoy reading, especially books on history and politics. I have a\r\nparticular fascination with ancient Chinese history, so I often read\r\nclassical Chinese literature. I believe that reading history can enhance\r\nmy knowledge and inspire passion for life.My favorite book is \"Records\r\nof the Three Kingdoms\" by Chen Shou. This book provides a true account\r\nof the history of the Three Kingdoms period.</p>\r\n<p>你的家庭</p>\r\n<p>There are four members in my family: My parents, my cute dog and me.\r\nMy father works at the railway company.He is often on duty. So most of\r\nthe housework is done by my industrious mom. Climbing at weekends is our\r\ncommon interest. The fresh air and natural beauty can help us get rid of\r\ntiredness. They can strengthen our relation, too. During my preparing\r\nfor coming here, my parents' love and support have always been my power.\r\nAnd I hope in future I will be able to repay them.</p>\r\n<p>你的优缺点</p>\r\n<p>My strengths are that I'm very studious and I can spend all day\r\ndrilling a puzzle without getting bored.</p>\r\n<p>My weakness is that I tend to be unconfident when doing things I'm\r\nnot good at. I have recognized this problem and am in the process of\r\ncorrecting it.</p>\r\n","categories":["考研复试"]},{"title":"考研复试：英语口语常问问题","url":"/posts/10ee4f95/","content":"<p>一、复试评分</p>\r\n<p>复试中的口试要求主要是从以下两个方面进行评价：</p>\r\n<p>①\r\n考查学生理解并回答有关日常生活、家庭、工作、学习等问题的能力(3分钟)。</p>\r\n<p>②\r\n考查学生连续表达的能力。考生从所给的问题中选择一个话题，就此话题表达自己的看法(3分钟)。</p>\r\n<p>二、考场注意</p>\r\n<p>1、第一句话</p>\r\n<p>见到考官的第一句话，很关键，不用说的很复杂。可以是一个简单句，但一定要铿锵有力。展示出自信和实力。千万不要来一句“Sorry,\r\nmy English is poor”。</p>\r\n<p>常见的开头有：</p>\r\n<p>I am glad to be here for this interview. First let me introduce\r\nmyself. I’m ...(姓名), my Number is…(编号).</p>\r\n<p>因为大多数高校，会让不少同学通过复试，所以参加面试的同学可能会有很多，每位同学可能会有一个考生编号，说一下自己的编号会显得很职业，正式。</p>\r\n<p>2、自我介绍</p>\r\n<p>作自我介绍——成长经历(making a self-introduction ——developing\r\nhistory)，有很多学校要求做一个自我介绍，但是你要注意的是，这个问题并不是在请你大谈你的个人历史。</p>\r\n<p>而是考官要在你的介绍中，找到有关你性格、资历、志向和生活动力等的线索。</p>\r\n<p>另外在介绍性格和爱好的时候，可以适当地结合一下家庭介绍，可以说说父母给了你哪些良好的影响，千万不要流水帐似的介绍家庭成员……</p>\r\n<p>3、没听懂问题怎么办?</p>\r\n<p>如果考官问其他的问题，但是没有听明白，一定要保持微笑，然后用任意一句回答：</p>\r\n<p>\"Could you speak slowly ?\"</p>\r\n<p>“I am sorry! I beg your pardon? \"</p>\r\n<p>\"I don't understand your question,could you repeat it again?\"</p>\r\n<p>三、常见问题</p>\r\n<p>在准备的过程中，一定不要光抄模板，要结合自己的经历和见解来准备，要让自己回答的问题和自我介绍融为一体，时刻都在加强考官对你的印象。</p>\r\n<p>如果你的回答没有圆回来，是很容易被考官抓住把柄，然后问个没完的，你再一紧张那现场的表现就有些不可控了。</p>\r\n<p>不过其实每一年的面试中，很多问题都是相同的，因为这些问题看起来很平常，但实际上是有很多陷阱的，比如下面这15个问题。(PS：划线的部分可代替)</p>\r\n<p>Q1. \"What can you tell me about yourself?\"\r\n(\"关于你自己，你能告诉我些什么?\")</p>\r\n<p>不完全等同于自我介绍，选一部分。(character, qualifications,\r\nambitions, and motivations)</p>\r\n<p>Q2. \"What would you like to be doing five years after\r\ngraduation?\"(\"毕业5年后你的计划\")</p>\r\n<p>If possible, I will go on with my study for doctorate degree. After\r\ngraduating received doctorate degree, I wanted to teach in university,\r\nand continue research in Archaian(古代的) literature field,I hope I can\r\nhave some achievement in my major.</p>\r\n<p>(举个栗子：\"我要读博，继续留校深造\")</p>\r\n<p>Q3. \"What is your greatest strength\"?\" (\"你最突出的优点是什么?\")</p>\r\n<p>这是你展示自己的最佳机会，不要吹嘘自己或过于自负，尽可能展现你的自信和优点。</p>\r\n<p>\"I feel that my strongest asset is my ability to stick to things to\r\nget them done. I feel a real sense of accomplishment when I finish a job\r\nand it turns out just as I'd planned. I've set some high goals for\r\nmyself. For example, I want to graduate with highest distinction.</p>\r\n<p>(举个栗子：\"我认为我最大的优点是能够执着地尽力把事情办好。当做完一件工作而其成果又正合我的预想时，我会有一种真正的成就感。我给自己定了一些高目标。比如说，我要成为出色的毕业生。)</p>\r\n<p>Q4. \"What is your greatest weakness?\"(\"你最大的弱点是什么?\")</p>\r\n<p>这时不要说你没有任何弱点，以此来回避这个问题;要在承认弱点的同事，还要表明你在予以改进，并且还有克服弱点的计划。</p>\r\n<p>Maybe because I am young people, I am a short fuse girl in daily\r\nlife, fortunately I have realized it was disadvantage, and I am trying\r\nmy best to get rid of it.</p>\r\n<p>(举个栗子：”我是个暴脾气的妹子，我知道这是不好的，我已经开始努力改正了，我是这样改正的……”。)</p>\r\n<p>Q5. ”How do you feel about your progress to\r\ndate?“(\"对于你至今所取得的进步你是怎样看的?\")</p>\r\n<p>\"I think I did well in school. But I am clear that I still have a\r\nlong way to walk to realize my dream and finally achieve self-value. I\r\nwill try my best.</p>\r\n<p>(举个栗子：\"我认为我在学校做得很好了，我做了这些这些还有这些，但是我知道我的路还长，但我会尽我全力去追梦的\"。)</p>\r\n<p>Q6. ”What has been your greatest\r\naccomplishment?“(”你目前取得最大的成就是什么?“)</p>\r\n<p>I will try my best to accomplish my plan as soon as I make a good\r\nchoose, and I am not distracted by circumstance and I never give up my\r\nchoose, such as this postgraduate exams.</p>\r\n<p>(举个栗子：\"我会尽我所能，尽快完成我的计划，因为我有一个好的选择，我会在不分心的情况下，我从来没有放弃我选择这样的研究生考试。\")</p>\r\n<p>Q7. ”What are some of the things you find difficult to\r\ndo?\"(\"对你来说困难的事有哪些?\")</p>\r\n<p>I don’t discouragement, on the contrary, I will actively think\r\nmeasure to conquer it and put measure into practice, I am sure I will\r\nsucceed in the end.</p>\r\n<p>(举个栗子：”我遇到的困难有这些这些这些，但是我从不气馁，我会积极思考克服困难的措施，并付诸实施，像这样解决，我相信我最终会成功的。“)</p>\r\n<p>Q8. ”What is the worst thing you have heard about our\r\nuniversity?”(\"关于我们学校你听过最糟糕的事是什么?\")</p>\r\n<p>To tell the truth, I don’t completely know our university, I know it\r\nonly by internet and some students, so I don’t randomly value it, but\r\nduring my preparing this postgraduate exams, I obtained some helps\r\ncoming from our university. They were very warmhearted, and I very\r\nappreciate them. In a word, I have very good impression about our\r\nuniversity.</p>\r\n<p>(举个栗子：\"说实话，我并不完全了解我们的大学，我只知道通过互联网和一些学生，所以我不随意评价它，但在我准备研究生考试时，我得到了一些来自我们大学的帮助。他们非常热情，我非常感激他们。总之，我有非常好的印象，对我们的大学。“)</p>\r\n<p>Q9. ”Describe your best friend and what he or she does for a\r\nliving.”(\"描述你最好的朋友和他是如何生活的。\")</p>\r\n<p>First of all, I have many good friends; we often study, discuss and\r\nplay in harness. To speak of my best friend, maybe it belongs to **, she\r\nis a warmhearted, hardworking strong-minded girl, we were favor in\r\ndiscussing some our interesting questions.She also took the postgraduate\r\nexams, and obtained very good result. I heartily hope she has a happy\r\nfuture.</p>\r\n<p>(举个栗子：\"首先，我有很多很好的朋友，我们经常一起学习，讨论和玩耍。谈论我最好的朋友，也许就是**，她是一个热情，勤奋坚强的女孩，我们喜欢讨论一些有趣的问题。她还参加了研究生考试，并取得了很好的效果。我衷心希望她有一个快乐的未来。\")</p>\r\n<p>Q10. ”In what ways are you similar or different from your best\r\nfriend?\"(\"在哪些方面你与你最好的朋友有什么相同或不同?\")</p>\r\n<p>I think we have many similar characters, such as warmhearted,\r\nhardworking etc. To mention difference, I think the big difference is\r\nthat she do anything slowly, on the contrary, I am short fuse. Maybe we\r\ncan supervise and urge both sides, so we are very good friends.</p>\r\n<p>(举个栗子：\"我想我们有很多相似的性格特点，如热情，勤奋等。谈到不同，我认为最大的不同是，她慢慢地做任何事情，相反，我脾气暴躁。也许我们可以督促双方，所以我们非常好的朋友。\")</p>\r\n<p>Q11. ”Are you a happy person?\"(\"你是一个快乐的人吗?\")</p>\r\n<p>Yes, of course. First, I have a happy family, I love my parents and\r\nthey love me, too. Second, I have a health body. Finally, I study the\r\nmajor that I very like. Though I have no many money, but I don’t envy\r\npeople who own much money, I can create life by my both hands, I think I\r\nam very happy.</p>\r\n<p>(举个栗子：“是的，当然。首先，我有一个幸福的家庭，我爱我的父母，他们也爱我。第二，我有一个健康的身体。最后，我很喜欢我的专业。虽然我没有很多钱，但我不羡慕谁拥有多少钱，我可以通过我的双手生活，我觉得我很高兴。”)</p>\r\n<p>Q12. ”If you failed this time what will you do in the near\r\nfuture?\"(\"如果这次你失败了,在不久的将来你会怎样做?\")</p>\r\n<p>I very clear that life is not successful at any time, it is full of\r\nchallenge, so I prepare for receiving challenge coming from life and I\r\nalso tell myself I never give up at any moment. Now, I also receive\r\nchallenge, I only think try my best to pass this challenge. No matter\r\nwhat result is. I never give up my pursuit and my dream.</p>\r\n<p>(举个栗子：“我很清楚，生活并不会每时每刻都很成功，它是充满挑战，所以我准备接受生活中的挑战，我也告诉自己，我永远不会放弃在任何时候，我会这样这样这样做。现在，我也接受挑战，我只是觉得，尽我所能通过这一挑战。无论什么结果。我从来不会放弃我的追求和梦想。”)</p>\r\n<p>Q13. ”What kinds of opportunities are you looking\r\nfor?\"(\"你正在寻找什么样的机会?\")</p>\r\n<p>I think that life fills with opportunities; people try their best to\r\nlooking for opportunities, of course, including me. But I think the most\r\nimportant is how you seize every opportunity to make you succeed.</p>\r\n<p>(举个栗子：\"我认为，人生充满了机会，人们尽力寻找机会，当然，包括我在内。但我认为最重要的是你如何抓住每一个机会，使你成功。\")</p>\r\n<p>Q14. ”Say a little about your educational\r\nbackground.\"(\"介绍一点你的教育背景。“)</p>\r\n<p>I come from a suburb of Luoyang.My elementary school and my junior\r\nhigh school is located my village, I spend my elementary school and my\r\njunior high school during 2003 to 2012. During 2012 to 2015, I study in\r\nmy senior high school in Luoyang city. From two thousand and one to\r\ndate, I studied in Luoyang normal college.</p>\r\n<p>(举个栗子：\"我一些来自洛阳市郊区。我和我的小学初中位于我的村庄，2003年到2012年，我完成了小学初中的学业。在2012年至2015年，我在洛阳市上了高中。从2015年至今，我就读于洛阳师范学院。\")</p>\r\n<p>Q15. ”What do you do in your spare\r\ntime?”(\"你在你的空闲时间都做什么?\")</p>\r\n<p>In my spare time, I like reading books, writing life sentiment,\r\nlistening music, communicating with friends, and so on.</p>\r\n<p>(举个栗子：\"在我的业余时间，我喜欢看书，写作的生活情绪，听音乐，与朋友交流，等等。\")</p>\r\n<p>Q16. ”What is your impression of Nanjing? (\"你对南京的印象如何?\")</p>\r\n<p>Maybe because I have good impression to Nanjing people, I have good\r\nimpression to Nanjing, Nanjing is the city that owns some history base,\r\nit is very good to me, I like this city.</p>\r\n<p>(举个栗子：\"也许因为我对南京人有很好的印象，他们这样这样这样，所以我对南京也有很好的印象。南京是一座拥有历史基础的城市，这非常适合我，我喜欢这座城市。\")</p>\r\n","categories":["考研复试"],"tags":["资料存档","非原创"]},{"title":"用像素画一棵树吧","url":"/posts/feda20cd/","content":"<h1 id=\"绘画步骤\">绘画步骤</h1>\r\n<p>像素画是一种新兴的艺术形式，一般被应用在一些小游戏里。</p>\r\n<p>究其本质，和传统绘画是一样的，重点在于轮廓和色彩。接下来，我们通过画一棵树，来展现像素画的一般步骤。</p>\r\n<h2 id=\"抽象成几何图形\">抽象成几何图形</h2>\r\n<p>任何图形，都可以被抽象成若干几何图形的组合：比如平行四边形、梯形、椭圆等。</p>\r\n<p>画一颗树也是如此，因此，我们可以把树抽象成这样的几何图形：上面一个椭圆表示树冠、下面一个矩形表示树干。</p>\r\n<h2 id=\"整形补充细节\">整形、补充细节</h2>\r\n<p>显然这么简单的图形是没法表现一棵树的，因此我们应该增加一些细节： -\r\n在矩形和圆的连接处留空，表示分开的树杈。 -\r\n矩形的底部延伸出几条线，表示根。 -\r\n椭圆的外延，沿弧线的切线方向衍生出若干不规则的毛刺，表示向外延伸的树冠。</p>\r\n<p>完成这些步骤，这个图形就有树的雏形了。</p>\r\n<h2 id=\"定义光源区分明暗\">定义光源、区分明暗</h2>\r\n<p>可以假设照射这棵树的阳光来自右上，这样就可以用浅灰、深灰和黑色，分别表示树受到强烈光照、一般光照、较少光照的部分。</p>\r\n<p>由于光源在右上角，浅灰的部分会集中在右上，黑色的部分则集中在左下。</p>\r\n<p>由于树冠是不规则的，自由生长的，我们可以想象，这棵树有两个亮面，一个在右上，一个在正面偏左的位置。浅灰和深灰交替分布，但是仍然要遵循一个原则：离光源越近，明亮的部分就分布越密。</p>\r\n<h2 id=\"上色\">上色</h2>\r\n<p>我们可以先调出树叶的绿色和树干的棕色。\r\n运用色轮的知识，分别调出这两个颜色的亮色和暗色。把这些色彩涂在树上，一颗树就完成了。</p>\r\n<h2 id=\"成果展示\">成果展示</h2>\r\n<p>这是放大十倍的效果图，也许看上去还有些不自然的地方：</p>\r\n<p><img\r\nsrc=\"https://raw.githubusercontent.com/vinouno/blog_image/main/%E6%A0%91-%E5%A4%A7.png\" /></p>\r\n<p>但是这棵树只是在48px*48px画布上完成的一个简单作品，如果只放大四倍，问题就没那么大了。</p>\r\n<p><img\r\nsrc=\"https://raw.githubusercontent.com/vinouno/blog_image/main/%E6%A0%91-%E5%B0%8F.png\" /></p>\r\n<p>如果再画几棵形态各异的树，把它们放在树林场景里，就非常自然了。</p>\r\n<h1 id=\"补充知识\">补充知识</h1>\r\n<p>像素画是一种简单的绘画形式，一个初学者只要几天就能画出像样的画来。\r\n但是，形式上的简单不代表我们可以忽视其他绘画形式所需的基础知识。</p>\r\n<h2 id=\"色轮\">色轮</h2>\r\n<p><img\r\nsrc=\"https://raw.githubusercontent.com/vinouno/blog_image/main/%E8%89%B2%E8%BD%AE.png\" /></p>\r\n<h3 id=\"第一次色第二次色和第三次色\">第一次色、第二次色和第三次色</h3>\r\n<p>绘画中，我们可以把红、黄、蓝定义为三原色，又名第一次色。</p>\r\n<p>第一次色两两混合，又产生了绿、橙、紫三色，称为第二次色。</p>\r\n<p>第一次色和相邻的第二次色混合，会产生六种更中间的颜色。</p>\r\n<p>把这十二种颜色按顺序排列在一个圆上，就得到了十二色相环。</p>\r\n<h3 id=\"色相饱和度明度\">色相、饱和度、明度</h3>\r\n<ul>\r\n<li>色相指的是色彩在色相环所处的位置。因为圆是360度的，所以它的数值范围是0-360。</li>\r\n<li>饱和度是指色彩的鲜艳程度。个人理解，就是和灰色的混合程度。饱和度越低，颜色就越灰；饱和度越高，颜色就越鲜艳。因为这是一个百分数，所以数值范围是0-100.</li>\r\n<li>明度是指色彩的明亮程度。个人理解，就是混合的灰色所占的黑白比例。明度越高，就越白；明度越低，就越黑。</li>\r\n</ul>\r\n<h3 id=\"冷暖色补偿色\">冷暖色、补偿色</h3>\r\n<p>冷暖色是色彩给人心理上感觉。红、黄、橙是暖色，而绿、蓝、紫是冷色。\r\n补偿色是指在色轮上位置相对的颜色，这两种颜色对比最强烈。比如橙色和蓝色，如果在一片蓝天中画一个橙色的太阳，强烈的对比会一下子吸引住观赏者。</p>\r\n<h3 id=\"色彩与光照\">色彩与光照</h3>\r\n<p>遵照如下的原则，就可以找到一个色彩的亮色和暗色。</p>\r\n<table>\r\n<thead>\r\n<tr class=\"header\">\r\n<th style=\"text-align: center;\"></th>\r\n<th style=\"text-align: center;\">强光照</th>\r\n<th style=\"text-align: center;\">弱光照</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">色相</td>\r\n<td style=\"text-align: center;\">更暖</td>\r\n<td style=\"text-align: center;\">更冷</td>\r\n</tr>\r\n<tr class=\"even\">\r\n<td style=\"text-align: center;\">饱和度</td>\r\n<td style=\"text-align: center;\">更鲜艳</td>\r\n<td style=\"text-align: center;\">更灰暗</td>\r\n</tr>\r\n<tr class=\"odd\">\r\n<td style=\"text-align: center;\">明度</td>\r\n<td style=\"text-align: center;\">更亮</td>\r\n<td style=\"text-align: center;\">更暗</td>\r\n</tr>\r\n</tbody>\r\n</table>\r\n<h2 id=\"抗锯齿\">抗锯齿</h2>\r\n<p>线条是物体轮廓的组成部分，充满锯齿和毛刺的像素线条是非常违和的，我们追求的是自然的线条。一种常用的办法是用更亮的颜色填充线条的外围，做出半透明的质感。</p>\r\n<h2 id=\"负空间\">负空间</h2>\r\n<p>练习像素画的过程中少不了临摹，判断临摹的像不像，要关注临摹作品的负空间。</p>\r\n","categories":["绘画笔记"],"tags":["像素画","教程学习"]},{"title":"微积分-求极限的难点","url":"/posts/687b653/","content":"<h1 id=\"概述\">概述</h1>\r\n<p>总结一下求极限问题中遇到的难以上手的题。</p>\r\n<p>我最熟练的方法是使用泰勒公式，它适用于占比最大的，在<span\r\nclass=\"math inline\">\\(\\lim_{x\\to0}\\)</span> 情况下的<span\r\nclass=\"math inline\">\\(\\frac{0}{0}\\)</span>型极限。</p>\r\n<p>现在还存在一些问题：</p>\r\n<ul>\r\n<li>有的题用洛必达方法更简单，泰勒公式反而是绕路了</li>\r\n<li>对于三角函数相关题目不熟悉</li>\r\n<li>对需要使用夹逼的题目不熟悉</li>\r\n</ul>\r\n<h2 id=\"第435题\">660-第435题</h2>\r\n<p>求数列极限：</p>\r\n<p><span class=\"math display\">\\[\r\nI=\\lim_{n\\to\\infty} n\\tan(\\pi\\sqrt{n^2+1})\r\n\\]</span></p>\r\n<p>注意观察题目：</p>\r\n<ul>\r\n<li>这是一道三角函数相关的题目</li>\r\n<li>这不是普通的求极限，而是数列极限，意味着n是一个整数。</li>\r\n</ul>\r\n<p>题目暗示得很明显，这道题要用到，诱导公式：</p>\r\n<p><span class=\"math display\">\\[\r\n\\tan x = \\tan(x - n\\pi)\r\n\\]</span></p>\r\n<h2 id=\"第442题\">660-第442题</h2>\r\n<p>求极限：</p>\r\n<p><span class=\"math display\">\\[\r\nI=\\lim_{x\\to+\\infty}(\\sin\\sqrt{x+1} - \\sin\\sqrt{x})\r\n\\]</span></p>\r\n<p>刚看到这道题的时候，第一反应是运用<strong>拉格朗日中值定理</strong>。但是很明显<span\r\nclass=\"math inline\">\\(f^{&#39;}(\\xi)\\)</span>是没法求得的，因为<span\r\nclass=\"math inline\">\\(\\cos(x)\\)</span>在正无穷的时候，并不是一个定值，所以这个方法行不通。</p>\r\n<p>另一种办法，就是和差化积。</p>\r\n<p><span class=\"math display\">\\[\r\nsin\\alpha - sin\\beta=2\\cdot\\cos\\frac{\\alpha +\r\n\\beta}{2}\\cdot\\sin\\frac{\\alpha - \\beta}{2}\r\n\\]</span></p>\r\n<h2 id=\"将来在此处补充一道夹逼定理\">将来在此处补充一道夹逼定理</h2>\r\n","categories":["考研数学笔记"],"tags":["微积分","极限","三角函数","和差化积","积化和差","诱导公式"]},{"title":"范德蒙行列式","url":"/posts/421e91bc/","content":"<h1 id=\"范德蒙行列式\">范德蒙行列式</h1>\r\n<p>范德蒙行列式（Vandermonde\r\ndeterminant）是一种特殊的行列式，它由一组不同的数所构成的<span\r\nclass=\"math inline\">\\(n\\)</span>维向量空间中的<span\r\nclass=\"math inline\">\\(n\\)</span>个向量的行列式组成。具体来说，如果<span\r\nclass=\"math inline\">\\(x_1,x_2,\\ldots,x_n\\)</span>是<span\r\nclass=\"math inline\">\\(n\\)</span>个不同的实数或复数，则范德蒙行列式定义为：</p>\r\n<p><span class=\"math display\">\\[\r\n\\begin{vmatrix}\r\n1 &amp; x_1 &amp; x_1^2 &amp; \\cdots &amp; x_1^{n-1} \\\\\r\n1 &amp; x_2 &amp; x_2^2 &amp; \\cdots &amp; x_2^{n-1} \\\\\r\n\\vdots &amp; \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\r\n1 &amp; x_n &amp; x_n^2 &amp; \\cdots &amp; x_n^{n-1}\r\n\\end{vmatrix}\r\n= \\prod_{1 \\leq i &lt; j \\leq n} (x_j-x_i)\r\n\\]</span></p>\r\n<p>其中的乘积表示对所有<span\r\nclass=\"math inline\">\\(i&lt;j\\)</span>的项的乘积。范德蒙行列式在数学和物理中有广泛的应用，特别是在描写离散点的多项式拟合、计算内积和求解线性方程组等方面。</p>\r\n","categories":["考研数学笔记"],"tags":["考研数学","范德蒙行列式"]},{"title":"微积分-求积分的难点","url":"/posts/b3a6362f/","content":"<h1 id=\"概述\">概述</h1>\r\n<p>汇总一下求积分问题的难点。</p>\r\n<h2 id=\"第467题常规公式\">660-第467题(常规公式)</h2>\r\n<p>不定积分<span\r\nclass=\"math inline\">\\(\\int\\frac{x+2}{x^2+2x+2}\\mathrm{d}x=\\)</span></p>\r\n<p>这道题的分母不能简单地拆分成两个式子相乘。</p>\r\n<p>必须对常规的公式非常熟悉，才能看出拆分方法。</p>\r\n<p><span class=\"math display\">\\[\r\nI=\r\n\\int\\frac{(x+1)+1}{(x+1)^2+1}\\mathrm{d}x=\r\n\\int\\frac{(x+1)+1}{(x+1)^2+1}\\mathrm{d}x=\r\n\\frac{1}{2}\\ln (x^2+2x+2) + \\arctan(1+x) + C\r\n\\]</span></p>\r\n<h2 id=\"第469题奇偶性\">660-第469题(奇偶性)</h2>\r\n<p>设a&gt;0,则<span class=\"math inline\">\\(I =\r\n\\int_{-a}^{a}\\sqrt{a^2-x^2}\\ln\\frac{x+\\sqrt{1+x^2}}{3}\\mathrm{d}x=\\)</span></p>\r\n<p>看到积分区间是对称的，就该想到积分的奇偶性。</p>\r\n<p><span class=\"math display\">\\[\r\nI=\\int_{-a}^{a}\\sqrt{a^2-x^2}\\ln(x+\\sqrt{1+x^2})\\mathrm{d}x-\\int_{-a}^{a}\\sqrt{a^2-x^2}\\ln3\\mathrm{d}x\r\n\\]</span></p>\r\n<p>前半部分是奇函数，后半部分可以用定积分的几何意义解题。</p>\r\n<p>所以答案是<span class=\"math inline\">\\(-\\frac{1}{2}\\pi\r\na^2\\ln3\\)</span>。</p>\r\n<h2 id=\"第472题凑根式换元\">660-第472题(凑根式换元)</h2>\r\n<p><span class=\"math display\">\\[\r\nI=\\int{\\frac{\\mathrm{d}x}{\\sqrt{(x-a)(b-x)}}}(a&lt;x&lt;b)=\r\n\\]</span></p>\r\n<p>转化为被积函数中含有形如<span\r\nclass=\"math inline\">\\(\\sqrt[n]{\\frac{ax+b}{cx+d}}\\)</span>的根式的积分。</p>\r\n<p><span class=\"math display\">\\[\r\nI=\\int{\\frac{1}{x-a}}\\sqrt{\\frac{x-a}{b-x}}\\mathrm{d}x\r\n\\]</span></p>\r\n<p>然后用换元法,令<span\r\nclass=\"math inline\">\\(t=\\sqrt{\\frac{x-a}{b-x}}\\)</span>,则x=<span\r\nclass=\"math inline\">\\(\\frac{a+bt^2}{1+t}\\)</span></p>\r\n<h2 id=\"第474题三角换元\">660-第474题(三角换元)</h2>\r\n<p><span class=\"math display\">\\[\r\n\\int^{+\\infty}_3{\\frac{\\mathrm{d}x}{(x-1)^4\\sqrt{x^2-2x}}}\r\n\\]</span></p>\r\n<p>第一次做到这个题的时候，已经意识到<span\r\nclass=\"math inline\">\\(x^2-2x=(x-1)^2-1\\)</span>，但是对三角换元没有足够的积累。</p>\r\n<p>在这里总结如下（待补充）。</p>\r\n<p><span class=\"math display\">\\[\r\n1-x^2\\sim t=\\sin{x}\\quad x\\in(-1,1),t\\in(-\\frac{\\pi}{2},\\frac{\\pi}{2})\\\\\r\na^2-x^2\\sim t=\\sin{\\frac{x}{a}}\\quad\r\nx\\in(-1,1),t\\in(-\\frac{\\pi}{2},\\frac{\\pi}{2})\\\\\r\n1+x^2\\sim t=\\tan{x}\\quad\r\nx\\in(-\\infty,+\\infty),t\\in(-\\frac{\\pi}{2},\\frac{\\pi}{2})\\\\\r\na^2+x^2\\sim t=\\tan{\\frac{x}{a}}\\quad\r\nx\\in(-\\infty,+\\infty),t\\in(-\\frac{\\pi}{2},\\frac{\\pi}{2})\\\\\r\nx^2-1\\sim t=\\sec{x}\\quad\r\nx\\in(-\\infty,-1)\\cup(1,+\\infty),t\\in(0,-\\frac{\\pi}{2})\\cup(\\frac{\\pi}{2},+\\infty)\\\\\r\n\\]</span></p>\r\n<h2 id=\"第476题利用关系式和换元\">660-第476题(利用关系式和换元)</h2>\r\n<p><span class=\"math display\">\\[\r\n设当0\\leq x \\leq \\pi时f(x)=x,且对一切x，f(x)=f(x-\\pi)+\\sin\r\nx,则\\int^{3\\pi}_\\pi f(x)\\mathrm{d}x=\r\n\\]</span></p>\r\n<p><img\r\nsrc=\"https://raw.githubusercontent.com/vinouno/blog_image/main/660-476.png\" /></p>\r\n<h2 id=\"题倍角公式\">660-491题(倍角公式)</h2>\r\n<p>把原题简化，仅仅保留积分的部分：</p>\r\n<p><span class=\"math display\">\\[\r\n\\int{\\frac{1}{\\sin{x}}}=\\int{\\frac{1}{2\\tan{x\\cos^2{x}}}}=\\ln\\lvert\\tan\\frac{u}{2}\\rvert+C\r\n\\]</span></p>\r\n","categories":["考研数学笔记"],"tags":["微积分","积分","奇偶性","换元","三角换元"]},{"title":"双指针操作数组","url":"/posts/ce6d7c23/","content":"<h1 id=\"双指针操作数组\">双指针操作数组</h1>\r\n<p>双指针法，又称快慢指针法，是数组题中比较简单的一种。\r\n通过一个快指针和慢指针在一个for循环下完成两个for循环的工作，把复杂度为O(n^2)的暴力法优化为O(n)。\r\n## Example\r\n之前做的题目，一两次就过了,没特别深的印象，等遇到难的题目再补充。</p>\r\n<p><a href=\"https://leetcode.cn/problems/remove-element/\">leetcode-27.\r\n移除元素</a> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">removeElement</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums, <span class=\"type\">int</span> val)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> slowIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> fastIndex = <span class=\"number\">0</span>; fastIndex &lt; nums.<span class=\"built_in\">size</span>(); fastIndex++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(val != nums[fastIndex])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                nums[slowIndex++] = nums[fastIndex];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slowIndex;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n<p><a\r\nhref=\"https://leetcode.cn/problems/remove-duplicates-from-sorted-array/\">leetcode-26.\r\n删除有序数组中的重复项</a> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">removeDuplicates</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> slowIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> fastindex = <span class=\"number\">1</span>; fastindex &lt; nums.<span class=\"built_in\">size</span>();fastindex++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(nums[fastindex] != nums[fastindex<span class=\"number\">-1</span>])</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                slowIndex++;</span><br><span class=\"line\">                nums[slowIndex] = nums[fastindex];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> slowIndex + <span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n<p><a href=\"https://leetcode.cn/problems/move-zeroes/\">leetcode-283.\r\n移动零</a> <figure class=\"highlight c++\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">moveZeroes</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"type\">int</span> slowIndex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> fastIndex = <span class=\"number\">0</span>; fastIndex &lt; nums.<span class=\"built_in\">size</span>(); fastIndex++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nums[fastIndex] != <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                nums[slowIndex++] = nums[fastIndex];</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">while</span>(slowIndex &lt; nums.<span class=\"built_in\">size</span>())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                nums[slowIndex++] = <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\r\n","categories":["算法笔记"],"tags":["双指针","数组"]}]