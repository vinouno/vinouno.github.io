<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/logo%20(2).png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/logo%20(3).png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/logo%20(4).png">
  <link rel="mask-icon" href="/images/logo%20(1).png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"vinouno.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.json"};
  </script>
  <meta name="description" content="CSAPP 第三章：程序的机器级表示">
<meta property="og:type" content="article">
<meta property="og:title" content="CSAPP 第三章：程序的机器级表示">
<meta property="og:url" content="https://vinouno.github.io/posts/adc3eca/index.html">
<meta property="og:site_name" content="老泉杂记">
<meta property="og:description" content="CSAPP 第三章：程序的机器级表示">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-05-21T03:55:10.000Z">
<meta property="article:modified_time" content="2023-11-03T03:50:23.200Z">
<meta property="article:author" content="裘千丈">
<meta property="article:tag" content="CSAPP">
<meta property="article:tag" content="汇编语言">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://vinouno.github.io/posts/adc3eca/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>CSAPP 第三章：程序的机器级表示 | 老泉杂记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">老泉杂记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-calendar fa-fw"></i>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/vinouno" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://vinouno.github.io/posts/adc3eca/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.png">
      <meta itemprop="name" content="裘千丈">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="老泉杂记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          CSAPP 第三章：程序的机器级表示
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-05-21 11:55:10" itemprop="dateCreated datePublished" datetime="2023-05-21T11:55:10+08:00">2023-05-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-11-03 11:50:23" itemprop="dateModified" datetime="2023-11-03T11:50:23+08:00">2023-11-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index"><span itemprop="name">CSAPP</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>17k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>28 分钟</span>
            </span>
            <div class="post-description"><div align="center">CSAPP 第三章：程序的机器级表示</div></div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="csapp-第三章程序的机器级表示">CSAPP
第三章：程序的机器级表示</h1>
<h2 id="历史观点">3.1 历史观点</h2>
<h3 id="摩尔定律">摩尔定律</h3>
<p>摩尔定律（Moore's
Law：是由英特尔公司的联合创始人之一戈登·摩尔（Gordon
Moore）在1965年提出的经验观察和预测。摩尔定律指出，集成电路上可容纳的晶体管数量每隔约18个月翻倍，同时造价减半。换句话说，摩尔定律认为集成电路的性能将以指数级增长，而成本则将相对下降。</p>
<p>摩尔定律的观察基础是在集成电路中使用的晶体管数量和密度不断增加，这使得处理器的速度和性能也在不断提高。这一观察发展为一个准则，成为计算机硬件行业的重要指导原则。</p>
<p>摩尔定律的实际效应是，在相同的芯片面积上，可以集成更多的晶体管，从而提高处理器的性能。这使得计算机和其他电子设备变得更快、更小、更强大，并带来了信息技术的快速发展。</p>
<h3 id="x86和x86-64">X86和X86-64</h3>
<p>x86是一种32位的处理器架构，最初由英特尔（Intel）开发并推广。它是基于英特尔的8086和8088处理器设计的，并成为个人电脑（PC）中最为广泛使用的架构之一。x86架构支持32位寻址和32位数据处理，其指令集和寄存器设计是基于32位的。</p>
<p>x86-64（也称为AMD64或x64）是x86架构的64位扩展。它由AMD首先引入，并得到了其他处理器制造商的采纳，包括英特尔。x86-64架构扩展了x86的寻址空间和寄存器大小，支持64位寻址和64位数据处理。这使得x86-64处理器能够处理更大的内存地址空间和执行更复杂的计算任务。与传统的32位x86架构相比，x86-64架构在处理器性能和内存管理方面有显著的优势。</p>
<p>x86-64架构是目前个人电脑和服务器领域最为广泛使用的处理器架构之一。它支持运行32位和64位的操作系统和应用程序，提供了更高的性能和更大的灵活性。许多现代操作系统和软件都提供了针对x86-64架构的优化版本，以充分利用其性能和功能。</p>
<h2 id="程序编码">3.2 程序编码</h2>
<h3 id="汇编过程">汇编过程</h3>
<p>编译C语言程序的过程：</p>
<ol type="1">
<li><p>预处理（Preprocessing）：编译器对源代码进行预处理，包括宏展开、头文件包含等操作。预处理器可以根据#include指令将其他文件的内容插入源文件中，并对宏进行替换。</p></li>
<li><p>编译（Compilation）：编译器将预处理后的源代码转换为汇编代码（Assembly
Code），即将C语言的代码转换为机器可以理解的低级指令。</p></li>
<li><p>汇编（Assembly）：汇编器将汇编代码转换为机器码，即可执行的二进制指令。汇编器将每条汇编指令翻译成对应的机器指令，并生成目标文件（Object
File）。</p></li>
<li><p>链接（Linking）：链接器将目标文件与所需的库文件进行链接，生成最终的可执行文件（Executable
File）。链接器将目标文件中的函数和变量引用与其定义进行匹配，解析符号引用，并将它们关联起来。</p></li>
</ol>
<h3 id="attatt和intel的语法区别">ATT（AT&amp;T）和Intel的语法区别</h3>
<p>ATT（AT&amp;T）和Intel是两种不同的汇编语法格式，它们主要在语法结构和指令书写上存在一些区别。</p>
<ol type="1">
<li>语法结构：
<ul>
<li>ATT语法：源操作数在前，目的操作数在后，使用逗号分隔。例如：<code>movl %eax, %ebx</code>。</li>
<li>Intel语法：目的操作数在前，源操作数在后，使用逗号分隔。例如：<code>mov ebx, eax</code>。</li>
</ul></li>
<li>寄存器命名：
<ul>
<li>ATT语法：寄存器名称以<code>%</code>开头。例如：<code>%eax</code>。</li>
<li>Intel语法：寄存器名称没有特殊的符号前缀。例如：<code>eax</code>。</li>
</ul></li>
<li>立即数和内存引用：
<ul>
<li>ATT语法：立即数使用<code>$</code>符号表示，内存引用使用括号表示。例如：<code>movl $10, %eax</code>（将立即数10移动到eax寄存器）；<code>movl (%ebx), %eax</code>（将ebx寄存器指向的内存地址的值移动到eax寄存器）。</li>
<li>Intel语法：立即数没有特殊符号表示，内存引用使用方括号表示。例如：<code>mov eax, 10</code>（将立即数10移动到eax寄存器）；<code>mov eax, [ebx]</code>（将ebx寄存器指向的内存地址的值移动到eax寄存器）。</li>
</ul></li>
<li>操作数大小：
<ul>
<li>ATT语法：根据操作数的大小，使用不同的后缀来表示，如<code>b</code>表示字节（byte），<code>w</code>表示字（word），<code>l</code>表示双字（double
word）。例如：<code>movb $1, %al</code>（将立即数1移动到al寄存器，al为8位寄存器）。</li>
<li>Intel语法：操作数的大小根据指令而定，不需要显式指定后缀。例如：<code>mov al, 1</code>（将立即数1移动到al寄存器，al为8位寄存器）。</li>
</ul></li>
</ol>
<p>需要注意的是，不同的汇编器可能支持不同的语法格式，默认使用的是特定的汇编语法。在使用汇编语言时，应根据所选的语法格式编写相应的汇编代码。</p>
<h2 id="数据格式">3.3 数据格式</h2>
<p>下面是常见的C语言数据类型在x86-64架构中的Intel数据类型、汇编代码后缀和大小（以字节为单位）的表格：</p>
<table>
<thead>
<tr>
<th>C数据类型</th>
<th>Intel数据类型</th>
<th>汇编代码后缀</th>
<th>大小（字节）</th>
</tr>
</thead>
<tbody>
<tr>
<td>char</td>
<td>BYTE</td>
<td>b</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>WORD</td>
<td>w</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>DWORD</td>
<td>l</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>QWORD</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>long long</td>
<td>QWORD</td>
<td>q</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>DWORD</td>
<td>s</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>QWORD</td>
<td>l</td>
<td>8</td>
</tr>
</tbody>
</table>
<h2 id="访问信息">3.4 访问信息</h2>
<h3 id="x86-64中的整数寄存器">X86-64中的整数寄存器</h3>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 7%" />
<col style="width: 8%" />
<col style="width: 20%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr>
<th>64位</th>
<th>32位</th>
<th>16位</th>
<th>8位</th>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>%rax</td>
<td>%eax</td>
<td>%ax</td>
<td>%al</td>
<td>返回值寄存器</td>
<td>存放函数返回值</td>
</tr>
<tr>
<td>%rbx</td>
<td>%ebx</td>
<td>%bx</td>
<td>%bl</td>
<td>数据寄存器</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rcx</td>
<td>%ecx</td>
<td>%cx</td>
<td>%cl</td>
<td>第4个参数寄存器</td>
<td>用于存放第4个函数参数</td>
</tr>
<tr>
<td>%rdx</td>
<td>%edx</td>
<td>%dx</td>
<td>%dl</td>
<td>第3个参数寄存器</td>
<td>用于存放第3个函数参数</td>
</tr>
<tr>
<td>%rsi</td>
<td>%esi</td>
<td>%si</td>
<td>%sil</td>
<td>第2个参数寄存器</td>
<td>用于存放第2个函数参数</td>
</tr>
<tr>
<td>%rdi</td>
<td>%edi</td>
<td>%di</td>
<td>%dil</td>
<td>第1个参数寄存器</td>
<td>用于存放第1个函数参数</td>
</tr>
<tr>
<td>%rbp</td>
<td>%ebp</td>
<td>%bp</td>
<td>%bpl</td>
<td>基址指针寄存器</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%rsp</td>
<td>%esp</td>
<td>%sp</td>
<td>%spl</td>
<td>栈指针寄存器</td>
<td>用于指向栈顶位置</td>
</tr>
<tr>
<td>%r8</td>
<td>%r8d</td>
<td>%r8w</td>
<td>%r8b</td>
<td>第5个参数寄存器</td>
<td>用于存放第5个函数参数</td>
</tr>
<tr>
<td>%r9</td>
<td>%r9d</td>
<td>%r9w</td>
<td>%r9b</td>
<td>第6个参数寄存器</td>
<td>用于存放第6个函数参数</td>
</tr>
<tr>
<td>%r10</td>
<td>%r10d</td>
<td>%r10w</td>
<td>%r10b</td>
<td>附加寄存器</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r11</td>
<td>%r11d</td>
<td>%r11w</td>
<td>%r11b</td>
<td>附加寄存器</td>
<td>调用者保存</td>
</tr>
<tr>
<td>%r12</td>
<td>%r12d</td>
<td>%r12w</td>
<td>%r12b</td>
<td>数据寄存器</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r13</td>
<td>%r13d</td>
<td>%r13w</td>
<td>%r13b</td>
<td>数据寄存器</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r14</td>
<td>%r14d</td>
<td>%r14w</td>
<td>%r14b</td>
<td>数据寄存器</td>
<td>被调用者保存</td>
</tr>
<tr>
<td>%r15</td>
<td>%r15d</td>
<td>%r15w</td>
<td>%r15b</td>
<td>数据寄存器</td>
<td>被调用者保存</td>
</tr>
</tbody>
</table>
<h3 id="操作数指示符">操作数指示符</h3>
<p>下面是一个关于操作数格式的表格示例，使用ATT格式的汇编代码：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>格式</th>
<th>操作数值</th>
<th>名称</th>
</tr>
</thead>
<tbody>
<tr>
<td>立即数</td>
<td>立即值</td>
<td>$42</td>
<td>立即数42</td>
</tr>
<tr>
<td>寄存器</td>
<td>寄存器名</td>
<td>%eax</td>
<td>通用寄存器</td>
</tr>
<tr>
<td>寄存器</td>
<td>内存引用</td>
<td>(%ebx)</td>
<td>寄存器间接寻址</td>
</tr>
<tr>
<td>寄存器</td>
<td>寄存器+偏移</td>
<td>12(%ecx)</td>
<td>寄存器偏移寻址</td>
</tr>
<tr>
<td>寄存器</td>
<td>寄存器+立即值</td>
<td>0x1234(%edx)</td>
<td>立即值偏移寻址</td>
</tr>
<tr>
<td>存储器</td>
<td>基址(, 索引)</td>
<td>(%ebx, %esi)</td>
<td>基址索引寻址</td>
</tr>
<tr>
<td>存储器</td>
<td>基址(, , 缩放因子)</td>
<td>(%ecx,,8)</td>
<td>变址寻址</td>
</tr>
</tbody>
</table>
<h3 id="数据传输指令">数据传输指令</h3>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
<th>数据大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>movb</td>
<td>传输一个字节大小的数据</td>
<td>8位</td>
</tr>
<tr>
<td>movw</td>
<td>传输一个字（16位）大小的数据</td>
<td>16位</td>
</tr>
<tr>
<td>movl</td>
<td>传输一个双字（32位）大小的数据</td>
<td>32位</td>
</tr>
<tr>
<td>movq</td>
<td>传输一个四字（64位）大小的数据</td>
<td>64位</td>
</tr>
<tr>
<td>movzbw</td>
<td>将无符号字节数据拓展为字大小</td>
<td>8位拓展为16位</td>
</tr>
<tr>
<td>movsbw</td>
<td>将有符号字节数据拓展为字大小</td>
<td>8位拓展为16位</td>
</tr>
</tbody>
</table>
<p>在x86-64架构的汇编语言中，movl指令会将32位数据的低32位复制到目的操作数的低32位，并将目的操作数的高32位清零。</p>
<p>movz指令将无符号字节数据拓展为字大小，填充零位；movs指令将有符号字节数据拓展为字大小，保持符号位不变。</p>
<h3 id="压入和弹出栈数据">压入和弹出栈数据</h3>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 23%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>pushq</td>
<td>将值压入栈顶</td>
<td>该指令将给定的源操作数的值压入栈顶，并将栈指针减小8个字节（根据操作数的大小）</td>
</tr>
<tr>
<td>popq</td>
<td>将值从栈顶弹出</td>
<td>该指令将栈顶的值弹出，并将栈指针增加8个字节（根据操作数的大小），并将值存储到目的操作数中</td>
</tr>
</tbody>
</table>
<p>这些指令用于栈的操作，栈是一个后进先出（LIFO）的数据结构。在x86-64汇编语言中，栈被广泛用于函数调用、局部变量存储和寄存器保存等任务。</p>
<p>使用pushq指令时，要指定要推入栈顶的操作数，可以是寄存器、内存位置或立即数。例如，<code>pushq %rax</code>
将将寄存器 %rax 的值压入栈顶。</p>
<p>使用popq指令时，要指定从栈顶弹出的目的操作数，可以是寄存器或内存位置。例如，<code>popq %rbx</code>
将从栈顶弹出一个值，并将其存储到寄存器 %rbx。</p>
<p>这些指令对栈指针进行相应的调整，以确保栈的正确管理（可以发现，栈是倒过来的）。在使用这些指令时，需要注意栈的正确使用，以避免栈溢出或栈指针错误的情况。</p>
<h2 id="算术逻辑操作">3.5 算术逻辑操作</h2>
<table>
<colgroup>
<col style="width: 5%" />
<col style="width: 18%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>leaq</td>
<td>计算有效地址</td>
<td>将源操作数的内存地址计算并存储到目的操作数中</td>
</tr>
<tr>
<td>inc</td>
<td>增加操作数的值</td>
<td>将源操作数的值增加1，结果存储到目的操作数中</td>
</tr>
<tr>
<td>dec</td>
<td>减少操作数的值</td>
<td>将源操作数的值减少1，结果存储到目的操作数中</td>
</tr>
<tr>
<td>neg</td>
<td>取反操作数的值</td>
<td>将源操作数的值取反（取负），结果存储到目的操作数中</td>
</tr>
<tr>
<td>not</td>
<td>取反操作数的位</td>
<td>将源操作数的位取反，结果存储到目的操作数中</td>
</tr>
<tr>
<td>add</td>
<td>加法操作</td>
<td>将源操作数的值与目的操作数相加，结果存储到目的操作数中</td>
</tr>
<tr>
<td>sub</td>
<td>减法操作</td>
<td>将源操作数的值与目的操作数相减，结果存储到目的操作数中</td>
</tr>
<tr>
<td>imul</td>
<td>有符号乘法操作</td>
<td>将源操作数与目的操作数进行有符号乘法运算，结果存储到目的操作数中</td>
</tr>
<tr>
<td>xor</td>
<td>异或操作</td>
<td>将源操作数与目的操作数进行按位异或运算，结果存储到目的操作数中</td>
</tr>
<tr>
<td>or</td>
<td>或操作</td>
<td>将源操作数与目的操作数进行按位或运算，结果存储到目的操作数中</td>
</tr>
<tr>
<td>and</td>
<td>与操作</td>
<td>将源操作数与目的操作数进行按位与运算，结果存储到目的操作数中</td>
</tr>
<tr>
<td>sal</td>
<td>左移算术（带符号）</td>
<td>将源操作数的位向左移动指定的位数，空位用0填充，结果存储到目的操作数中（带符号左移）</td>
</tr>
<tr>
<td>shl</td>
<td>左移逻辑（无符号）</td>
<td>将源操作数的位向左移动指定的位数，空位用0填充，结果存储到目的操作数中（无符号左移）</td>
</tr>
<tr>
<td>sar</td>
<td>右移算术（带符号）</td>
<td>将源操作数的位向右移动指定的位数，空位用符号位填充，结果存储到目的操作数中（带符号右移）</td>
</tr>
<tr>
<td>shr</td>
<td>右移逻辑（无符号）</td>
<td>将源操作数的位向右移动指定的位数，空位用0填充，结果存储到目的操作数中（无符号右移）</td>
</tr>
</tbody>
</table>
<h3 id="加载有效地址">加载有效地址</h3>
<p>leaq和movq基本等同，但是目的数必须是寄存器。</p>
<p>leaq可以用来做一些巧妙的操作，但是往往这和设计用途无关。</p>
<h3 id="一元和二元操作">一元和二元操作</h3>
<p>一元操作的源和目的是同一个数。</p>
<p>二元操作的源操作数是第一个，目的操作数是第二个。</p>
<p>例如 subq %rax,%rdx是使%rdx的值变为%rdx减去%rax的值。</p>
<h3 id="移位操作">移位操作</h3>
<p>左移指令有两个名字：SAl和SHL。两者的效果是一样的。，都是在右面填上0。</p>
<p>右移指令在x86汇编语言中，SAR和SHR指令的不同字母来自以下单词：</p>
<p>SAR：Shift Arithmetic Right（算术右移） SHR：Shift Logical
Right（逻辑右移）</p>
<p>移位量可以是一个立即数，也可以放在单字节寄存器%cl中。</p>
<h3 id="特殊的算术操作">特殊的算术操作</h3>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 25%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>imulq</td>
<td>有符号乘法操作（四字节）</td>
<td>将源操作数与目的操作数进行有符号乘法运算，结果存储到目的操作数中</td>
</tr>
<tr>
<td>mulq</td>
<td>无符号乘法操作（四字节）</td>
<td>将源操作数与目的操作数进行无符号乘法运算，结果存储到目的操作数中</td>
</tr>
<tr>
<td>cqto</td>
<td>扩展符号位（四字节到八字节）</td>
<td>将四字节的有符号值扩展到八字节，并存储到目的操作数中（对于imulq和divq指令的操作准备）</td>
</tr>
<tr>
<td>idivq</td>
<td>有符号除法操作（四字节）</td>
<td>将目的操作数除以源操作数，商存储到目的操作数中，余数存储到%rdx寄存器中</td>
</tr>
<tr>
<td>divq</td>
<td>无符号除法操作（四字节）</td>
<td>将目的操作数除以源操作数，商存储到目的操作数中，余数存储到%rdx寄存器中</td>
</tr>
</tbody>
</table>
<p>对于imulq指令，当只使用一个操作数时，它会将源操作数与目的操作数（即%rax寄存器）进行有符号乘法运算，并将结果存储在%rdx:%rax寄存器对中。这个寄存器对存储了64位结果，其中高32位存储在%rdx寄存器中，低32位存储在%rax寄存器中。</p>
<h2 id="控制">3.6 控制</h2>
<p>有时需要有条件的执行，数据决定指令执行的顺序，这时就要使用jump指令改变执行顺序。</p>
<h3 id="条件码">条件码</h3>
<p>条件码是指在计算机体系结构中用于记录运算结果状态的一组标志位。常见的条件码包括进位标志（Carry
Flag，CF）、零标志（Zero Flag，ZF）、符号标志（Sign
Flag，SF）和溢出标志（Overflow Flag，OF）。</p>
<ol type="1">
<li>进位标志（CF）：
<ul>
<li>用途：记录算术和逻辑运算中的进位或借位情况。</li>
<li>设置条件：当无符号数相加产生进位，或者无符号数相减产生借位时，CF被设置为1；否则，CF被设置为0。</li>
</ul></li>
<li>零标志（ZF）：
<ul>
<li>用途：记录运算结果是否为零。</li>
<li>设置条件：当运算结果为零时，ZF被设置为1；否则，ZF被设置为0。</li>
</ul></li>
<li>符号标志（SF）：
<ul>
<li>用途：记录运算结果的符号。</li>
<li>设置条件：当运算结果为负数时，SF被设置为1；当运算结果为非负数时，SF被设置为0。</li>
</ul></li>
<li>溢出标志（OF）：
<ul>
<li>用途：记录有符号数运算中是否发生溢出。</li>
<li>设置条件：当有符号数相加或相减产生溢出时，OF被设置为1；否则，OF被设置为0。</li>
</ul></li>
</ol>
<p>这些条件码在程序执行过程中，可以被用于控制程序的流程，比如进行条件判断、循环等。根据条件码的状态，程序可以根据不同的条件选择不同的执行路径。例如，使用条件跳转指令根据CF、ZF、SF和OF的状态进行分支判断，从而实现程序的控制流程。</p>
<p>好的，下面是对x86-64架构下的<code>cmp</code>和<code>test</code>指令进行说明的表格：</p>
<table>
<colgroup>
<col style="width: 6%" />
<col style="width: 22%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr>
<th>指令</th>
<th>效果</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>cmp</td>
<td>比较操作数</td>
<td>比较源操作数和目的操作数的值，根据比较结果设置标志位</td>
</tr>
<tr>
<td>test</td>
<td>位测试操作</td>
<td>对源操作数和目的操作数进行按位与运算，并根据结果设置标志位</td>
</tr>
</tbody>
</table>
<p>这两个指令，cmp等价于sub，test等价于and，唯一的区别在于，这个操作只改变条件码而不改变操作数。</p>
<h3 id="访问条件码">访问条件码</h3>
<p>在x86-64架构下，<code>set</code>指令是一个条件设置指令，用于根据某个条件的结果设置一个目标操作数的值。它根据条件的真假结果设置目标操作数的值为1或0。<code>set</code>指令通常与条件跳转指令（如<code>jmp</code>、<code>jz</code>等）一起使用，用于在条件满足时设置一个寄存器或内存位置的值。</p>
<p><code>set</code>指令有多个变种，每个变种都对应不同的条件码（flags）和条件判断。这些变种包括：</p>
<ul>
<li><code>seta</code> /
<code>setnbe</code>：如果无符号数大于（Above）指定条件，则将目标操作数设置为1，否则设置为0。</li>
<li><code>setae</code> / <code>setnb</code> /
<code>setnc</code>：如果无符号数大于等于（Above or
Equal）指定条件，则将目标操作数设置为1，否则设置为0。</li>
<li><code>setb</code> / <code>setnae</code> /
<code>setc</code>：如果无符号数小于（Below）指定条件，则将目标操作数设置为1，否则设置为0。</li>
<li><code>setbe</code> / <code>setna</code>：如果无符号数小于等于（Below
or Equal）指定条件，则将目标操作数设置为1，否则设置为0。</li>
<li><code>sete</code> /
<code>setz</code>：如果等于（Equal）指定条件，则将目标操作数设置为1，否则设置为0。</li>
<li><code>setg</code> /
<code>setnle</code>：如果有符号数大于（Greater）指定条件，则将目标操作数设置为1，否则设置为0。</li>
<li><code>setge</code> /
<code>setnl</code>：如果有符号数大于等于（Greater or
Equal）指定条件，则将目标操作数设置为1，否则设置为0。</li>
<li><code>setl</code> /
<code>setnge</code>：如果有符号数小于（Less）指定条件，则将目标操作数设置为1，否则设置为0。</li>
<li><code>setle</code> / <code>setng</code>：如果有符号数小于等于（Less
or Equal）指定条件，则将目标操作数设置为1，否则设置为0。</li>
<li><code>setne</code> / <code>setnz</code>：如果不等于（Not
Equal）指定条件，则将目标操作数设置为1，否则设置为0。</li>
</ul>
<p>这些变种可以根据特定的条件码和条件判断来设置目标操作数的值，目标操作数可以是一个寄存器或内存位置。例如，如果指令的结果满足"等于"条件，<code>sete %al</code>会将AL寄存器的值设置为1；否则，它将设置AL寄存器的值为0。</p>
<h3 id="跳转">跳转</h3>
<ol type="1">
<li>无条件跳转：
无条件跳转指令用于无条件地改变程序的执行流程，跳转到指定的代码位置。其中，常见的无条件跳转指令有：</li>
</ol>
<ul>
<li><code>jmp</code>：无条件跳转到目标地址，目标地址可以是一个绝对地址或相对地址。
例如：<code>jmp label</code> 将会无条件跳转到标签为 <code>label</code>
的位置。</li>
</ul>
<ol start="2" type="1">
<li>直接/间接跳转：
直接跳转指令通过指定目标地址来改变程序的执行流程。目标地址可以通过直接给出或者存储在寄存器或内存中。常见的直接跳转指令有：</li>
</ol>
<ul>
<li><code>jmp reg</code>：跳转到寄存器中存储的目标地址。
例如：<code>jmp eax</code>
将会跳转到<code>eax</code>寄存器中存储的地址。</li>
<li><code>jmp [mem]</code>：跳转到内存中存储的目标地址。
例如：<code>jmp [0x1000]</code>
将会跳转到地址为<code>0x1000</code>处存储的目标地址。</li>
<li>跳转目标是从寄存器或者内存位置读出的，成为间接跳转，写法是加一个操作符<code>*</code>，例如<code>jmp *%rax</code>。</li>
</ul>
<ol type="1">
<li>有条件跳转：
有条件跳转指令根据特定的条件码（flags）和条件判断来确定是否进行跳转。根据条件的真假结果，可以有符号数和无符号数的情况。常见的有条件跳转指令有：</li>
</ol>
<ul>
<li>有符号数条件跳转：
<ul>
<li><code>jg</code> /
<code>jnle</code>：如果有符号数大于（Greater）指定条件，则跳转。</li>
<li><code>jge</code> / <code>jnl</code>：如果有符号数大于等于（Greater
or Equal）指定条件，则跳转。</li>
<li><code>jl</code> /
<code>jnge</code>：如果有符号数小于（Less）指定条件，则跳转。</li>
<li><code>jle</code> / <code>jng</code>：如果有符号数小于等于（Less or
Equal）指定条件，则跳转。</li>
<li><code>je</code> /
<code>jz</code>：如果等于（Equal）指定条件，则跳转。</li>
<li><code>jne</code> / <code>jnz</code>：如果不等于（Not
Equal）指定条件，则跳转。
例如：<code>jg label</code>将会在有符号数大于指定条件时跳转到标签为<code>label</code>的位置。</li>
</ul></li>
<li>无符号数条件跳转：
<ul>
<li><code>ja</code> /
<code>jnbe</code>：如果无符号数大于（Above）指定条件，则跳转。</li>
<li><code>jae</code> / <code>jnb</code> /
<code>jnc</code>：如果无符号数大于等于（Above or
Equal）指定条件，则跳转。</li>
</ul></li>
<li><code>jb</code> / <code>jnae</code> /
<code>jc</code>：如果无符号数小于（Below）指定条件，则跳转。</li>
<li><code>jbe</code> / <code>jna</code>：如果无符号数小于等于（Below or
Equal）指定条件，则跳转。</li>
<li><code>je</code> /
<code>jz</code>：如果等于（Equal）指定条件，则跳转。</li>
<li><code>jne</code> / <code>jnz</code>：如果不等于（Not
Equal）指定条件，则跳转。
例如：<code>ja label</code>将会在无符号数大于指定条件时跳转到标签为<code>label</code>的位置。</li>
</ul>
<p>这些跳转指令可以根据特定条件的结果来决定是否跳转到目标位置，从而实现程序执行流程的控制。</p>
<p>在计算机中，PC（程序计数器）用于存储下一条要执行的指令的地址。在跳转指令的执行过程中，PC会被修改为跳转目标的地址，以实现代码的跳转和程序流程的改变。</p>
<p>相对跳转（PC相对寻址）是一种常见的跳转方式，其中跳转目标相对于当前指令的地址进行偏移。PC相对寻址使用一个相对于当前指令的偏移量，该偏移量可以是正数或负数，用于计算跳转目标的地址。</p>
<p>在x86-64架构中，相对跳转通常使用有符号的偏移量。例如，<code>jmp rel32</code>
指令使用一个32位的有符号相对偏移量，该偏移量会与当前指令的地址相加，从而计算出跳转目标的地址。相对跳转指令会将这个计算出的跳转目标地址加载到PC中，使得程序执行流程转移到该地址处。</p>
<p>例如，假设当前指令的地址为0x1000（jmp的下一条指令），执行了一条相对跳转指令
<code>jmp rel32</code>，偏移量为-10。那么，PC会被修改为 0x1000 + (-10) =
0xFF6 的值，即跳转到地址 0xFF6 执行下一条指令。</p>
<p>PC相对寻址允许程序在不同的代码位置之间进行跳转，提供了灵活性和动态性，可以根据程序的需求在不同的条件下选择不同的执行路径。</p>
<h3 id="用条件控制">用条件控制</h3>
<p>在x86-64架构下，条件控制和条件传送是两种不同的方式来实现条件分支：</p>
<ul>
<li><p>条件控制是通过条件跳转指令（如<code>jmp</code>、<code>jz</code>、<code>jnz</code>等）来实现条件分支。程序在执行到条件跳转指令时，会根据指定的条件判断是否满足跳转条件，如果满足，则会跳转到指定的目标位置执行相应的代码；如果不满足，则会继续顺序执行下一条指令。这种方式需要进行跳转操作，可能会导致指令预测失败，从而降低性能。</p></li>
<li><p>条件传送是通过条件传送指令（如<code>cmov</code>系列指令）来实现条件分支。这些指令会根据条件判断来选择是否将数据从源操作数传送到目标操作数。如果条件满足，则将源操作数的值传送到目标操作数；如果条件不满足，则不进行传送操作。这种方式不需要跳转操作，因此可以避免指令预测失败的开销，提高性能。</p></li>
</ul>
<p>条件传送方式在指令流水线中更高效，主要是因为它避免了分支预测失败的开销，减少了流水线的清空操作，并且提高了指令级并行性，允许更多的指令同时执行。这使得条件传送在一些需要频繁进行条件分支的代码段中能够更好地发挥性能优势。然而，需要根据具体的代码特点和性能需求进行权衡选择，有时条件控制方式可能更适合。</p>
<p><code>cmov</code>指令在条件传送中起到了关键的作用。它是条件传送指令中的一种，用于执行条件传送操作。<code>cmov</code>指令的基本语法如下：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmovXX dest, <span class="attribute">src</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>XX</code>是条件码（如<code>e</code>、<code>ne</code>、<code>g</code>、<code>ge</code>、<code>l</code>、<code>le</code>等），根据不同的条件码可以执行不同的条件判断。<code>dest</code>表示目标操作数，<code>src</code>表示源操作数。</p>
<p><code>cmov</code>指令的工作原理是先进行条件判断，如果条件满足，则将源操作数的值传送到目标操作数；如果条件不满足，则不进行传送操作。这样可以根据条件的真假来灵活选择数据传送的方式，而不需要进行跳转操作。</p>
<p>通过使用<code>cmov</code>指令进行条件传送，可以提高程序的执行效率，尤其在一些需要频繁进行条件分支的代码段中。然而，需要注意的是，<code>cmov</code>指令的执行时间可能会比条件跳转指令长，因此在一些执行时间敏感的代码段中，需要权衡选择合适的方式来实现条件分支。</p>
<p>只有在每个分支都容易计算的时候，才会使用条件传送，这样能避免条件控制带来的预测错误的开销。当然也会有一些特殊的情况，比如条件不成立，则分支中有空指针，显然不能进行条件传送。所以尽管条件传送效率更高，但是大部分情况下仍然选择条件控制。</p>
<h2 id="过程">3.7 过程</h2>
<h3 id="运行时栈">运行时栈</h3>
<p>x86-64架构中的运行时栈（Runtime
Stack）是一种用于支持函数调用和局部变量存储的数据结构。它是计算机内存中的一块特殊区域，由处理器和操作系统共同管理。</p>
<p>运行时栈通常以“栈”的形式组织数据，采用后进先出（LIFO）的方式进行操作。它在函数调用和返回过程中提供了一种有效的方式来保存和恢复现场，包括函数参数、返回地址和局部变量等。</p>
<p>以下是一些关于x86-64运行时栈的重要概念和特点：</p>
<ol type="1">
<li><p>栈指针（Stack
Pointer）：在x86-64中，栈指针是一个特殊的寄存器，通常称为<code>RSP</code>（64位模式下）或者<code>ESP</code>（32位模式下）。栈指针指向栈顶的位置，即最后一个入栈的元素。</p></li>
<li><p>栈帧（Stack
Frame）：栈帧是函数在运行时栈中的一块区域，用于存储函数的局部变量、函数参数和其他与函数执行相关的数据。每次函数调用时，都会创建一个新的栈帧，用于保存当前函数的上下文信息。</p></li>
<li><p>函数调用过程：当一个函数被调用时，以下步骤通常发生在运行时栈中：</p>
<ul>
<li>将函数参数压入栈中。</li>
<li>保存当前函数的返回地址。</li>
<li>分配栈空间用于存储局部变量。</li>
<li>将控制转移到被调用函数的入口点。</li>
<li>在被调用函数中，可以访问参数和局部变量。</li>
<li>当函数执行完毕时，恢复返回地址，并释放栈空间。</li>
<li>将控制返回给调用函数。</li>
</ul></li>
<li><p>栈溢出（Stack
Overflow）：由于运行时栈的大小是有限的，当递归调用层级过深或者在函数中分配过多的局部变量时，可能会导致栈空间不足，从而发生栈溢出错误。</p></li>
</ol>
<p>运行时栈在x86-64架构中是一个重要的组成部分，它提供了函数调用和局部变量存储的机制。了解运行时栈的工作原理和特点有助于理解函数调用、栈帧布局和内存管理等底层的运行时机制。</p>
<h3 id="转移控制">转移控制</h3>
<p>在x86-64架构中，<code>call</code>（调用）和<code>ret</code>（返回）是用于函数调用和返回的指令。</p>
<ol type="1">
<li><code>call</code> 指令：
<ul>
<li><code>call</code> 指令用于调用一个函数或跳转到指定的代码段。</li>
<li>在执行 <code>call</code>
指令时，会将当前指令的下一条指令的地址（即返回地址）压入栈中，保存现场。</li>
<li>然后，<code>call</code>
指令会将控制转移到目标函数或代码段的入口点，开始执行目标代码。</li>
<li>当目标函数或代码段执行完毕后，通过 <code>ret</code>
指令返回调用者。</li>
</ul></li>
<li><code>ret</code> 指令：
<ul>
<li><code>ret</code>
指令用于函数返回，将控制权从被调用函数返回到调用者。</li>
<li>在执行 <code>ret</code>
指令时，它会从栈中弹出保存的返回地址，并将控制转移到该地址所指向的指令。</li>
<li>这样，程序的执行流程回到了调用者处，继续执行后续的代码。</li>
</ul></li>
</ol>
<p>在函数调用过程中，<code>call</code> 和 <code>ret</code>
指令的配对使用，确保了函数的正确调用和返回：</p>
<ol type="1">
<li>调用者：
<ul>
<li>调用者在准备调用函数之前，将函数参数压入栈中，按照函数调用约定传递参数。</li>
<li>调用者使用 <code>call</code>
指令将控制转移给被调用函数，并将返回地址压入栈中。</li>
</ul></li>
<li>被调用函数：
<ul>
<li>被调用函数接收参数，并在栈上分配空间用于保存局部变量。</li>
<li>被调用函数执行完毕后，使用 <code>ret</code>
指令将控制权返回给调用者。</li>
</ul></li>
<li>调用者继续执行：
<ul>
<li>当被调用函数执行完毕，控制权返回到调用者处。</li>
<li>调用者从栈中弹出返回地址，并继续执行后续的代码。</li>
</ul></li>
</ol>
<p>这样，通过 <code>call</code> 和 <code>ret</code>
指令的组合，实现了函数之间的调用和返回，确保了程序的正确执行流程和返回路径。</p>
<h3 id="数据传送">数据传送</h3>
<p>x86-64中，通过寄存器传递参数，但是有上限（详情见<strong>86-64中的整数寄存器</strong>），多于的参数只能通过栈传递。</p>
<h3 id="栈上的局部储存">栈上的局部储存</h3>
<p>大部分情况下，不需要超出寄存器大小的本地存储趋于，但是有时候局部数据必须存放在内存中：</p>
<ul>
<li>寄存器不足够存放所有的本地数据</li>
<li>对一个局部变量使用地址运算符'&amp;',因此必须产生一个地址</li>
<li>局部变量是数组或者结构。</li>
</ul>
<h3 id="寄存器中的局部储存空间">寄存器中的局部储存空间</h3>
<p>寄存器组是唯一被所有过程共享的资源，虽然给定时刻只有一个过程是活动的，但是我们仍然必须确保，被调用者不会覆盖调用者稍后会使用的寄存器。</p>
<p>因此，x86-64采用了统一的寄存器使用管理，所有的过程都必须遵循。</p>
<p>按照惯例，寄存器%rbx、%rbp和%r12-%r15被划分为被调用者保存寄存器。被调用的过程要么保证这个值不变，要么压入栈中，在返回时复原这个值。</p>
<p>其它寄存器，除了栈指针%rsp，所有函数都可以任意修改这个寄存器。</p>
<h2 id="数组的分配和访问">3.8 数组的分配和访问</h2>
<h3 id="基本原则">基本原则</h3>
<p>在计算数组元素的地址时，可以使用以下公式：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">address</span> = base_address + element_size * <span class="built_in">index</span></span><br></pre></td></tr></table></figure>
<p>其中： - <code>address</code> 是数组元素的地址。 -
<code>base_address</code> 是数组的起始地址或首元素的地址。 -
<code>element_size</code> 是每个数组元素的大小（以字节为单位）。 -
<code>index</code> 是要访问的元素的索引（从0开始）。</p>
<p>通过将索引乘以每个元素的大小，然后加上起始地址，可以计算出特定元素的地址。</p>
<p>例如，假设有一个数组 <code>arr</code>，起始地址为
<code>0x1000</code>，每个元素的大小为 4
字节（32位整数），要计算第三个元素（索引为
2）的地址，可以使用以下公式：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">address</span> = <span class="number">0</span>x1000 + <span class="number">4</span> * <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>计算结果为 <code>0x1008</code>，即第三个元素的地址为
<code>0x1008</code>。</p>
<h3 id="嵌套的数组">嵌套的数组</h3>
<p>如果数组是嵌套的，也就是多维数组，计算数组元素的地址就会稍微复杂一些。在多维数组中，每个维度都有一个对应的索引，因此需要使用多个索引来定位数组中的元素。</p>
<p>对于一个二维数组，可以使用以下公式来计算元素的地址：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">address</span> = base_address + (element_size * (row_index * <span class="built_in">columns</span> + column_index))</span><br></pre></td></tr></table></figure>
<p>其中： - <code>address</code> 是数组元素的地址。 -
<code>base_address</code> 是数组的起始地址或首元素的地址。 -
<code>element_size</code> 是每个数组元素的大小（以字节为单位）。 -
<code>row_index</code> 是行索引，指定要访问的行。 -
<code>column_index</code> 是列索引，指定要访问的列。 -
<code>columns</code> 是数组的列数，表示每行有多少个元素。</p>
<p>在一个三维数组中，需要使用类似的公式，但是会涉及更多的索引和维度。</p>
<p>需要注意的是，对于多维数组，计算地址的公式可能会因不同的数组排列方式（行主序、列主序等）而有所不同。在一些情况下，还可能需要进行乘法优化或使用偏移量来处理特殊的嵌套数组布局。</p>
<h3 id="定长数组和变长数组">定长数组和变长数组</h3>
<p>对于定长数组，每个元素的大小已知且相同，可以使用之前提到的公式来计算元素的地址。</p>
<p>例如，对于一个定长数组 <code>arr</code>，起始地址为
<code>base_address</code>，每个元素的大小为
<code>element_size</code>，要计算第 <code>index</code>
个元素的地址，可以使用以下公式：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">address</span> = base_address + (element_size * <span class="built_in">index</span>)</span><br></pre></td></tr></table></figure>
<p>其中 <code>address</code> 是数组元素的地址。</p>
<p>对于变长数组（例如动态分配的数组），情况略有不同。由于数组的大小是在运行时确定的，每个元素的地址无法使用简单的公式进行计算。通常，变长数组的元素是通过指针或引用进行访问，而不是直接计算地址。</p>
<p>在使用变长数组时，通常需要使用动态内存分配函数（例如
<code>malloc()</code>）在堆上分配内存，并使用指针来访问数组元素。此时，可以使用指针运算来访问数组元素，而不需要直接计算地址。</p>
<p>例如，假设有一个变长数组 <code>arr</code>，通过动态内存分配函数
<code>malloc()</code> 在堆上分配了一块内存，并返回了指向数组首元素的指针
<code>arr_ptr</code>。要访问第 <code>index</code>
个元素，可以使用以下指针运算：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element_ptr = arr_ptr + index</span><br></pre></td></tr></table></figure>
<p>其中 <code>element_ptr</code> 是指向第 <code>index</code>
个元素的指针。</p>
<p>需要注意的是，对于变长数组，必须在分配内存后才能进行访问，而且还需要确保在不再使用数组时释放相关的内存，以避免内存泄漏。</p>
<p>总结起来，对于定长数组，可以使用公式计算元素的地址。对于变长数组，通常需要使用指针来访问数组元素。</p>
<h2 id="异质的数据结构">3.9 异质的数据结构</h2>
<h3 id="结构体">结构体</h3>
<p>在x86-64架构中，结构体的实现与其他架构类似，使用一系列的字节来存储结构体的成员。下面是一种常见的实现方式：</p>
<ol type="1">
<li><p>内存对齐：结构体在内存中存储时，通常要进行内存对齐，以保证结构体成员在内存中的地址是对齐的。这有助于提高内存访问的效率。可以使用编译器提供的特定指令或指令集来实现内存对齐。</p></li>
<li><p>成员偏移：每个结构体成员在结构体中的偏移量决定了其在内存中的位置。编译器会根据结构体成员的类型和对齐要求计算出偏移量，并将成员放置在适当的位置。</p></li>
<li><p>结构体大小：结构体的大小取决于其成员的类型和排列方式。成员之间可能存在填充字节，以确保内存对齐。</p></li>
</ol>
<p>以下是一个示例结构体的定义和实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建结构体变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问结构体成员并赋值</span></span><br><span class="line">    <span class="built_in">sprintf</span>(person.name, <span class="string">&quot;John&quot;</span>);</span><br><span class="line">    person.age = <span class="number">25</span>;</span><br><span class="line">    person.height = <span class="number">1.75</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结构体成员的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s\n&quot;</span>, person.name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Age: %d\n&quot;</span>, person.age);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Height: %.2f\n&quot;</span>, person.height);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们定义了一个名为<code>Person</code>的结构体，它包含了一个字符数组<code>name</code>、一个整数<code>age</code>和一个浮点数<code>height</code>作为成员。在<code>main()</code>函数中，我们创建了一个<code>person</code>结构体变量，并通过点运算符<code>.</code>来访问和赋值结构体的成员。最后，我们使用<code>printf()</code>函数输出结构体成员的值。</p>
<p>需要注意的是，结构体的具体实现可能因编译器、编译选项和对齐要求等因素而有所差异。因此，在实际编程中，最好遵循编译器的规范，并确保对结构体的访问和操作是正确和可移植的。</p>
<h3 id="联合">联合</h3>
<p>联合（Union）是一种特殊的数据类型，允许在相同的内存位置存储不同类型的数据。与结构体不同，联合只能同时存储其中一个成员的值。以下是联合的实现方式：</p>
<ol type="1">
<li><p>内存共享：联合的所有成员共享相同的内存空间，其大小取决于最大成员的大小。这意味着联合的不同成员会占用相同的内存位置。</p></li>
<li><p>成员访问：通过使用联合变量的名称和成员名称，可以访问和操作联合的成员。</p></li>
</ol>
<p>下面是一个简单的联合示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> intValue;</span><br><span class="line">    <span class="type">float</span> floatValue;</span><br><span class="line">    <span class="type">char</span> stringValue[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">    data.intValue = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Integer value: %d\n&quot;</span>, data.intValue);</span><br><span class="line"></span><br><span class="line">    data.floatValue = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Float value: %.2f\n&quot;</span>, data.floatValue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(data.stringValue, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;String value: %s\n&quot;</span>, data.stringValue);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，我们定义了一个名为<code>Data</code>的联合，它包含了一个整数<code>intValue</code>、一个浮点数<code>floatValue</code>和一个字符数组<code>stringValue</code>作为成员。在<code>main()</code>函数中，我们创建了一个<code>data</code>联合变量，并通过点运算符<code>.</code>来访问和赋值联合的成员。需要注意的是，对于联合来说，我们只能同时访问其中一个成员，对一个成员的赋值会影响其他成员。</p>
<p>请注意，联合的使用需要谨慎，特别是在涉及类型转换和内存访问方面。由于联合的成员共享相同的内存空间，对一个成员的修改可能会影响其他成员的值。因此，在使用联合时，请确保正确地访问和操作联合的成员，以避免潜在的错误和问题。</p>
<h3 id="数据对齐">数据对齐</h3>
<p>数据对齐是为了提高内存访问效率和处理器的性能而进行的一种优化技术。数据对齐确保数据在内存中按照特定的规则进行存储，使得访问对齐的数据可以更快速地进行，减少内存访问的开销。</p>
<p>以下是一些原因说明为什么要进行数据对齐：</p>
<ol type="1">
<li><p>提高内存访问效率：处理器通常以特定的块大小（例如字节、字、双字等）从内存中读取数据。如果数据按照处理器的访问要求进行对齐，处理器可以直接从内存中读取整块数据，而不需要进行额外的操作。这样可以提高内存读取的效率。</p></li>
<li><p>减少内存访问次数：当结构体或对象中的成员按照对齐要求进行排列时，可以避免在访问不对齐的数据时进行多次内存读取。相反，可以通过一次对齐的读取来获取多个成员的值，从而减少内存访问的次数，提高效率。</p></li>
</ol>
<p>需要注意的是，数据对齐可能会导致一些额外的内存空间被填充，以确保成员之间的对齐。这些额外的填充字节可能会增加结构体或对象的大小。因此，在设计数据结构时，需要权衡内存使用和访问效率之间的平衡。</p>
<p>数据对齐是由编译器根据平台的要求自动完成的。大多数编程语言和编译器提供了一些机制，如编译器指令、编译选项或属性，以控制数据对齐的方式和行为。</p>
<h2 id="在机器级程序中将控制欲数据结合起来">3.10
在机器级程序中将控制欲数据结合起来</h2>
<h3 id="指针">指针</h3>
<p>C语言的指针是其核心特性之一，它允许直接访问内存地址，进而实现高效的内存操作和数据结构表示。指针在C语言中扮演着重要的角色，并且对于理解机器代码和底层内存操作至关重要。</p>
<p>首先，让我们讨论指针的概念。指针是一个变量，它存储了内存地址的值。可以通过使用取地址运算符<code>&amp;</code>将变量的地址赋给指针变量。例如，<code>int *ptr;</code>声明了一个指向整数的指针。然后，通过将某个整数变量的地址赋给<code>ptr</code>，可以使<code>ptr</code>指向该变量。</p>
<p>指针的重要性在于它提供了直接访问内存的能力。通过解引用操作符<code>*</code>，可以访问指针指向的内存位置上存储的值。例如，<code>*ptr</code>将返回指针<code>ptr</code>指向的整数值。</p>
<p>指针的使用要正确且谨慎。以下是一些指针相关的关键原则：</p>
<ul>
<li>每个指针都有值</li>
<li>指针用'&amp;'运算符创建</li>
<li>数组与指针紧密联系</li>
<li>*操作符用来间接引用指针</li>
<li>将指针强制转化类型，只改变类型不改变值</li>
<li>指针也可以指向函数，指向的是第一条指令的地址</li>
</ul>
<h3 id="内存越界引用和缓存区溢出">内存越界引用和缓存区溢出</h3>
<ul>
<li><p>内存越界引用（Memory Out-of-Bounds Reference）：
内存越界引用指的是程序试图访问超出其分配内存范围的位置的行为。当程序访问超过其分配内存边界的位置时，可能会导致未定义的行为和安全漏洞。</p>
<p>例如，在C语言中，如果你声明了一个数组 <code>int arr[5];</code>
，它有五个元素，索引从0到4。如果你试图访问 <code>arr[5]</code> 或者
<code>arr[100]</code>，这就是内存越界引用，因为你超出了数组的有效索引范围。这样的行为可能会导致程序崩溃、数据损坏或者安全漏洞，因为你可能会误用或覆盖其他内存区域的数据。</p>
<p>内存越界引用可能导致的问题包括程序崩溃、内存泄漏、数据损坏、安全漏洞（如利用越界引用进行代码执行）等。因此，在编写程序时，务必要注意数组和指针的边界，并确保不发生内存越界引用。</p></li>
<li><p>缓冲区溢出（Buffer Overflow）：
缓冲区溢出是指向一个缓冲区写入超过其容量的数据量的行为。当程序向一个固定大小的缓冲区写入超过其可容纳的数据时，多余的数据会覆盖到相邻的内存区域，可能导致程序崩溃或者被攻击者利用。</p>
<p>缓冲区溢出通常发生在使用不安全的字符串处理函数（如C语言中的
<code>strcpy</code>、<code>sprintf</code>
等）时，因为这些函数不会检查目标缓冲区的容量。攻击者可以利用缓冲区溢出漏洞，覆盖关键数据、修改程序行为、执行恶意代码等。</p>
<p>为了避免缓冲区溢出漏洞，可以使用安全的字符串处理函数（如C语言中的
<code>strncpy</code>、<code>snprintf</code>
等），并且要仔细检查输入数据的大小，确保不会写入超过缓冲区容量的数据。</p></li>
</ul>
<h3 id="对抗缓存区溢出攻击">对抗缓存区溢出攻击</h3>
<ol type="1">
<li><p>栈随机化（Stack Randomization）：
栈随机化是一种安全增强技术，它通过在每次程序运行时随机选择栈的起始地址来改变栈的内存布局。在
Linux 系统中，栈随机化是 ASLR（Address Space Layout
Randomization）的一部分。</p>
<p>ASLR
通过随机化程序的内存布局，包括栈、堆、共享库、代码段等，来增加攻击者对系统的预测难度。栈随机化是
ASLR
的一项措施，它使得栈的位置在每次程序运行时都会发生随机变化，从而减少了栈溢出攻击的成功概率。</p>
<p>栈随机化通过使攻击者无法准确预测栈的位置来防止栈溢出攻击。即使攻击者成功地溢出了栈缓冲区，他们也无法确定准确的返回地址或其他敏感数据的位置，从而阻止了攻击的成功执行。</p></li>
<li><p>栈破坏检测（Stack Protection）：
栈破坏检测是一种用于检测栈溢出攻击的技术。其中一种常见的栈破坏检测技术是使用金丝雀值（Canary
Value），它也是 ASLR 的一部分。</p>
<p>在 Linux
系统中，当启用栈保护机制时，编译器会自动将一个特殊的随机值（金丝雀值）插入到栈帧中函数返回地址之前。在函数返回时，系统会检查金丝雀值是否保持不变。如果金丝雀值被篡改，系统会判定栈溢出攻击已发生，并采取相应的安全措施，如终止程序运行或触发警报。</p>
<p>栈破坏检测技术通过使用金丝雀值可以检测栈溢出攻击。攻击者在进行溢出时，必须同时修改栈缓冲区和相应的金丝雀值。如果金丝雀值被修改，检测机制就会触发并采取相应的措施。</p></li>
<li><p>ASLR（Address Space Layout Randomization）： ASLR
是一种操作系统级的安全技术，旨在增加攻击者对系统内存布局的预测难度。除了栈随机化之外，ASLR
还包括对代码段、堆、共享库等内存区域的随机化。</p>
<p>在 Linux 中，启用 ASLR
后，操作系统会在每次程序加载时，随机地将程序的内存布局进行重排。这意味着相同的程序在不同的运行实例中，其内存布局会发生随机变化。</p>
<p>ASLR
防止了许多常见的攻击技术，如栈溢出、代码注入等。通过随机化内存布局，攻击者无法准确预测关键数据和代码的位置，从而增加了攻击的难度。</p></li>
</ol>
<h3 id="支持变长栈帧">支持变长栈帧</h3>
<p>支持变长栈帧（Variable Length Stack
Frames）是一种在函数调用过程中动态调整栈帧大小的技术。这通常用于支持具有可变数量参数或动态分配局部变量的函数。下面是几种常见的支持变长栈帧的方法：</p>
<ol type="1">
<li><p>栈指针调整：
变长栈帧的一种常见方法是通过在函数开始时动态调整栈指针来为变量分配空间。这通常涉及使用额外的指令来增加或减少栈指针的偏移量，以适应变量的大小。</p>
<p>例如，对于具有可变数量参数的函数，可以使用类似于C语言中的<code>va_list</code>和相关的宏（如<code>va_start</code>和<code>va_end</code>）来获取参数的地址，并使用栈指针调整来分配和访问参数。</p></li>
<li><p>动态分配空间：
另一种支持变长栈帧的方法是通过动态分配空间来容纳变量。这可以通过在堆上分配内存并将指针存储在栈帧中来实现。</p>
<p>例如，如果函数需要动态分配一个可变大小的数组，可以使用堆分配函数（如<code>malloc</code>）来分配内存，并将返回的指针存储在栈帧中的变量中。在函数结束时，需要确保释放已分配的内存，以避免内存泄漏。</p></li>
<li><p>额外的栈帧元数据：
对于支持变长栈帧的函数，通常需要存储关于栈帧结构的额外元数据信息。这些信息可以包括参数的数量、大小以及局部变量的数量和偏移量等。</p>
<p>这些额外的栈帧元数据通常存储在特定的位置，如栈帧的开头或结尾。通过解析和使用这些元数据，函数可以动态地访问和操作变长栈帧中的变量。</p></li>
</ol>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>裘千丈
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://vinouno.github.io/posts/adc3eca/" title="CSAPP 第三章：程序的机器级表示">https://vinouno.github.io/posts/adc3eca/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/CSAPP/" rel="tag"># CSAPP</a>
              <a href="/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" rel="tag"># 汇编语言</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/b47441a5/" rel="prev" title="2211. 统计道路上的碰撞次数">
      <i class="fa fa-chevron-left"></i> 2211. 统计道路上的碰撞次数
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/10ee4f95/" rel="next" title="考研复试：英语口语常问问题">
      考研复试：英语口语常问问题 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#csapp-%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA"><span class="nav-number">1.</span> <span class="nav-text">CSAPP
第三章：程序的机器级表示</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%86%E5%8F%B2%E8%A7%82%E7%82%B9"><span class="nav-number">1.1.</span> <span class="nav-text">3.1 历史观点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">摩尔定律</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#x86%E5%92%8Cx86-64"><span class="nav-number">1.1.2.</span> <span class="nav-text">X86和X86-64</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A0%81"><span class="nav-number">1.2.</span> <span class="nav-text">3.2 程序编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E8%BF%87%E7%A8%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">汇编过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#attatt%E5%92%8Cintel%E7%9A%84%E8%AF%AD%E6%B3%95%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.2.</span> <span class="nav-text">ATT（AT&amp;T）和Intel的语法区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">3.3 数据格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E4%BF%A1%E6%81%AF"><span class="nav-number">1.4.</span> <span class="nav-text">3.4 访问信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#x86-64%E4%B8%AD%E7%9A%84%E6%95%B4%E6%95%B0%E5%AF%84%E5%AD%98%E5%99%A8"><span class="nav-number">1.4.1.</span> <span class="nav-text">X86-64中的整数寄存器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8C%87%E7%A4%BA%E7%AC%A6"><span class="nav-number">1.4.2.</span> <span class="nav-text">操作数指示符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%8C%87%E4%BB%A4"><span class="nav-number">1.4.3.</span> <span class="nav-text">数据传输指令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%8B%E5%85%A5%E5%92%8C%E5%BC%B9%E5%87%BA%E6%A0%88%E6%95%B0%E6%8D%AE"><span class="nav-number">1.4.4.</span> <span class="nav-text">压入和弹出栈数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C"><span class="nav-number">1.5.</span> <span class="nav-text">3.5 算术逻辑操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80"><span class="nav-number">1.5.1.</span> <span class="nav-text">加载有效地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E5%85%83%E5%92%8C%E4%BA%8C%E5%85%83%E6%93%8D%E4%BD%9C"><span class="nav-number">1.5.2.</span> <span class="nav-text">一元和二元操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A7%BB%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="nav-number">1.5.3.</span> <span class="nav-text">移位操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E7%AE%97%E6%9C%AF%E6%93%8D%E4%BD%9C"><span class="nav-number">1.5.4.</span> <span class="nav-text">特殊的算术操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6"><span class="nav-number">1.6.</span> <span class="nav-text">3.6 控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="nav-number">1.6.1.</span> <span class="nav-text">条件码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%9D%A1%E4%BB%B6%E7%A0%81"><span class="nav-number">1.6.2.</span> <span class="nav-text">访问条件码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B7%B3%E8%BD%AC"><span class="nav-number">1.6.3.</span> <span class="nav-text">跳转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6"><span class="nav-number">1.6.4.</span> <span class="nav-text">用条件控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B"><span class="nav-number">1.7.</span> <span class="nav-text">3.7 过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A0%88"><span class="nav-number">1.7.1.</span> <span class="nav-text">运行时栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6"><span class="nav-number">1.7.2.</span> <span class="nav-text">转移控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81"><span class="nav-number">1.7.3.</span> <span class="nav-text">数据传送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E4%B8%8A%E7%9A%84%E5%B1%80%E9%83%A8%E5%82%A8%E5%AD%98"><span class="nav-number">1.7.4.</span> <span class="nav-text">栈上的局部储存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E5%82%A8%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="nav-number">1.7.5.</span> <span class="nav-text">寄存器中的局部储存空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E9%85%8D%E5%92%8C%E8%AE%BF%E9%97%AE"><span class="nav-number">1.8.</span> <span class="nav-text">3.8 数组的分配和访问</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="nav-number">1.8.1.</span> <span class="nav-text">基本原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E7%9A%84%E6%95%B0%E7%BB%84"><span class="nav-number">1.8.2.</span> <span class="nav-text">嵌套的数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E9%95%BF%E6%95%B0%E7%BB%84%E5%92%8C%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84"><span class="nav-number">1.8.3.</span> <span class="nav-text">定长数组和变长数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E8%B4%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.9.</span> <span class="nav-text">3.9 异质的数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">1.9.1.</span> <span class="nav-text">结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E5%90%88"><span class="nav-number">1.9.2.</span> <span class="nav-text">联合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90"><span class="nav-number">1.9.3.</span> <span class="nav-text">数据对齐</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8%E6%9C%BA%E5%99%A8%E7%BA%A7%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%B0%86%E6%8E%A7%E5%88%B6%E6%AC%B2%E6%95%B0%E6%8D%AE%E7%BB%93%E5%90%88%E8%B5%B7%E6%9D%A5"><span class="nav-number">1.10.</span> <span class="nav-text">3.10
在机器级程序中将控制欲数据结合起来</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">1.10.1.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E8%B6%8A%E7%95%8C%E5%BC%95%E7%94%A8%E5%92%8C%E7%BC%93%E5%AD%98%E5%8C%BA%E6%BA%A2%E5%87%BA"><span class="nav-number">1.10.2.</span> <span class="nav-text">内存越界引用和缓存区溢出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E6%8A%97%E7%BC%93%E5%AD%98%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB"><span class="nav-number">1.10.3.</span> <span class="nav-text">对抗缓存区溢出攻击</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%AF%E6%8C%81%E5%8F%98%E9%95%BF%E6%A0%88%E5%B8%A7"><span class="nav-number">1.10.4.</span> <span class="nav-text">支持变长栈帧</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="裘千丈"
      src="/images/head.png">
  <p class="site-author-name" itemprop="name">裘千丈</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">76</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">77</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">裘千丈</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">98k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">2:44</span>
</div>

<!--
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>
-->

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>